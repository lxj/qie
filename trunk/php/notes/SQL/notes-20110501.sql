-- phpMyAdmin SQL Dump
-- version 2.11.6
-- http://www.phpmyadmin.net
--
-- 主机: localhost
-- 生成日期: 2011 年 05 月 01 日 00:57
-- 服务器版本: 6.0.4
-- PHP 版本: 5.2.0RC4

SET SQL_MODE="NO_AUTO_VALUE_ON_ZERO";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;

--
-- 数据库: `notes`
--

-- --------------------------------------------------------

--
-- 表的结构 `list`
--

CREATE TABLE IF NOT EXISTS `list` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'id',
  `title` varchar(100) NOT NULL,
  `content` text NOT NULL COMMENT '内容',
  `cat` varchar(500) NOT NULL COMMENT '分类',
  `time` varchar(50) NOT NULL COMMENT '时间',
  PRIMARY KEY (`id`)
) ENGINE=MyISAM  DEFAULT CHARSET=gbk AUTO_INCREMENT=552 ;

--
-- 导出表中的数据 `list`
--

INSERT INTO `list` (`id`, `title`, `content`, `cat`, `time`) VALUES
(2, 'Frame中的scrolling="yes/no/auto"', '在设置Frame时，有一属性是scrolling="yes/no/auto"，IE6的mozilla都支持，但很显然地，IE的开发人员在这个地方懒了一下，他们对auto的理解很不人性化。auto的意思是自动，就是要的时候有，不要的时候没有。但如果设成auto，则在网页过长需要出竖起滚动条时，IE会自动地把水平滚动条也显示出来，哪怕网页完全不超宽。而设成yes时，IE则会一直出竖直滚动条，而不随便出水平条，这差不多是对的。所以如果要用Frame的话，还是要把这个属性设成Yes，这完全是为迁就IE。 mozilla则在任何时候都是对的。(google) \r\n', 'CSS', '2011-01-05 21:12:30'),
(5, 'CSS方法解决chrome 12像素字体限制', '<p>CSS方法解决chrome 12像素字体限制：中文版的chrome有个12px字体限制的问题，就是当字体小于12px时候都以12px来显示，可以使用Webkit 的内核的 -webkit-text-size-adjust 的私有 CSS 属性来解决，比如下面的代码就可以成功的解决，通过它即可实现字体大小不随终端设备或浏览器影响。样式定义如下： #chrome10px{ -webkit-text-size-adjust:none; font-size:10px}</p>', 'CSS', '2011-01-05 21:00:30'),
(4, 'FCKeditor', '<pre class="brush: jscript;" title="code">\r\nvar oFCKeditor = new FCKeditor(''content'');//传入参数为表单元素（由FCKeditor生成的input或textarea）的name\r\noFCKeditor.BasePath=''FCKEditor-syntaxhighlight/fckeditor/'';//指定FCKeditor根路径，也就是fckeditor.js所在的路径\r\noFCKeditor.Height=''200px'';\r\noFCKeditor.ToolbarSet=''Syntax2Demo'';//&lsquo;Default&rsquo;指定工具栏\r\noFCKeditor.Value=&quot;&quot;;//默认值\r\noFCKeditor.Create();\r\n</pre>', 'FCKeditor', '2011-04-30 12:37:46'),
(7, 'table的浮动', '<p>给table定义align=&quot;left&quot;或align=&quot;right&quot;时就像是给div标签定义浮动，所以记得给父层定义清除浮动的样式，要不然js获取父层的offsetHeight时其值时0</p>', 'CSS', '2011-01-04 21:11:30'),
(6, 'iframe,object和img底部会有间隙', 'iframe,object和img一样，有时候在非IE浏览器下底部会有间隙，定义vertical-align:top清除下就行了', 'CSS', '2011-01-04 21:31:30'),
(3, '更改SVN中已经提交的版本的注释', '更改SVN中已经提交的版本的注释，提示说“请管理员创建pre-revprop-change钩子”，解决方法为在hooks目录下创建pre-revprop-change.bat，里面的代码如下：pre-revprop-change.bat所示(google) \r\n', 'SVN', '2011-01-05 21:10:30'),
(1, 'input按钮文字隐藏', '用line-height:9999px可以达到隐藏input按钮的文字的效果\r\n', 'CSS', '2011-01-05 21:31:30'),
(8, 'text-indent:-9999px隐藏input按钮文字要注意的细节', '<p>用text-indent:-9999px隐藏input按钮的文字时，一定要给这按钮float或display:block样式，否则在IE6和IE7下会出现整行显示不了的问题。</p>', 'CSS', '2011-04-30 15:34:20'),
(9, '有浮动没有清除的层在FF下用js获取到的offsetheight的值为0', '有浮动没有清除的层在FF下用js获取到的offsetheight的值为0\r\n', 'JavaScript', '2011-01-03 20:31:30'),
(10, 'Web性能优化', 'Web性能优化最佳实践中最重要的一条是减少HTTP请求，它也是YSlow中比重最大的一条规则。减少HTTP请求的方案主要有合并JavaScript和CSS文件、CSS Sprites、图像映射（Image Map）和使用Data URI来编码图片。CSS Sprites和图像映射现在已经随处可见了，但由于IE6和IE7不支持Data URI以及性能问题，这项技术尚未大量使用。目前大部分网页中的JavaScript和CSS文件数量和开发时一致，少量的网页会根据实际情况采取本地合并，这些合并中相当多的是有选择地手动完成，每次新的合并都需要重新在本地完成并上传到服务器，比较的随意和繁琐，同样文件的压缩也有类似的情况。而利用服务端的合并和压缩，我们就可以按照开发的逻辑尽可能让文件的颗粒度变小，利用网页中URL的规则来自动实现文件的合并和压缩，这会相当的灵活和高效。(<a href="http://dancewithnet.com/2010/06/08/minify-js-and-css-files-in-server/" target="_blank">随网之舞</a>)', '性能', '2011-01-03 20:21:30'),
(11, 'a链接标签妙用', 'a链接标签不错，设置了href属性时就表现出了a标签的独特之处，没有设置href属性时它就是一个没有手型没有链接的内联元素非常好用\r\n', 'CSS', '2011-01-03 20:20:30'),
(16, 'textarea滚动条', '<p>IE下textarea文本区域默认是有滚动的，其他浏览器只有当内容输入过多的时候才出现滚动条。设置了overflow:hidden时，在所有浏览器中就算输入的内容再多滚动条都是被隐藏。设置overflow:auto时，在所有浏览器中都没滚动条，只有在内容输入过多时才出现滚动条，这很人性化(Opera除外)。</p>', 'CSS', '2011-04-30 21:50:07'),
(15, 'CSS3旋转', '<pre class="brush: css;" title="code">\r\n-o-transform:rotate(30deg); -moz-transform:rotate(30deg); -webkit-transform:rotate(30deg);</pre>', 'CSS3', '2011-01-02 19:10:30'),
(13, 'CSS3圆角', '<pre title="code" class="brush: css;">\r\nborder-radius:10px;-moz-border-radius:10px;-webkit-border-radius:10px;border:1px solid #eee</pre>', 'CSS3', '2011-01-03 19:10:30'),
(14, 'CSS3阴影', '<pre class="brush: css;" title="code">\r\nbox-shadow:5px 5px 5px #333; -moz-box-shadow:5px 5px 5px #333;-webkit-box-shadow:5px 5px 5px #999;</pre>', 'CSS3', '2011-01-02 19:10:30'),
(393, 'Firefox3下的getElementsByClassName', '<p>Firefox3实现的原生getElementsByClassName方法返回的不是javascript数组（Array），而是html element collection，这个东西可以用标准的方式遍历，但是却与Array没有共同的prototype（这个指javascript里面的原型继承的prototype）。所以，很不幸，如果你用了Prototype库的那个返回Array的方法写程序，然后使用了Array增强方法里面的first()等方法或者Emmerable里面的each()等方法，那么程序一定会出错。此时你可以$A一下这个html element collection，但是这不是好方法。因为其实Prototype在1.6以后就不推荐使用getElementsByClassName方法了。</p>', 'JavaScript', '2011-04-30 21:51:28'),
(394, 'CSS个浏览器hack', '<pre class="brush: css;" title="code">\r\n#test{ \r\n　　　　　　　　color:red; /* 所有浏览器都支持 */ \r\n　　　　　　　　color:red !important;/* Firefox、IE7支持 */ \r\n　　　　　　　　_color:red; /* IE6支持 */ \r\n　　　　　　　　*color:red; /* IE6、IE7支持 */ \r\n　　　　　　　　*+color:red; /* IE7支持 */ \r\n　　　　　　　　color:red\\9; /* IE6、IE7、IE8支持 */ \r\n　　　　　　　　color:red\\0; /* IE8支持 */ \r\n　　　　　　　　} \r\nbody:nth-of-type(1) p{color:red;} /* Chrome、Safari支持 */\r\n</pre>', 'CSS', '2011-04-30 15:34:48'),
(395, '设置file input的尺寸', '<p>通常情况下给file input设置宽或是设置size都不能把浏览按钮的宽度增宽，其实只要设置font-size就可以达到给浏览按钮增加宽度。</p>', 'CSS', '2011-04-30 21:52:16'),
(396, 'Lazyload实现方式', '<p>把有图片的标签的HTML放在textarea标签内作为value，或者作为一段HTML的注释，这样可以使浏览器略过分析该HTML，图片也就不会加载</p>', 'CSS', '2011-04-30 21:52:53'),
(403, '开启Fckeditor上传图片功能', '<p><strong>开启Fckeditor上传图片功能<br />\r\n</strong></p>\r\n<p>打开editor/filemanager/connectors/php目录下config.php，找到<br />\r\n&nbsp;</p>\r\n<pre class="brush: php;" title="code">\r\n$Config[''Enabled''] = false ; </pre>\r\n<p>更改为</p>\r\n<p>&nbsp;</p>\r\n<pre class="brush: php;" title="code">\r\n$Config[''Enabled''] = true ; </pre>\r\n<p>并在相应目录下建立userfiles上传目录后，Fckeditor上传图片功能开启。</p>\r\n<p>&nbsp;</p>\r\n<p>打开editor/filemanager/connectors/php目录下config.php文件，找到<br />\r\n&nbsp;</p>\r\n<pre class="brush: php;" title="code">\r\n$Config[''UserFilesPath''] = ''/userfiles/'' ; \r\n</pre>\r\n<p>更改为</p>\r\n<pre class="brush: php;" title="code">\r\n$Config[''UserFilesPath''] = ''/项目目录/userfiles/'' ; </pre>\r\n<p><strong>注意：此处userfiles文件夹是针对http://localhost/的根目录而言的。</strong></p>\r\n<p>&nbsp;</p>\r\n<p><strong>Fckeditor上传图片文件名重名及中文乱码解决方法</strong></p>\r\n<p>&nbsp;打开editor/filemanager/connectors/php目录下commands.php，找到FileUpload函数，在<br />\r\n&nbsp;</p>\r\n<pre class="brush: php;" title="code">\r\n$sExtension = substr( $sFileName, ( strrpos($sFileName, ''.'') + 1 ) ) ;\r\n$sExtension = strtolower( $sExtension ) ; </pre>\r\n<p>后添加</p>\r\n<p>&nbsp;</p>\r\n<pre class="brush: php;" title="code">\r\n$sFileName = rand(0,100).&quot;.&quot;.$sExtension; </pre>\r\n<p>此处rand函数可根据需要自行改变重命名规则。</p>\r\n<p>　　另一种上传图片文件名乱码解决方法为使用iconv函数对文件名进行编码转换，但仍然存在重名问题，所以针对Fckeditor上传图片文件名最好还是重命名。</p>', 'FCKEditor', '2011-01-07 22:49:29'),
(408, 'FCKeditor', '<pre class="brush: jscript;" title="code">\r\nFCKConfig.ImageUpload = true ;\r\nFCKConfig.ImageUploadURL = FCKConfig.BasePath + ''filemanager/connectors/'' + _QuickUploadLanguage + ''/connector.'' + _QuickUploadExtension + ''?Command=FileUpload&amp;Type=Image&amp;CurrentFolder=%2F'' ;\r\nFCKConfig.ImageUploadAllowedExtensions	= &quot;.(jpg|gif|jpeg|png|bmp)$&quot; ;		// empty for all\r\nFCKConfig.ImageUploadDeniedExtensions	= &quot;&quot; ;							// empty for no one</pre>\r\n<p>FCKConfig.ImageUploadURL的地址改成如上所示后，通过点击图片按钮上传的图片就会自动放在image文件夹中去了。</p>', 'FCKeditor', '2011-01-07 23:21:14'),
(547, 'HTML5自定义属性的规范', '<p><a href="http://www.infoq.com/cn/articles/dojo-1.6-html5">http://www.infoq.com/cn/articles/dojo-1.6-html5</a></p>\r\n<p>HTML5中已经有了针对自定义属性的规范。所有自定义属性都必须以data-作为前缀。这样就可以很方便的将HTML标准属性与自定义属性区分开来，不仅提供了代码的可读性也避免了与标准属性冲突的风险。</p>', 'HTML5', '2011-04-30 16:06:13'),
(548, '翻译：HTML5介绍：视频和音频<三>', '<p>&nbsp;<a href="http://www.riameeting.com/node/803">http://www.riameeting.com/node/803</a></p>', 'HTML5', '2011-04-30 16:06:49'),
(544, 'tagName vs nodeName', '<p>&nbsp;<a href="http://aleembawany.com/2009/02/11/tagname-vs-nodename/">http://aleembawany.com/2009/02/11/tagname-vs-nodename/</a></p>', 'JavaScript', '2011-04-30 14:54:15'),
(545, '异步加载脚本', '<p>参考资料</p>\r\n<ol>\r\n <li><a href="http://www.cnblogs.com/rubylouvre/archive/2011/04/12/2011175.html">http://www.cnblogs.com/rubylouvre/archive/2011/04/12/2011175.html</a></li>\r\n <li><a href="http://www.iteye.com/topic/1019020">http://www.iteye.com/topic/1019020</a></li>\r\n <li><a href="http://bbs.blueidea.com/thread-3020271-1-1.html">http://bbs.blueidea.com/thread-3020271-1-1.html</a></li>\r\n</ol>', 'JavaScript', '2011-04-30 15:13:43'),
(551, 'JS中getElementsByTagName()', '在JS中getElementsByTagName()获得的是一个类似于数组的NodeList对象，但除了有个length属性和下标取值以外再也没有别的数组方法了，因为他不是一个真正的数组对象。', 'JavaScript', '2011-04-30 17:20:53'),
(433, '形式参数和实际参数', '<p>函数的参数分为形参和实参两种。在本小节中，进一步介绍形参、实参的特点和两者的关系。形参出现在函数定义中，在整个函数体内都可以使用，离开该函数则不能使用。实参出现在主调函数中，进入被调函数后，实参变量也不能使用。形参和实参的功能是作数据传送。发生函数调用时，主调函数把实参的值传送给被调函数的形参从而实现主调函数向被调函数的数据传送。 函数的形参和实参具有以下特点：&nbsp;<br />\r\n1. 形参变量只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元。因此，形参只有在函数内部有效。函数调用结束返回主调函数后则不能再使用该形参变量。&nbsp;<br />\r\n2. 实参可以是常量、变量、表达式、函数等，无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值，以便把这些值传送给形参。因此应预先用赋值，输入等办法使实参获得确定值。&nbsp;<br />\r\n3. 实参和形参在数量上，类型上，顺序上应严格一致，否则会发生类型不匹配&rdquo;的错误。&nbsp;<br />\r\n4. 函数调用中发生的数据传送是单向的。即只能把实参的值传送给形参，而不能把形参的值反向地传送给实参。 因此在函数调用过程中，形参的值发生改变，而实参中的值不会变化。</p>\r\n<div id="postmessage_183841">就例如一下一段函数</div>\r\n<pre title="code" class="brush: jscript;">\r\nvar a;\r\na = 0;\r\nfunction func(b)\r\n{\r\nb = 1;\r\ndocument.write(b);\r\n}\r\ndocument.write(a+&quot;&lt;br&gt;&quot;)\r\nfunc(a);\r\ndocument.write(&quot;&lt;br&gt;&quot;+a)</pre>\r\n<div>我希望的是，变量a经过func(a)之后，变成1，<br />\r\n但是出了这个func()这个函数体之后，a的值还是0。<br />\r\n这下大家应该明白了吧。<br />\r\n有什么办法使得a出了这个func()这个函数体之后，a的值变成1呢？<br />\r\n这个就是形参和实参的区别啦。</div>', 'CSS', '2011-04-30 22:51:07'),
(434, '我是一个最硬心软的人，不关心的人我是不骂他的', '<p>&nbsp;我是一个最硬心软的人，不关心的人我是不骂他的</p>', 'CSS', '2011-01-08 23:39:30'),
(439, 'Javascript取和设FCKeditor值', '<p>利用Javascript取和设FCKeditor值也是非常容易的，如下：</p>\r\n<pre title="code" class="brush: jscript;">\r\n// 获取编辑器中HTML内容 \r\nfunction getEditorHTMLContents(EditorName) { \r\nvar oEditor = FCKeditorAPI.GetInstance(EditorName); \r\nreturn(oEditor.GetXHTML(true)); \r\n} \r\n\r\n// 获取编辑器中文字内容 \r\nfunction getEditorTextContents(EditorName) { \r\nvar oEditor = FCKeditorAPI.GetInstance(EditorName); \r\nreturn(oEditor.EditorDocument.body.innerText); \r\n} \r\n\r\n// 设置编辑器中内容 \r\nfunction SetEditorContents(EditorName, ContentStr) { \r\nvar oEditor = FCKeditorAPI.GetInstance(EditorName) ; \r\noEditor.SetHTML(ContentStr) ; \r\n}</pre>\r\n<p>&nbsp;</p>', 'FCKeditor', '2011-01-09 10:23:00'),
(473, 'Lazyload', '<p>Lazyload的一个作用就是延迟html渲染。原理是先保存元素里面的html，当判断元素在加载范围里面时，再加载里面的html。程序主要是做判断的部分，而如何保存和加载就看各位的想象力了。以下几种方法个人认为还不错的： <br />\r\n1，ajax法：保存地址，加载时利用ajax读取实际内容并插入到元素中；使用恰当的话能有效节省服务器资源，特别是要读数据库的地方，但响应速度受网络影响，而且不利seo，类似的还可以用iframe。 <br />\r\n2，textarea法：把html保存到一个textarea中，加载时把value插入元素中；利用了textarea的特性，第二个实例就使用了这个方法，淘宝用的也是这个方式，使用简单，响应速度快。不过仅仅是html的话，貌似也没必要延迟，可以考虑关联一些dom操作之类的。 <br />\r\n2，注释法：把html保存到一个注释中，加载时把内容插入元素中；跟textarea法类似，但效率应该更好，加载时找出nodeType为8的节点，再把nodeValue插入元素中；但在ie如果用innerHTML添加注释会被自动忽略掉，使用时注意。</p>', '性能', '2011-01-09 20:47:22'),
(474, '去掉字符串的空格', '<pre class="brush: jscript;" title="code">\r\n	//去掉字符串的空格\r\n	String.prototype.trim = function(){\r\n		return this.replace(/(^[\\s]*)|([\\s]*$)/g, &quot;&quot;);\r\n	}\r\n</pre>', 'JavaScript', '2011-01-09 20:51:50'),
(476, 'Firefox、chrome、safari中的textarea控件拉伸的功能', '<p>目前的Firefox、chrome、safari中的textarea控件，可以有拉伸的功能，有时这非常酷，但再好的东西并不是所有人都喜欢，你可以用CSS把这个功能屏蔽掉。 <br />\r\n解决方法:</p>\r\n<pre class="brush: css;" title="code">\r\nresize: none;</pre>\r\n<p>或者:</p>\r\n<pre class="brush: css;" title="code">\r\n    max-width:300px; \r\n    max-height:300px; \r\n    width:300px; \r\n    height:300px;  </pre>', 'CSS', '2011-01-10 19:34:10'),
(484, '电脑对比', '<p><a href="http://product.pchome.net/compare_param_289672,300808.html">http://product.pchome.net/compare_param_289672,300808.html</a></p>\r\n<p><a href="http://php.tech.sina.com.cn/notebook/compare.php?d_id=10755,9848">http://php.tech.sina.com.cn/notebook/compare.php?d_id=10755,9848</a></p>', '随笔', '2011-04-30 21:53:37'),
(485, 'Clarksfield和Arrandale', '<p><span style="color: rgb(255, 0, 0);"><strong>Clarksfield比Arrandale好</strong></span></p>\r\n<p>Arrandale是目前酷睿i3/i5处理器的内核代号，Clarksfield是酷睿i7的内核代号，不是架构。Arrandale内核的处理器均采用32nm工艺制作，为双核四线程，有3或4MB的三级缓存，内部集成GPU。Clarksfield采用45nm工艺制作，为四核八线程，有6或8MB的三级缓存，所以从性能上后者明显强于前者</p>', '随笔', '2011-01-15 10:45:34'),
(543, 'JavaScript的事件代理', '<p>参考资料</p>\r\n<ol>\r\n    <li><a target="_blank" href="http://www.danwebb.net/2008/2/8/event-delegation-made-easy-in-jquery">http://www.danwebb.net/2008/2/8/event-delegation-made-easy-in-jquery</a></li>\r\n    <li><a target="_blank" href="http://blog.csdn.net/weinideai/archive/2009/01/19/3835839.aspx">http://blog.csdn.net/weinideai/archive/2009/01/19/3835839.aspx</a></li>\r\n    <li><a target="_blank" href="http://ghsky.com/2010/08/kissy-event-model-part-two.html">http://ghsky.com/2010/08/kissy-event-model-part-two.html</a></li>\r\n</ol>\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>\r\n<p><span style="font-family: Arial;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你想给网页添加点JavaScript的交互性，也许你已经听过JavaScript的<span style="color: #ff0000;">事件代理</span>（<span style="color: #ff0000;">event delegation</span>），并且觉得这是那些发烧友级别的JavaScript程序员才会关心的什么费解的设计模式之一。事实上，如果你已经知道怎么添加JavaScript的<span style="color: #ff0000;">事件处理器</span>（<span style="color: #ff0000;">event handler</span>），实现事件代理也是件轻而易举的事情。</span></p>\r\n<p><span style="font-family: Arial;">&nbsp;&nbsp;&nbsp;&nbsp; JavaScript事件是所有网页互动性的根基（我指的是<span style="background-color: #ff9900;">真正的互动性</span>，而不仅是那些<span style="background-color: #ff9900;">CSS下拉菜单</span>）。在传统的事件处理中，你按照需要为每一个元素添加或者是删除事件处理器。然而，<span style="color: #339966;">事件处理器</span>将有可能<span style="color: #339966;">导致</span><span style="background-color: #ff9900;">内存泄露或者是性能下降</span>&mdash;&mdash;你用得越多这种风险就越大。<span style="color: #339966;">JavaScript事件代理</span>则是<span style="color: #339966;">一种简单的技巧</span>，通过它你可以把<span style="color: #339966;">事件处理器</span><span style="background-color: #ff9900;">添加</span>到<span style="color: #339966;">一个父级元素</span>上，这样就避免了把事件处理器添加到多个子级元素上。</span></p>\r\n<p><span style="font-family: Arial;"><strong>它是怎么运作的呢？</strong></span></p>\r\n<p><span style="font-family: Arial;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #339966;">事件代理</span>用到了<span style="color: #339966;">两个</span>在JavaSciprt事件中<span style="background-color: #ff9900;">常被忽略</span>的<span style="color: #339966;">特性</span>：<span style="color: #ff0000;">事件冒泡</span>以及<span style="color: #ff0000;">目标元素</span>。当一个元素上的事件被触发的时候，比如说鼠标点击了一个按钮，<span style="color: #ff0000;">同样的事件</span>将会在<span style="background-color: #ff9900;">那个元素的所有祖先元素</span>中<span style="color: #ff0000;">被触发</span>。这一过程被称为<span style="color: #ff0000;">事件冒泡</span>；这个事件从<span style="color: #ff0000;">原始元素</span>开始一直<span style="color: #ff0000;">冒泡到</span><span style="background-color: #ff9900;">DOM树的</span><span style="color: #ff0000;">最上层</span>。任何一个事件的<span style="color: #ff0000;">目标元素</span>都是<span style="background-color: #ff9900;">最开始的那个元素</span>，在我们的这个例子中也就是按钮，并且它在我们的元素对象中<span style="color: #ff0000;"><span style="text-decoration: underline;">以属性的形式</span></span>出现。使用事件代理，我们可以把<span style="color: #ff0000;">事件处理器</span><span style="color: #339966;">添加</span>到<span style="color: #ff0000;">一个元素上</span>，等待<span style="color: #ff0000;">一个事件</span>从<span style="color: #339966;">它的子级元素</span>里<span style="color: #ff0000;">冒泡上来</span>，并且可以得知这个事件是<span style="color: #339966;">从哪个元素开始</span>的。</span></p>\r\n<p><span style="font-family: Arial;"><strong>这对我有什么好处呢？</strong></span></p>\r\n<p><span style="font-family: Arial;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 想象一下现在我们有一个10列、100行的HTML表格，你希望在用户点击表格中的某一单元格的时候做点什么。比如说我有一次就需要让表格中的每一个单元格在被点击的时候变成可编辑状态。如果把事件处理器加到这1000个单元格会产生一个很大的性能问题，并且有可能导致内存泄露甚至是浏览器的崩溃。相反地，使用事件代理，你只需要把<span style="color: #339966;">一个事件处理器</span><span style="background-color: #ff9900;">添加到</span><span style="color: #339966;">table元素上</span>就可以了，这个函数可以把<span style="color: #339966;">点击事件</span>给截下来，并且判断出是哪个单元格被点击了。</span></p>\r\n<p><span style="font-family: Arial;"><strong>用代码写出来是什么样呢？</strong></span></p>\r\n<p><span style="font-family: Arial;">&nbsp;&nbsp;&nbsp;&nbsp; 代码很简单，我们所要关心的只是如何检测目标元素而已。比方说我们有一个table元素，ID是&ldquo;report&rdquo;，我们为这个表格<span style="background-color: #ff9900;">添加</span><span style="color: #339966;">一个事件处理器</span>以<span style="color: #339966;">调用editCell函数</span>。editCell函数<span style="color: #ff0000;">需要判断</span><span style="background-color: #ff9900;">传到table来的事件</span>的<span style="color: #ff0000;">目标元素</span>。考虑到我们要写的几个函数中都有可能用到这一功能，所以我们把它单独放到一个名为getEventTarget的函数中：</span></p>\r\n<p><span style="font-family: Arial;">function getEventTarget(e) {<br />\r\n&nbsp; e = e || window.event;<br />\r\n&nbsp; return e.target || e.srcElement;<br />\r\n}</span></p>\r\n<p><span style="font-family: Arial;"><span style="color: #ff0000;">e</span>这个变量表示的<span style="color: #ff0000;">是</span>一个<span style="color: #ff0000;">事件对象</span>，我们只需要写一点点跨浏览器的代码来返回<span style="background-color: #339966;">目标元素</span>，在IE里目标元素放在srcElemnt属性中，而在其它浏览器里则是target属性。</span></p>\r\n<p><span style="font-family: Arial;">接下来就是editCell函数了，这个函数调用到了getEventTarget函数。一旦我们得到了目标元素，剩下的事情就是看看它是否是我们所需要的那个元素了。</span></p>\r\n<p style="padding-left: 30px;"><span style="font-family: Arial;">function editCell(e) </span></p>\r\n<p style="padding-left: 30px;"><span style="font-family: Arial;">{<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;var target = getEventTarget(e);<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(target.tagName.toLowerCase() ==''td'') </span></p>\r\n<p style="padding-left: 30px;"><span style="font-family: Arial;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DO SOMETHING WITH THE CELL<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />\r\n}</span></p>\r\n<p><span style="font-family: Arial;">在editCell函数中，我们通过检查<span style="color: #339966;">目标元素标签名称</span>的方法来确定它是否是一个表格的单元格。这种检查也许过于简单了点；如果它是这个目标元素单元格里的另一个元素呢？我们需要为代码做一点小小的修改以便于其找出父级的td元素。如果说有些单元格不需要被编辑怎么办呢？此种情况下我们可以为那些不可编辑的单元格添加一个指定的样式名称，然后在把单元格变成可编辑状态之前先检查它是否不包含那个样式名称。选择总是多样化的，你只需找到适合你应用程序的那一种。</span></p>\r\n<p><span style="font-family: Arial;"><strong>有哪些优点和缺点呢？</strong></span></p>\r\n<p><span style="font-family: Arial;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JavaScript事件代理带来的好处有：</span></p>\r\n<p><span style="font-family: Arial;">那些需要<span style="background-color: #339966;">创建的以及驻留在内存中</span>的<span style="color: #339966;">事件处理器</span>少了。这是很重要的一点，这样我们就提高了性能，并降低了崩溃的风险。 <br />\r\n在DOM更新后无须重新绑定事件处理器了。如果你的页面是动态生成的，比如说通过Ajax，你不再需要在元素被载入或者卸载的时候来添加或者删除事件处理器了。 <br />\r\n潜在的问题也许并不那么明显，但是一旦你注意到这些问题，你就可以轻松地避免它们：</span></p>\r\n<p><span style="font-family: Arial;">你的事件管理代码有成为性能瓶颈的风险，所以尽量使它能够短小精悍。 </span></p>\r\n<p><span style="font-family: Arial;">不是所有的事件都能冒泡的。blur、focus、load和unload不能像其它事件一样冒泡。事实上blur和focus可以用事件捕获而非事件冒泡的方法获得（在IE之外的其它浏览器中）。 <br />\r\n在管理鼠标事件的时候有些需要注意的地方。如果你的代码处理mousemove事件的话你遇上性能瓶颈的风险可就大了，因为mousemove事件触发非常频繁。而mouseout则因为其怪异的表现而变得很难用事件代理来管理。 </span></p>\r\n<p><span style="font-family: Arial;"><br />\r\n总结：<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 已经有一些使用主流类库的事件代理示例出现了，比如说jQuery、Prototype以及Yahoo! UI。你也可以找到那些不用任何类库的例子，比如说Usable Type blog上的这一个。</span><span style="font-family: Arial;">一旦需要的话，事件代理将是你工具箱里的一件得心应手的工具，而且它很容易实现。<br />\r\n</span></p>', 'JavaScript', '2011-04-30 22:19:45'),
(489, 'gracecode.com', '<p><a href="http://www.gracecode.com/archives/3044/">http://www.gracecode.com/archives/3044/</a></p>\r\n<p><a href="http://code.taobao.org/svn/nginx_concat_module/trunk">http://code.taobao.org/svn/nginx_concat_module/trunk</a></p>', '性能', '2011-01-17 21:21:15'),
(495, '漫谈B端的沙箱技术', '<h1><a rel="permalink" href="http://www.infoq.com/cn/articles/sandboxOnB;jsessionid=1C01966EFA805A841473BD46ECC07ED5">漫谈B端的沙箱技术</a></h1>\r\n<p><a href="http://www.infoq.com/cn/articles/sandboxOnB">http://www.infoq.com/cn/articles/sandboxOnB</a></p>\r\n<p>&nbsp;</p>\r\n<p>从语言学的角度上来说，允许代码无节制地使用全局变量，是最错误的选择之一。而更可怕的，就是一个变量&quot;可能&quot;成为全局的（在未知的时间与地点）。但是这两项，却伴随JavaScript这门语言成功地走到了现在。</p>\r\n<p>也许是限于浏览器应用的规模，所以这一切还迟迟没有酿成灾难。在此之前，出现了两种解决方案。一种是ECMA在新的规范（Edition 5）中对此做出了限制，其中最重要的一条便是eval()的使用变得不再随意和无度。而另一种方案，则是相对没有那么官僚与学术的，尽管也拥有一个同样学术的名字：沙箱。</p>\r\n<p>沙箱（Sandbox）并不是一个新东西，即使对于JavaScript来说，也已经存在了相当长的时间。在SpiderMonkey JS的源代码中，就明确地将一个闭包描述为一个沙箱。这包含着许多潜在的信息：它有一个初始环境，可以被重置，可以被复制，以及最重要的，在它内部的所有操作，不会影响到外部</p>\r\n<p>当然事实上远非如此。JavaScript里的闭包只是一个&quot;貌似沙箱&quot;的东西--仍然是出于JavaScript早期的语言规范的问题，闭包不得不允许那些&quot;合法泄漏&quot;给外部的东西。而对于这一切无法忍受的前端工程师们，开始寻求另外的解决之道，这其中相对较早的尝试，是基于IFRAME的实践。例如dean.edwards在2006年提出过的方案（注1）：</p>\r\n<pre title="code" class="brush: jscript;">\r\na_frames.document.write(\r\n  &quot;&lt;script&gt;&quot;+\r\n  &quot;var MSIE/*@cc_on =1@*/;&quot;+ // sniff\r\n  &quot;parent.sandbox=MSIE?this:{eval:function(s){return eval(s)}}&quot;+\r\n  &quot;&lt;\\/script&gt;&quot;\r\n);\r\n</pre>\r\n<p>显然，由于在不同的IFRAME中运行着各自的JavaScript引擎实例，所以上述的方案也意味着沙箱是&quot;引擎&quot;这个级别的：在任何一个沙箱中的崩溃，将导致该引擎以及对应IFRAME崩溃。但--理论上说--不会影响整个浏览器。</p>\r\n<p>问题是，这并不那么理想。往往的，引擎会导致整个浏览器锁在那里，例如用alert()弹出一个对话框而又因为某种意外失去了焦点。又或者单个的IFRAME会导致全局的CPU被耗光，例如一个死循环。于是更加复杂的方案--在JavaScritp中包含一个完整的执行器--出现了。最有名的则是Narrative JavaScript，它内建了一个执行器，用于逐行地解释执行JavaScript代码，这使得它可以控制所有的代码执行序列，或者随时重置整个执行引擎--如同一个沙箱所要做的那样。</p>\r\n<p>这一切或者太过依赖于环境，又或者太过复杂，但都不乏追随者。例如jsFiddle这个项目（注2）在&quot;嵌入或装载&quot;这样的路子上就已经有了不俗的成绩。但是，YUI在新版本中却给出了它自己的选择：以更加明确的编程约定，来实现应用级别的沙箱。这包括一个非常简单的、新的YUI语法：</p>\r\n<pre title="code" class="brush: jscript;">\r\nYUI().use(''dom-base'', function(Y) {\r\n  // Y是一个新的沙箱\r\n});\r\n</pre>\r\n<p>在''dom-base''位置上，可以是1到N个字符串，表明一个需要在沙箱中装载的模块列表。这可以是沙箱的初始列表，或者后续的callback函数(亦即是用户代码)所需依赖的模块列表。在这种实现方案中，YUI为每个沙箱维护各自的装载模块列表和上下文环境中的变量、成员。但是出于JavaScript语言自己的局限，这个沙箱依然是相当脆弱的。例如下一示例中沙箱内的代码就会污染到全局：</p>\r\n<pre title="code" class="brush: jscript;">\r\nYUI().use('''', function(Y) {\r\n  abc = 1234;  //&lt;--这里可能导致一个全局变量''abc''被隐式地声明\r\n});\r\n</pre>\r\n<p>同样，在上述的沙箱里也可以使用类似window、document等全局变量、修改它们的成员或无限制地调用方法（例如使用setTimeout()来创建时钟）。所以YUI的沙箱事实上是靠&quot;规约&quot;来约束的，而不是真正意义上的沙箱。当然，这也意味着，如果用户能按照规约来处理沙箱内的代码，那么也就能自由地享用它带来的便利：安全、移植和有效的隔离副作用。</p>\r\n<p>而我们再穷究其根底，YUI沙箱的实质不过是一行:</p>\r\n<pre title="code" class="brush: jscript;">\r\n\r\n// code from yui.js\r\n//  - mod.fn(this, name)\r\nmod.entryFunc(sandbox, modName);\r\n</pre>\r\n<p>其实际含义是：</p>\r\n<ul>\r\n    <li>mod ：沙箱当前装载的模块；</li>\r\n    <li>entryFunc : 上述模块的入口函数；</li>\r\n    <li>sandbox ：当前的沙箱的实例，即YUI()返回值；</li>\r\n    <li>modName：模块名</li>\r\n</ul>\r\n<p>除了依赖关系（以及可能需要的异步加载）之外，YUI沙箱环境仅是用下面的代码来简单地调用callback函数：</p>\r\n<pre title="code" class="brush: jscript;">\r\ncallback(Y, response);\r\n</pre>\r\n<p>然而这些需求的实现并不那么复杂。首先，我们设定数据结构mod为一个对象：</p>\r\n<pre title="code" class="brush: jscript;">\r\n{ name:modName, fn: entryFunc, req: [], use: [] }</pre>\r\n<p>则一个环境对象env，将包括多个mod(将它们处理成对象而非数组，主要是便于使用名字来索引模块)和以及对它们进行管理操作的方法：</p>\r\n<pre title="code" class="brush: jscript;">\r\n\r\n{ mods:{}, used:{}, add:..., use:...}\r\n</pre>\r\n<p>最后，所谓一个沙箱sandbox，就是上述环境对象的一个实例，并在初始时sandbox.mods与sandbox.used为空。由此简单的实现为：</p>\r\n<pre title="code" class="brush: jscript;">\r\n/**\r\n * tiny sandbox framework\r\n * mirror from YUI3 by aimingoo.\r\n**/\r\nfunction Sandbox() {\r\n  if (!(this instanceof arguments.callee)) return new arguments.callee();\r\n  this.mods = this.mods || {};\r\n  this.used = {};\r\n}\r\n\r\nSandbox.prototype = {\r\n  add: function(modName, entryFunc, reqArr, useArr) {\r\n    this.mods[modName] = { fn: entryFunc, req: reqArr, use: useArr }\r\n  },\r\n\r\n  use: function() { \r\n    var mods = [].slice.call(arguments, 0); 	// 0..length-2 is modNames\r\n    var callback = mods.pop();  	// length-1 is callback\r\n    var recursive_load = function(name, mod) {\r\n      if (!this.used[name] &amp;&amp; (mod=this.mods[name])) {\r\n        mod.req.forEach(recursive_load, this);\r\n        mod.fn(this, name);\r\n        mod.use.forEach(recursive_load, this);\r\n        this.used[name] = true;\r\n      }\r\n    }\r\n    mods.forEach(recursive_load, this);\r\n    callback(this);\r\n  }\r\n}\r\n</pre>\r\n<p>现在我们来尝试一个与YUI类似的语法风格：</p>\r\n<pre title="code" class="brush: jscript;">\r\nSandbox().use('''', function(){\r\n   alert(''user code.'');\r\n});\r\n</pre>\r\n<p>或者，先向整个Sandbox环境注册一些模块（在真实的框架实现中，这一步可能是通过框架的装载器来初始化）：</p>\r\n<pre title="code" class="brush: jscript;">\r\n\r\n// for test, entry of mods\r\nf1 = function() { alert(''f1'') };\r\nf2 = function() { alert(''f2'') };\r\nf3 = function() { alert(''f3'') };\r\n\r\n// mods for global/common env.\r\nSandbox.prototype.mods = {\r\n  ''core'': { fn: f1, req: [], use: [] },\r\n  ''oo'':   { fn: f2, req: [''core''], use: [''xml''] },\r\n  ''xml'':  { fn: f3, req: [], use: [] }\r\n}\r\n</pre>\r\n<p>然后再尝试在一个沙箱实例中运行代码：</p>\r\n<pre title="code" class="brush: jscript;">\r\n// f1 -&gt; f2 -&gt; f3 -&gt; user code\r\nSandbox().use(''oo'', function(){\r\n   alert(''user code.'');\r\n});\r\n</pre>\r\n<p>其实即便是上述代码中用于处理模块依赖的逻辑，也并不是什么&quot;神奇的&quot;代码或者技巧。除开这些，这样的沙箱隔离泄露的能力还抵不过一个嵌入式DSL语言。而后者所应用的技巧很简单，看不出什么花招（注3)：</p>\r\n<pre title="code" class="brush: jscript;">\r\nwith (YUI()) this.eval(&quot;... mod_context ... &quot;);\r\n</pre>\r\n<p>这样一来，在mod_context里的代码就只会在YUI()的一个实例中造成污染了。当然，仍然是源于JavaScript的限制，我们还是无法避免一个变量泄露到全局--除非，我们回到js in js这个项目（注4），真的在环境中重新初始化一个js引擎。</p>\r\n<p>从这一意义上来说，引擎级别的沙箱与操作系统的进程一样，带来的是终级的解决方案，所以Chrome、IE等等主流浏览器纷纷有了&quot;独立进程&quot;模式。而在这样的背景之下，试图用&quot;框架内置沙箱&quot;来改善ECMAScript ed3中一些设计疏失的种种努力，不过是一张张空头的支票罢了。</p>', 'JavaScript', '2011-03-08 8:22:02'),
(496, '[].slice.call(arguments, 0)', '<pre title="code" class="brush: jscript;">\r\nfunction lxj(){\r\n	var mods = [].slice.call(arguments, 0); //将函数的形参储存为数组\r\n	return mods;\r\n}\r\ndocument.write(lxj(1,2)+''&lt;br/&gt;'');//输出结果为:[1,2]\r\ndocument.write(lxj(1,2,3)+''&lt;br/&gt;'');//输出结果为:[1,2,3]\r\ndocument.write(lxj(''a'',''b'')+''&lt;br/&gt;'');//输出结果为:[''a'',''b'']\r\ndocument.write(lxj(''a'',''b'',''h'',''j'')+''&lt;br/&gt;'');//输出结果为:[''a'',''b'',''h'',''j'']\r\ndocument.write(lxj(''a'',''b'',''y'')+''&lt;br/&gt;'');//输出结果为:[''a'',''b'',''y'']</pre>\r\n<p>&nbsp;</p>', 'JavaScript', '2011-03-08 8:22:30'),
(501, 'css3实战:制作一个弹性滑动的图片显示', '<p>css3实战&mdash;制作一个弹性滑动的图片显示</p>\r\n<pre title="code" class="brush: css;">\r\n    .flexbox {\r\n        background-color:#ffffff;\r\n \r\n        display: -webkit-box;\r\n        display: -moz-box;\r\n        display: box;\r\n \r\n        -webkit-box-orient: horizontal;\r\n        -moz-box-orient: horizontal;\r\n        box-orient: horizontal;\r\n \r\n        box-align: stretch;\r\n        \r\n        margin-top:20px;\r\n        position: relative;\r\n        overflow:hidden;\r\n \r\n        text-shadow: 1px 1px 1px rgba(240,240,240,0.7);\r\n        \r\n        box-shadow:0 0 10px #cccccc;\r\n        -webkit-box-shadow: 0 0 10px #cccccc;\r\n        -moz-box-shadow:0 0 10px #cccccc;\r\n \r\n    }\r\n \r\n    .flexbox &gt; div {\r\n        -webkit-box-flex: 1;\r\n        -moz-box-flex: 1;\r\n        box-flex: 1;\r\n \r\n        box-align: stretch;\r\n        \r\n        -moz-transition: all 0.5s ease-out;\r\n        -o-transition: all 0.5s ease-out;\r\n        -webkit-transition: all 0.5s ease-out;\r\n        transition: all 0.5s ease-out;\r\n        width: 0;\r\n    }\r\n \r\n    .flexbox &gt; div:hover {\r\n        width: 500px;\r\n    }</pre>\r\n<pre title="code" class="brush: xhtml;">\r\n    &lt;div class=&quot;flexbox&quot;&gt; \r\n        &lt;div&gt; \r\n           &lt;img src=&quot;images/1.png&quot; alt=&quot;死神1&quot; /&gt; \r\n        &lt;/div&gt; \r\n        &lt;div&gt; \r\n            &lt;img src=&quot;images/2.png&quot; alt=&quot;死神2&quot; /&gt; \r\n        &lt;/div&gt; \r\n        &lt;div&gt; \r\n            &lt;img src=&quot;images/3.png&quot; alt=&quot;死神3&quot; /&gt; \r\n        &lt;/div&gt; \r\n        &lt;div&gt; \r\n            &lt;img src=&quot;images/1.png&quot; alt=&quot;死神4&quot; /&gt; \r\n        &lt;/div&gt; \r\n        &lt;div&gt; \r\n            &lt;img src=&quot;images/2.png&quot; alt=&quot;死神5&quot; /&gt; \r\n        &lt;/div&gt; \r\n    &lt;/div&gt; </pre>', 'CSS3', '2011-04-30 22:38:07'),
(502, '在IE下的JS编程需注意的内存释放问题', '<p>在IE下的JS编程需注意的内存释放问题</p>\r\n<p><a href="http://bbs.51js.com/viewthread.php?tid=51770">http://bbs.51js.com/viewthread.php?tid=51770</a></p>\r\n<p>在IE下的JS编程中，以下的编程方式都会造成即使关闭IE也无法释放内存的问题，下面分类给出：<br />\r\n<br />\r\n<font color="red">1、给DOM对象添加的属性是一个对象的引用。范例：</font><br />\r\nvar MyObject = {};<br />\r\ndocument.getElementById(''myDiv'').myProp = MyObject;<br />\r\n<font color="green">解决方法</font>：<br />\r\n在window.onunload事件中写上: document.getElementById(''myDiv'').myProp = null;<br />\r\n<br />\r\n<br />\r\n<font color="red">2、DOM对象与JS对象相互引用。范例：</font><br />\r\nfunction Encapsulator(element) {<br />\r\n&nbsp;&nbsp;this.elementReference = element;<br />\r\n&nbsp;&nbsp;element.myProp = this;<br />\r\n}<br />\r\nnew&nbsp;&nbsp;Encapsulator(document.getElementById(''myDiv''));<br />\r\n<font color="green">解决方法</font>：<br />\r\n在onunload事件中写上: document.getElementById(''myDiv'').myProp = null;<br />\r\n<br />\r\n<br />\r\n<font color="red">3、给DOM对象用attachEvent绑定事件。范例：</font><br />\r\nfunction doClick() {}<br />\r\nelement.attachEvent(&quot;onclick&quot;, doClick);<br />\r\n<font color="green">解决方法</font>：<br />\r\n在onunload事件中写上: element.detachEvent(''onclick'', doClick);<br />\r\n<br />\r\n<br />\r\n<font color="red">4、从外到内执行appendChild。这时即使调用removeChild也无法释放。范例：</font><br />\r\nvar parentDiv =&nbsp;&nbsp;document.createElement(&quot;div&quot;);<br />\r\nvar childDiv = document.createElement(&quot;div&quot;);<br />\r\ndocument.body.appendChild(parentDiv);<br />\r\nparentDiv.appendChild(childDiv);<br />\r\n<font color="green">解决方法</font>：<br />\r\n从内到外执行appendChild:<br />\r\nvar parentDiv =&nbsp;&nbsp;document.createElement(&quot;div&quot;);<br />\r\nvar childDiv = document.createElement(&quot;div&quot;);<br />\r\nparentDiv.appendChild(childDiv);<br />\r\ndocument.body.appendChild(parentDiv);<br />\r\n<br />\r\n<br />\r\n<font color="red">5、反复重写同一个属性会造成内存大量占用(但关闭IE后内存会被释放)。范例：</font><br />\r\nfor(i = 0; i &lt; 5000; i++) {<br />\r\n&nbsp;&nbsp;hostElement.text = &quot;asdfasdfasdf&quot;;<br />\r\n}<br />\r\n这种方式相当于定义了5000个属性！<br />\r\n<font color="green">解决方法：</font><br />\r\n其实没什么解决方法:P~~~就是编程的时候尽量避免出现这种情况咯~~</p>', 'JavaScript', '2011-04-01 8:36:04'),
(499, 'Object.prototype.toString', '<p>为什么要用Object.prototype.toString而不是Function.prototype.toString或者其它？这是和他们的toString解释方式有关系的。下面是ECMA中对Object.prototype.toString的解释：</p>\r\n<p><code>Object.prototype.toString( )<br />\r\nWhen the toString method is called, the following steps are taken:<br />\r\n1. Get the [[Class]] property of this object.<br />\r\n2. Compute a string value by concatenating the three strings &ldquo;[object &ldquo;, Result (1), and &ldquo;]&rdquo;.<br />\r\n3. Return Result (2)<br />\r\n</code></p>\r\n<p>其过程简单说来就是：1、获取对象的类名（对象类型）。2、然后将[object、获取的类名、]组合并返回。</p>\r\n<p>ECMA中对Array有如下说明：</p>\r\n<p><code>The [[Class]] property of the newly constructed object is set to &ldquo;Array&rdquo;.</code></p>\r\n<p>因此我们用如下代码来检测数组：</p>\r\n<pre><span class="keywords">function</span> isArray(o) { <br />&nbsp;&nbsp;<span class="keywords">return</span> Object.<span class="global">prototype</span>.<span class="global">toString</span>.call(o) === <span class="string">''[object Array]''</span>;&nbsp;&nbsp;<br />}</pre>\r\n<p>function isArray(o) {&lt;br/&gt;  return Object.prototype.toString.call(o) === ''[object Array]''; &lt;br/&gt;}</p>\r\n<p>这种方式既解决了instanceof存在的跨页面问题，也解决了属性检测方式所存在的问题，实在是一种妙招，一个很好的解决方案。</p>\r\n<p>除此之外，这种解决办法也可以应用于判断Date,Function等类型的对象。</p>', 'JavaScript', '2011-03-10 22:18:06'),
(500, 'You can see what we do，but we do more than what you see', '<p>前端: <br />\r\nYou can see what we do，but we do more than what you see.</p>', '随笔', '2011-04-30 21:53:59'),
(503, '程序测试题', '<p>http://bbs.51js.com/viewthread.php?tid=45812&amp;extra=page%3D1</p>\r\n<p>我认识了一个程序员,讲到我们毕业生出来工资大概多少的时候,他出了一道题,说,这个题目的月薪是1000 ,如果做不出 说明你现在可能还需要努力突破￥1000 ,而不是突破￥5000   请用程序打印出a b c d e f g h i j k l这十二个字符的全部组合，每种组合占一行 你的结果可能会是 a b c d e a b c d f &hellip;&hellip; 请用任何你熟悉的语言写出程序   10分钟内完成</p>\r\n<pre title="code" class="brush: jscript;">\r\nvar stack = new Array(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;,&quot;g&quot;,&quot;h&quot;,&quot;i&quot;,&quot;j&quot;,&quot;k&quot;,&quot;l&quot;);\r\nvar buff = new Array();\r\n\r\nfunction getComb(stack, buff)\r\n{\r\n	if(stack.length + buff.length &lt; 5) return; //字母不够了，不用再试\r\n	while(stack.length &gt; 0) //字母还没用完\r\n	{\r\n		buff.push(stack.shift()); //选取字母\r\n		if(buff.length &lt; 5) //还没到5个字母\r\n		{\r\n			getComb(stack.slice(0), buff.slice(0)); //继续选取\r\n		}\r\n		else if(buff.length == 5)\r\n		{\r\n			document.write(buff+&quot;&lt;br&gt;&quot;); //够数量了，输出\r\n		}\r\n		buff.pop(); //丢弃用过的字母\r\n	}\r\n\r\n	return;\r\n}\r\ngetComb(stack, buff);</pre>', 'JavaScript', '2011-04-30 22:38:50'),
(504, 'javascript中的作用域scope', '<p>javascript中的作用域scope</p>\r\n<p>在一般程序设计语言中，作用域是按块来划分的。即&ldquo;变量定义在哪个块之内，这个块就是变量的有效范围&rdquo;。而在javascript中，变量的作用域是按函数来划分的&mdash;&mdash;变量在某个函数范围内有效。比如：</p>\r\n<p>var f = false;</p>\r\n<p>if(true) { var f = true; } &nbsp; //此时f位于if内，也就是块内，等价于还是全局范围内</p>\r\n<p>alert(f) &nbsp;//所以，结果为true</p>\r\n<p>&nbsp;</p>\r\n<p>再如下例：</p>\r\n<p>var f = false;</p>\r\n<p>function test() {</p>\r\n<p>　　var f = true; &nbsp;//这是函数内定义的变量，只在函数内部有效，函数执行完毕后，该变量将被释放</p>\r\n<p>}</p>\r\n<p>test();</p>\r\n<p>alert(f) //结果为false，并没有因为test()的执行而改变</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>再有，在javascript中声明的全局变量都可以看作是window对象的一个属性，比如：</p>\r\n<p>var test = &quot;this is a test&quot;;</p>\r\n<p>alert(window.test == test) &nbsp;//结果为true</p>\r\n<p>这正好验证了上边所说的全局变量也是window对象的属性</p>\r\n<p>&nbsp;</p>\r\n<p>最后，我们来看</p>\r\n<p>function test() {</p>\r\n<p>　　f = false;</p>\r\n<p>}</p>\r\n<p>test();</p>\r\n<p>alert(f) //结果为false</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>', 'JavaScript', '2011-04-30 15:19:49');
INSERT INTO `list` (`id`, `title`, `content`, `cat`, `time`) VALUES
(505, '最佳的"addEvent"是怎样诞生的', '<h2>最佳的&quot;addEvent&quot;是怎样诞生的</h2>\r\n<p>&nbsp;IE的 JScript 存在内存泄露的bug 想必大家都清楚或者有耳闻了。这是由于IE的内存回收管理器的一个设计错误导致的。当我们编写脚本的时候创建了交叉引用，例如如下代码： window.onload = function () {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; var x = document.getElementsByTagName(&rsquo;H3&rsquo;);&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; for (var i=0;i&lt;x.length;i++)&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x[i].onclick = openClose;&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x[i].relatedElement = x[i].nextSibling; // simplified situation&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x[i].relatedElement.relatedElement = x[i];&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;<br />\r\n}或者在函数中使用脚本语言最常见的闭句Closures的时候，IE都无法回收内存。而闭句在给DOM对象注册事件处理器(event handler)的时候最为常用。Novemberborn提供了一些example可以让你运行并切实感受到这个bug。&nbsp;&nbsp;<br />\r\n我最喜爱的QuirkMode  去年初意识到这个bug存在巨大隐患，觉得有必要呼吁广大web开发者关注并竭力避免这个问题，于是举办了一个慈善邀请赛，鼓励大家提交各自  addEvent/removeEvent 方案。并终于在去年10月下旬宣布了他们认为的胜利者：John  Resig，让John赢得胜利的代码如下：&nbsp;&nbsp;&nbsp;<br />\r\n<br />\r\nfunction addEvent( obj, type, fn ) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp; if ( obj.attachEvent ) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; obj[&rsquo;e&rsquo;+type+fn] = fn;&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; obj[type+fn] = function(){obj[&rsquo;e&rsquo;+type+fn]( window.event );}&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; obj.attachEvent( &rsquo;on&rsquo;+type, obj[type+fn] );&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp; } else&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; obj.addEventListener( type, fn, false );&nbsp;&nbsp;<br />\r\n}&nbsp;&nbsp;<br />\r\nfunction removeEvent( obj, type, fn ) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp; if ( obj.detachEvent ) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; obj.detachEvent( &rsquo;on&rsquo;+type, obj[type+fn] );&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; obj[type+fn] = null;&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp; } else&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; obj.removeEventListener( type, fn, false );&nbsp;&nbsp;<br />\r\n}&nbsp;&nbsp;<br />\r\nQuirkMode 对选择John为胜利者的解释概括来说就是以上代码最简洁有效，在避免内存问题的同时还巧妙的保证了this关键字在ie的attachEvent中能正常工作。缺点当然还是存在：&nbsp;&nbsp;&nbsp;<br />\r\n<br />\r\n不支持 Netscape 4 和 Explorer 5 Mac。(有可能国内的程序员会嗤之以鼻，但国外很强调广泛的兼容性)&nbsp;&nbsp;&nbsp;<br />\r\n在 removeEvent 中遗漏了remove obj[&quot;e&quot;+type+fn]。&nbsp;&nbsp;&nbsp;<br />\r\n总之不管怎么说，简单取胜。&nbsp;&nbsp;<br />\r\n结果一出，众多参赛与评论者不服气，很快又挑出了John的代码的几处毛病：&nbsp;&nbsp;&nbsp;<br />\r\n<br />\r\naddEvent中本身就使用了闭句，所以没有根本解决IE内存泄露的问题。&nbsp;&nbsp;&nbsp;<br />\r\n没有解决同类型的事件可能被重复注册而被IE重复执行的问题。&nbsp;&nbsp;&nbsp;<br />\r\n几个高手于是提出了改进性的方案： /*&nbsp;&nbsp;<br />\r\nOriginal idea by John Resig&nbsp;&nbsp;<br />\r\nTweaked by Scott Andrew LePera, Dean Edwards and Peter-Paul Koch&nbsp;&nbsp;<br />\r\nFixed for IE by Tino Zijdel (crisp)&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; Note that in IE this will cause memory leaks and still doesn&rsquo;t  quite function the same as in browsers that do support the W3C event  model:&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; - event execution order is not the same (LIFO in IE against FIFO)&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; - functions attached to the same event on the same element multiple times will also get executed multiple times in IE&nbsp;&nbsp;<br />\r\n*/&nbsp;&nbsp;<br />\r\nfunction addEvent( obj, type, fn ) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; if (obj.addEventListener)&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj.addEventListener( type, fn, false );&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; else if (obj.attachEvent) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj[&quot;e&quot;+type+fn] = fn;&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj.attachEvent( &quot;on&quot;+type, function() { obj[&quot;e&quot;+type+fn](); } );&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;<br />\r\n}&nbsp;&nbsp;<br />\r\nfunction removeEvent( obj, type, fn ) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; if (obj.removeEventListener)&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj.removeEventListener( type, fn, false );&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; else if (obj.detachEvent) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj.detachEvent( &quot;on&quot;+type, obj[&quot;e&quot;+type+fn] );&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj[&quot;e&quot;+type+fn] = null;&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;<br />\r\n}&nbsp;&nbsp;<br />\r\n很明显，虽然修正了John代码的一些不足。但内存泄露依然存在，部分浏览器依然不支持，还是无法避免ie重复注册。另外根据注释:当在同一个对象上注册多个事件处理器的时候，IE与其他浏览器的执行顺序是不同的，这又是一个隐患。&nbsp;&nbsp;<br />\r\n<br />\r\n几天之后，一个被认为最严谨的方案由Dean Edwards 提出。Dean他的方案与众不同：&nbsp;&nbsp;&nbsp;<br />\r\n<br />\r\n不执行对象检测(Object detection)&nbsp;&nbsp;&nbsp;<br />\r\n没有调用 addeventListener/attachEvent 方法&nbsp;&nbsp;&nbsp;<br />\r\n保持this关键字的运行于正确的上下文环境&nbsp;&nbsp;&nbsp;<br />\r\n正确传递 event 对象参数&nbsp;&nbsp;&nbsp;<br />\r\n完全跨浏览器至此(包括IE4和NS4)&nbsp;&nbsp;&nbsp;<br />\r\n不存在内存泄露&nbsp;&nbsp;&nbsp;<br />\r\nDean的代码如下： // written by Dean Edwards, 2005&nbsp;&nbsp;<br />\r\n// <a target="_blank" href="http://dean.edwards.name/function%C2%A0">http://dean.edwards.name/function </a>  ; <br />\r\naddEvent(element, type, handler) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; // assign each event handler a unique ID&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; // 为事件处理函数设定一个唯一值&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; if (!handler.$$guid) handler.$$guid = addEvent.guid++;&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; // create a hash table of event types for the element&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; if (!element.events) element.events = {};&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; // create a hash table of event handlers for each element/event pair&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; var handlers = element.events[type];&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; if (!handlers) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handlers = element.events[type] = {};&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // store the existing event handler (if there is one)&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 如果对象已经注册有事件处理，那么要保留下来,并保存为第一个&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (element[&quot;on&quot; + type]) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handlers[0] = element[&quot;on&quot; + type];&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; // store the event handler in the hash table&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; handlers[handler.$$guid] = handler;&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; // assign a global event handler to do all the work&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; // 指派一个全局函数做统一的事件处理，同时避免了反复注册&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; element[&quot;on&quot; + type] = handleEvent;&nbsp;&nbsp;<br />\r\n};&nbsp;&nbsp;<br />\r\n// a counter used to create unique IDs&nbsp;&nbsp;<br />\r\naddEvent.guid = 1;function removeEvent(element, type, handler) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; // delete the event handler from the hash table&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; if (element.events &amp;&amp; element.events[type]) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete element.events[type][handler.$$guid];&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;<br />\r\n};function handleEvent(event) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; // grab the event object (IE uses a global event object)&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; event = event || window.event;&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; // get a reference to the hash table of event handlers&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; // 这里的 this 随 handlerEvent function 被触发的source element 变化而变化&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; var handlers = this.events[event.type];&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; // execute each event handler&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; for (var i in handlers) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //这样写才能保证注册的事件处理函数中的 this 得到正确的引用，直接handlers[i]()是不行的&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.$$handleEvent = handlers[i];&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.$$handleEvent(event);&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;<br />\r\n};&nbsp;&nbsp;<br />\r\n这段代码相比之前就大了不少了，不过确实很精妙。可是这段代码却引入了其他的问题，比如无法处理事件处理函数的返回值，for..in循环可能因为  (Object.prototype)的错误应用而中断等等...很快Dean推出一个&quot;updated version&quot;。&nbsp;&nbsp;<br />\r\n<br />\r\n要做到最好真的好辛苦。&nbsp;&nbsp;<br />\r\n<br />\r\n目前似乎Dean的最终版本是最全面的解决方案。不过就我个人意见，感觉有些吹毛求疵了。尽量使用浏览器本身的实现和保持简单是我一贯坚持的主张。但洋人这种严谨的态度，还是让我深深敬佩。</p>', 'JavaScript', '2011-04-30 15:25:08'),
(506, 'javascript跨浏览器事件框架myEvent.js', '<p>IE与现代浏览器在DOM中最大的差异是什么无疑就是event了。各个浏览器接口的差异以及够头疼了，而IE甚至Firefox早期版本由于内存管理机制不完善，很容易在事件处理中导致内存泄漏。</p>\r\n<p>event究竟有多么复杂？可见前辈的6年前的努力：<a href="http://blog.csdn.net/alex197963/archive/2009/08/18/4458737.aspx">最佳的addEvent是怎样诞生的</a>，后起之秀jQuery也付出了一千六百多行血汗代码（v 1.5.1）搞定了6年后出现的各种核的浏览器。</p>\r\n<p>我参考前辈的代码以及自己的理解尝试写了一个事件框架，我的框架完成了一个事件机制的核心，它能提供统一接口实现多事件绑定以及避免内存泄漏等其他一些问题，更重要的是性能还不错。</p>\r\n<p><strong>我的手法：</strong></p>\r\n<ol>\r\n    <li>所有回调函数根据元素、事件类型、回调函数唯一ID缓存在一个_create对象中（其内部具体结构可见下面源码的关于_cache的注释）。</li>\r\n    <li>事件绑定使用一个_create代理函数处理，并且一个元素的各类型事件全部通过此进行分发，同时运用apply方法让IE的指针指向元素。</li>\r\n    <li>通过数组队列解决IE回调函数执行顺序的问题。</li>\r\n    <li>fix函数将处理回调函数传入的event参数以及其他兼容问题。此处参考了jQuery.event.fix。</li>\r\n    <li>断开事件与元素的循环引用避免内存泄漏。</li>\r\n</ol>\r\n<p><strong>一、核心实现：</strong></p>\r\n<pre class="brush:javascript">\r\n \r\n// myEvent 0.2\r\n// 2011.04.06 - TangBin - planeart.cn - MIT Licensed\r\n/**\r\n * 事件框架\r\n * @namespace\r\n * @see http://www.planeart.cn/?p=1285\r\n */\r\nvar myEvent = (function () {\r\nvar _fid = 1,\r\n	_guid = 1,\r\n	_time = (new Date).getTime(),\r\n	_nEid = ''{$eid}'' + _time,\r\n	_nFid = ''{$fid}'' + _time,\r\n	_DOM = document.addEventListener,\r\n	_noop = function () {},\r\n	_create = function (guid) {\r\n		return function (event) {\r\n			event = api.fix(event || window.event);\r\n			var i = 0,\r\n				type = (event || (event = document.event)).type,\r\n				elem = _cache[guid].elem,\r\n				data = arguments,\r\n				events = _cache[guid].events[type];\r\n \r\n			for (; i &lt; events.length; i ++) {\r\n				if (events[i].apply(elem, data) === false) event.preventDefault();\r\n			};\r\n		};\r\n	},\r\n	_cache = {/*\r\n		1: {\r\n			elem: (HTMLElement),\r\n			events: {\r\n				click: [(Function), (..)],\r\n				(..)\r\n			},\r\n			listener: (Function)\r\n		},\r\n		(..)\r\n	*/};\r\n \r\nvar api = {\r\n \r\n	/**\r\n	 * 事件绑定\r\n	 * @param	{HTMLElement}	元素\r\n	 * @param	{String}		事件名\r\n	 * @param	{Function}		要绑定的函数\r\n	 */\r\n	bind: function (elem, type, callback) {\r\n		var guid = elem[_nEid] || (elem[_nEid] = _guid ++);\r\n \r\n		if (!_cache[guid]) _cache[guid] = {\r\n			elem: elem,\r\n			listener: _create(guid),\r\n			events: {}\r\n		};\r\n \r\n		if (type &amp;&amp; !_cache[guid].events[type]) {\r\n			_cache[guid].events[type] = [];\r\n			api.add(elem, type, _cache[guid].listener);\r\n		};\r\n \r\n		if (callback) {\r\n			if (!callback[_nFid]) callback[_nFid] = _fid ++;\r\n			_cache[guid].events[type].push(callback);\r\n		} else\r\n			return _cache[guid];\r\n	},\r\n \r\n	/**\r\n	 * 事件卸载\r\n	 * @param	{HTMLElement}	元素\r\n	 * @param	{String}		事件名\r\n	 * @param	{Function}		要卸载的函数\r\n	 */\r\n	unbind: function (elem, type, callback) {\r\n		var events, i, list,\r\n			guid = elem[_nEid],\r\n			handler = _cache[guid];\r\n \r\n		if (!handler) return;\r\n		events = handler.events;\r\n \r\n		if (callback) {\r\n \r\n			list = events[type];\r\n			if (!list) return;\r\n			for (i = 0; i &lt; list.length; i ++) {\r\n				list[i][_nFid] === callback[_nFid] &amp;&amp; list.splice(i--, 1);\r\n			};\r\n			if (list.length === 0) return api.unbind(elem, type);\r\n \r\n		} else if (type) {\r\n \r\n			delete events[type];\r\n			api.remove(elem, type, handler.listener);\r\n \r\n		} else {\r\n \r\n			for (i in events) {\r\n				api.remove(elem, i, handler.listener);\r\n			};\r\n			delete _cache[guid];\r\n \r\n		};\r\n	},\r\n \r\n	/**\r\n	 * 事件触发 (注意：不会触发浏览器默认行为与冒泡)\r\n	 * @param	{HTMLElement}	元素\r\n	 * @param	{String}		事件名\r\n	 * @param	{Array}			(可选)附加数据\r\n	 */\r\n	triggerHandler: function (elem, type, data) {\r\n		var guid = elem[_nEid],\r\n			event = {\r\n				type: type,\r\n				target: elem,\r\n				currentTarget: elem,\r\n				preventDefault: _noop,\r\n				stopPropagation: _noop\r\n			};\r\n \r\n		data = data || [];\r\n		data.unshift(event);\r\n \r\n		guid &amp;&amp; _cache[guid].listener.apply(elem, data);\r\n \r\n		try {\r\n			elem[''on'' + type] &amp;&amp; elem[''on'' + type].apply(elem, data);\r\n			//elem[type] &amp;&amp; elem[type]();\r\n		} catch (e) {};\r\n	},\r\n \r\n	// 原生事件绑定接口\r\n	add: _DOM ? function (elem, type, listener) {\r\n		elem.addEventListener(type, listener, false);\r\n	} : function (elem, type, listener) {\r\n		elem.attachEvent(''on'' + type, listener);\r\n	},\r\n \r\n	// 原生事件卸载接口\r\n	remove: _DOM ? function (elem, type, listener) {\r\n		elem.removeEventListener(type, listener, false);\r\n	} : function (elem, type, listener) {\r\n		elem.detachEvent(''on'' + type, listener);\r\n	},\r\n \r\n	// 修正\r\n	fix: function (event) {\r\n		if (_DOM) return event;\r\n		var name,\r\n			newEvent = {},\r\n			doc = document.documentElement,\r\n			body = document.body;\r\n \r\n		newEvent.target = event.srcElement || document;\r\n		newEvent.target.nodeType === 3 &amp;&amp; (newEvent.target = newEvent.target.parentNode);\r\n		newEvent.preventDefault = function () {event.returnValue = false};\r\n		newEvent.stopPropagation = function () {event.cancelBubble = true};\r\n		newEvent.pageX = newEvent.clientX + (doc &amp;&amp; doc.scrollLeft || body &amp;&amp; body.scrollLeft || 0) - (doc &amp;&amp; doc.clientLeft || body &amp;&amp; body.clientLeft || 0);\r\n		newEvent.pageY = newEvent.clientY + (doc &amp;&amp; doc.scrollTop  || body &amp;&amp; body.scrollTop  || 0) - (doc &amp;&amp; doc.clientTop  || body &amp;&amp; body.clientTop  || 0);\r\n		newEvent.relatedTarget = event.fromElement === newEvent.target ? event.toElement : event.fromElement;\r\n \r\n		// !!IE写event会极其容易导致内存泄漏，Firefox写event会报错\r\n		// 拷贝event\r\n		for (name in event) newEvent[name] = event[name];\r\n \r\n		return newEvent;\r\n	}\r\n \r\n};\r\n \r\nreturn api;\r\n})();\r\n</pre>\r\n<p>我给一万个元素绑定事件进行了测试，测试工具为sIEve，结果：</p>\r\n<blockquote>\r\n<table width="340" border="1" cellpadding="7" cellspacing="2">\r\n    <tbody>\r\n        <tr>\r\n            <td width="100">事件框架</td>\r\n            <td width="73">耗时</td>\r\n            <td width="117">内存</td>\r\n        </tr>\r\n        <tr>\r\n            <td colspan="3" align="center" bgcolor="#F7F7F7">IE8</td>\r\n        </tr>\r\n        <tr>\r\n            <td>jQuery.bind</td>\r\n            <td>1064 MS</td>\r\n            <td>79.80 MB</td>\r\n        </tr>\r\n        <tr>\r\n            <td>myEvent.bind</td>\r\n            <td>623 MS</td>\r\n            <td>35.82 MB</td>\r\n        </tr>\r\n        <tr>\r\n            <td colspan="3" align="center" bgcolor="#F7F7F7">IE6</td>\r\n        </tr>\r\n        <tr>\r\n            <td>jQuery.bind</td>\r\n            <td>2503 MS</td>\r\n            <td>74.23 MB</td>\r\n        </tr>\r\n        <tr>\r\n            <td height="35">myEvent.bind</td>\r\n            <td>1810 MS</td>\r\n            <td>28.48 MB</td>\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n</blockquote>\r\n<p>可以看到无论是执行效率还是内存占用myEvent都比有一定优势，这是可能是由于jQuery事件机制过于强大导致其性能的损耗。<br />\r\n测试样本：<a href="http://www.planeart.cn/demo/myEvent/">http://www.planeart.cn/demo/myEvent/</a></p>\r\n<p><strong>二、扩展自定义事件机制</strong><br />\r\njQuery是可以自定义事件的，它用一个special命名空间存储自定义事件，我在上面代码的基础上模仿jQuery自定义事件机制，并把其著名的ready事件与另外一个jQuery hashchange事件插件移植过来。</p>\r\n<p>这两个自定义事件非常重要，ready事件可以在DOM就绪给元素绑定事件，比传统使用window.onload要快很多；hashchange事件可以监听锚点改变，常用于解决AJAX历史记录问题，如Twitter新版本就就采用此处理AJAX，使用锚点机制除了可以提高AJAX应用程序的用户体验外，如果按照一定规则还能被google索引到。</p>\r\n<p>当然，我前面文章实现的imgReady事件也可以通过此扩展进来，稍后更新。</p>\r\n<pre class="brush:javascript">\r\n \r\n// myEvent 0.2.2\r\n// 2011.04.07 - TangBin - planeart.cn - MIT Licensed\r\n/**\r\n * 事件框架\r\n * @namespace\r\n * @see http://www.planeart.cn/?p=1285\r\n */\r\nvar myEvent = (function () {\r\n \r\nvar _ret, _name,\r\n	_fid = 1,\r\n	_guid = 1,\r\n	_time = (new Date).getTime(),\r\n	_nEid = ''{$eid}'' + _time,\r\n	_nFid = ''{$fid}'' + _time,\r\n	_DOM = document.addEventListener,\r\n	_noop = function () {},\r\n	_create = function (guid) {\r\n		return function (event) {\r\n			event = myEvent.fix(event || window.event);\r\n			var type = (event || (event = document.event)).type,\r\n				elem = _cache[guid].elem,\r\n				data = arguments,\r\n				events = _cache[guid].events[type],\r\n				i = 0,\r\n				length = events.length;\r\n \r\n			for (; i &lt; length; i ++) {\r\n				if (events[i].apply(elem, data) === false) event.preventDefault();\r\n			};\r\n \r\n			event = elem = null;\r\n		};\r\n	},\r\n	_cache = {/*\r\n		1: {\r\n			elem: (HTMLElement),\r\n			events: {\r\n				click: [(Function), (..)],\r\n				(..)\r\n			},\r\n			listener: (Function)\r\n		},\r\n		(..)\r\n	*/};\r\n \r\nvar API = function () {};\r\nAPI.prototype = {\r\n \r\n	/**\r\n	 * 事件绑定\r\n	 * @param	{HTMLElement}	元素\r\n	 * @param	{String}		事件名\r\n	 * @param	{Function}		要绑定的函数\r\n	 */\r\n	bind: function (elem, type, callback) {\r\n		var events, listener,\r\n			guid = elem[_nEid] || (elem[_nEid] = _guid ++),\r\n			special = this.special[type] || {},\r\n			cacheData = _cache[guid];\r\n \r\n		if (!cacheData) cacheData = _cache[guid] = {\r\n			elem: elem,\r\n			listener: _create(guid),\r\n			events: {}\r\n		};\r\n \r\n		events = cacheData.events;\r\n		listener = cacheData.listener;\r\n		if (!events[type]) events[type] = [];\r\n		if (!callback[_nFid]) callback[_nFid] = _fid ++;\r\n		if (!special.setup || special.setup.call(elem, listener) === false) {\r\n			events[type].length === 0 &amp;&amp; this.add(elem, type, listener);\r\n		};\r\n		events[type].push(callback);\r\n	},\r\n \r\n	/**\r\n	 * 事件卸载\r\n	 * @param	{HTMLElement}	元素\r\n	 * @param	{String}		事件名\r\n	 * @param	{Function}		要卸载的函数\r\n	 */\r\n	unbind: function (elem, type, callback) {\r\n		var events, special, i, list, fid,\r\n			guid = elem[_nEid],\r\n			cacheData = _cache[guid];\r\n \r\n		if (!cacheData) return;\r\n		events = cacheData.events;\r\n \r\n		if (callback) {\r\n \r\n			list = events[type];\r\n			fid = callback[_nFid];\r\n			if (!list) return;\r\n \r\n			for (i = 0; i &lt; list.length; i ++) {\r\n				list[i][_nFid] === fid &amp;&amp; list.splice(i--, 1);\r\n			};\r\n			if (!list.length) this.unbind(elem, type);\r\n \r\n		} else if (type) {\r\n \r\n			special = this.special[type] || {};\r\n			if (!special.teardown || special.teardown.call(elem) === false) {\r\n				this.remove(elem, type, cacheData.listener);\r\n			};\r\n			delete events[type];\r\n \r\n		} else {\r\n \r\n			for (i in events) {\r\n				this.remove(elem, i, cacheData.listener);\r\n			};\r\n			delete _cache[guid];\r\n \r\n		};\r\n \r\n	},\r\n \r\n	/**\r\n	 * 事件触发 (注意：不会触发浏览器默认行为与冒泡)\r\n	 * @param	{HTMLElement}	元素\r\n	 * @param	{String}		事件名\r\n	 * @param	{Array}			(可选)附加数据\r\n	 */\r\n	triggerHandler: function (elem, type, data) {\r\n		var guid = elem[_nEid],\r\n			cacheData = _cache[guid],\r\n			event = {\r\n				type: type,\r\n				target: elem,\r\n				currentTarget: elem,\r\n				preventDefault: _noop,\r\n				stopPropagation: _noop\r\n			};\r\n \r\n		data = data || [];\r\n		data.unshift(event);\r\n \r\n		cacheData &amp;&amp; cacheData.events[type] &amp;&amp; _cache[guid].listener.apply(elem, data);\r\n \r\n		try {\r\n			elem[''on'' + type] &amp;&amp; elem[''on'' + type].apply(elem, data);\r\n			//elem[type] &amp;&amp; elem[type]();\r\n		} catch (e) {};\r\n	},\r\n \r\n	// 自定义事件接口\r\n	special: {},\r\n \r\n	// 原生事件绑定接口\r\n	add: _DOM ? function (elem, type, listener) {\r\n		elem.addEventListener(type, listener, false);\r\n	} : function (elem, type, listener) {\r\n		elem.attachEvent(''on'' + type, listener);\r\n	},\r\n \r\n	// 原生事件卸载接口\r\n	remove: _DOM ? function (elem, type, listener) {\r\n		elem.removeEventListener(type, listener, false);\r\n	} : function (elem, type, listener) {\r\n		elem.detachEvent(''on'' + type, listener);\r\n	},\r\n \r\n	// 修正\r\n	fix: function (event) {\r\n		if (_DOM) return event;\r\n \r\n		var name,\r\n			newEvent = {},\r\n			doc = document.documentElement,\r\n			body = document.body;\r\n \r\n		newEvent.target = event.srcElement || document;\r\n		newEvent.target.nodeType === 3 &amp;&amp; (newEvent.target = newEvent.target.parentNode);\r\n		newEvent.preventDefault = function () {event.returnValue = false};\r\n		newEvent.stopPropagation = function () {event.cancelBubble = true};\r\n		newEvent.pageX = newEvent.clientX + (doc &amp;&amp; doc.scrollLeft || body &amp;&amp; body.scrollLeft || 0) - (doc &amp;&amp; doc.clientLeft || body &amp;&amp; body.clientLeft || 0);\r\n		newEvent.pageY = newEvent.clientY + (doc &amp;&amp; doc.scrollTop  || body &amp;&amp; body.scrollTop  || 0) - (doc &amp;&amp; doc.clientTop  || body &amp;&amp; body.clientTop  || 0);\r\n		newEvent.relatedTarget = event.fromElement === newEvent.target ? event.toElement : event.fromElement;\r\n \r\n		// !!直接写event IE导致内存泄漏，Firefox会报错\r\n		// 伪装event\r\n		for (name in event) newEvent[name] = event[name];\r\n		return newEvent;\r\n	}\r\n \r\n};\r\n \r\nreturn new API();\r\n})();\r\n \r\n// DOM就绪事件\r\nmyEvent.ready = (function () {\r\n	var readyList = [], DOMContentLoaded,\r\n		readyBound = false, isReady = false;\r\n \r\n	function ready () {\r\n		if (!isReady) {\r\n			if (!document.body) return setTimeout(ready, 13);\r\n			isReady = true;\r\n \r\n			if (readyList) {\r\n				var fn, i = 0;\r\n				while ((fn = readyList[i++])) {\r\n					fn.call(document, {});\r\n				};\r\n				readyList = null;\r\n			};\r\n		};\r\n	};\r\n \r\n	function bindReady () {\r\n		if (readyBound) return;\r\n \r\n		readyBound = true;\r\n \r\n		if (document.readyState === ''complete'') {\r\n			return ready();\r\n		};\r\n \r\n		if (document.addEventListener) {\r\n			document.addEventListener(''DOMContentLoaded'', DOMContentLoaded, false);\r\n			window.addEventListener(''load'', ready, false);\r\n		} else if (document.attachEvent) {\r\n			document.attachEvent(''onreadystatechange'', DOMContentLoaded);\r\n			window.attachEvent(''onload'', ready);\r\n			var toplevel = false;\r\n			try {\r\n				toplevel = window.frameElement == null;\r\n			} catch (e) {};\r\n \r\n			if (document.documentElement.doScroll &amp;&amp; toplevel) {\r\n				doScrollCheck();\r\n			};\r\n		};\r\n	};\r\n \r\n	myEvent.special.ready = {\r\n		setup: bindReady,\r\n		teardown: function () {}\r\n	};\r\n \r\n	if (document.addEventListener) {\r\n		DOMContentLoaded = function () {\r\n			document.removeEventListener(''DOMContentLoaded'', DOMContentLoaded, false);\r\n			ready();\r\n		};\r\n	} else if (document.attachEvent) {\r\n		DOMContentLoaded = function () {\r\n			if (document.readyState === ''complete'') {\r\n				document.detachEvent(''onreadystatechange'', DOMContentLoaded);\r\n				ready();\r\n			};\r\n		};\r\n	};\r\n \r\n	function doScrollCheck () {\r\n		if (isReady) return;\r\n \r\n		try {\r\n			document.documentElement.doScroll(''left'');\r\n		} catch (e) {\r\n			setTimeout(doScrollCheck, 1);\r\n			return;\r\n		};\r\n		ready();\r\n	};\r\n \r\n	return function (callback) {\r\n		bindReady();\r\n \r\n		if (isReady) {\r\n			callback.call(document, {});\r\n		} else if (readyList) {\r\n			readyList.push(callback);\r\n		};\r\n \r\n		return this;\r\n	};\r\n})();\r\n \r\n// Hashchange Event v1.3\r\n(function (window, undefined) {\r\n    var config = {\r\n			delay: 50,\r\n			src: null,\r\n			domain: null\r\n		},\r\n		str_hashchange = ''hashchange'',\r\n        doc = document,\r\n		isIE = !-[1,],\r\n        fake_onhashchange, special = myEvent.special,\r\n        doc_mode = doc.documentMode,\r\n        supports_onhashchange = ''on'' + str_hashchange in window &amp;&amp; (doc_mode === undefined || doc_mode &gt; 7);\r\n \r\n    function get_fragment(url) {\r\n        url = url || location.href;\r\n        return ''#'' + url.replace(/^[^#]*#?(.*)$/, ''$1'');\r\n    };\r\n \r\n    special[str_hashchange] = {\r\n        setup: function () {\r\n            if (supports_onhashchange) return false;\r\n \r\n            myEvent.ready(fake_onhashchange.start);\r\n        },\r\n        teardown: function () {\r\n            if (supports_onhashchange) return false;\r\n            myEvent.ready(fake_onhashchange.stop);\r\n        }\r\n    };\r\n \r\n	/** @inner */\r\n    fake_onhashchange = (function () {\r\n        var self = {},\r\n            timeout_id, last_hash = get_fragment(),\r\n			/** @inner */\r\n            fn_retval = function (val) {\r\n                return val;\r\n            },\r\n            history_set = fn_retval,\r\n            history_get = fn_retval;\r\n \r\n        self.start = function () {\r\n            timeout_id || poll();\r\n        };\r\n \r\n        self.stop = function () {\r\n            timeout_id &amp;&amp; clearTimeout(timeout_id);\r\n            timeout_id = undefined;\r\n        };\r\n \r\n        function poll() {\r\n            var hash = get_fragment(),\r\n                history_hash = history_get(last_hash);\r\n            if (hash !== last_hash) {\r\n                history_set(last_hash = hash, history_hash);\r\n                myEvent.triggerHandler(window, str_hashchange);\r\n            } else if (history_hash !== last_hash) {\r\n                location.href = location.href.replace(/#.*/, '''') + history_hash;\r\n            };\r\n            timeout_id = setTimeout(poll, config.delay);\r\n        };\r\n \r\n        isIE &amp;&amp; !supports_onhashchange &amp;&amp; (function () {\r\n            var iframe,iframe_src, iframe_window;\r\n \r\n            self.start = function () {\r\n                if (!iframe) {\r\n                    iframe_src = config.src;\r\n                    iframe_src = iframe_src &amp;&amp; iframe_src + get_fragment();\r\n \r\n					iframe = doc.createElement(''<iframe tabindex="-1" style="display:none" title="empty" src="'' + (iframe_src || ''javascript:0'') + ''"></iframe>'');\r\n					myEvent.bind(iframe, ''load'', function () {\r\n						myEvent.unbind(iframe, ''load'');\r\n						iframe_src || history_set(get_fragment());\r\n                        poll();\r\n                    });\r\n					doc.getElementsByTagName(''html'')[0].appendChild(iframe);\r\n					iframe_window = iframe.contentWindow;\r\n                    doc.onpropertychange = function () {\r\n                        try {\r\n                            if (event.propertyName === ''title'') {\r\n                                iframe_window.document.title = doc.title;\r\n                            };\r\n                        } catch (e) {};\r\n                    };\r\n                };\r\n            };\r\n \r\n            self.stop = fn_retval;\r\n \r\n			/** @inner */\r\n            history_get = function () {\r\n                return get_fragment(iframe_window.location.href);\r\n            };\r\n \r\n			/** @inner */\r\n            history_set = function (hash, history_hash) {\r\n                var iframe_doc = iframe_window.document,\r\n                    domain = config.domain;\r\n                if (hash !== history_hash) {\r\n					iframe_doc.title = doc.title;\r\n                    iframe_doc.open();\r\n                    domain &amp;&amp; iframe_doc.write(''<script>document.domain="'' + domain + ''"</script>'');\r\n					iframe_doc.close();\r\n                    iframe_window.location.hash = hash;\r\n                };\r\n            };\r\n        })();\r\n \r\n        return self;\r\n    })();\r\n})(this);\r\n</pre>\r\n<p>ready事件是伪事件，调用方式：</p>\r\n<pre class="brush:javascript">\r\n \r\nmyEvent.ready(function () {\r\n    //[code..]\r\n});\r\n</pre>\r\n<p>hashchange事件可以采用标准方式绑定：</p>\r\n<pre class="brush:javascript">\r\n \r\nmyEvent.bind(window, ''hashchange'', function () {\r\n    //[code..]\r\n});\r\n</pre>\r\n<p>这里有一些文章值得阅读：<br />\r\n<a href="http://www.cnblogs.com/rubylouvre/archive/2010/03/26/1696182.html">javascript 跨浏览器的事件系统</a>(司徒正美。他博客有一系列的讲解)<br />\r\n<a href="http://typeof.net/2010/08/compatibility-with-elegance/">更优雅的兼容</a>（BELLEVE INVIS）</p>', 'JavaScript', '2011-04-30 15:24:33'),
(507, '数组去重――一道前端校招试题', '<p><a href="https://lijing00333.wordpress.com/2011/02/08/%e6%95%b0%e7%bb%84%e5%8e%bb%e9%87%8d%e2%80%94%e2%80%94%e4%b8%80%e9%81%93%e5%89%8d%e7%ab%af%e6%a0%a1%e6%8b%9b%e8%af%95%e9%a2%98/">https://lijing00333.wordpress.com/2011/02/08/%e6%95%b0%e7%bb%84%e5%8e%bb%e9%87%8d%e2%80%94%e2%80%94%e4%b8%80%e9%81%93%e5%89%8d%e7%ab%af%e6%a0%a1%e6%8b%9b%e8%af%95%e9%a2%98/ </a></p>\r\n<h2 class="entry-title">数组去重&mdash;&mdash;一道前端校招试题</h2>\r\n<p>很多校招题是没有严格的标准答案的，只有知识点，只要几个关键点能答上来，不管程序是否真的能跑通，都可以拿分的。比如最常见的一道题：</p>\r\n<p>试题：<br />\r\n有这样一个数组，成员都是数字，例如<br />\r\nvar a = [1,2,3,4,5,2,3,4,6,7,8];<br />\r\n请实现a.distinct()方法，用来给数组a去掉重复值，要求对Array的原型进行扩展方法，并尽可能做到效率最优。</p>\r\n<p>考察点：<br />\r\n1，考察应试者是否理解原型链<br />\r\n2，考察应试者是否由意识的控制算法的时间复杂度，了解应试者对专业课知识的掌握程度<br />\r\n3，考察应试者对js数组函数的了解程度</p>\r\n<p>答案1：</p>\r\n<p>Array.prototype.distinct = function(){<br />\r\nvar a = [],b=[],oa = this.concat();<br />\r\nfor(var i = 1;i&lt;oa.length;i++){<br />\r\nfor(var j = 0;j&lt;i;j++){<br />\r\nif(b.indexOf(j)&gt;-1)continue;<br />\r\nif(oa[j] == oa[i]){<br />\r\nb.push(j);<br />\r\n}<br />\r\n}<br />\r\n}<br />\r\nthis.splice(0,this.length);<br />\r\nfor(var i = 0;i&lt;oa.length;i++){<br />\r\nif(b.indexOf(i)&gt;-1)continue;<br />\r\nthis.push(oa[i ]);<br />\r\n}<br />\r\nreturn this;<br />\r\n};</p>\r\n<p>&nbsp;</p>\r\n<p>答案2：</p>\r\n<p>Array.prototype.distinct = function(){<br />\r\nfor(var i = 0;i&lt;this.length;i++){<br />\r\nvar n = this[i ];<br />\r\nthis.splice(i,1,null);<br />\r\nif(this.indexOf(n) &lt; 0){<br />\r\nthis.splice(i,1,n);//不存在重复<br />\r\n}else{<br />\r\nthis.splice(i,1);//存在重复<br />\r\n}<br />\r\n}<br />\r\nreturn this;<br />\r\n};</p>\r\n<p>答案3：</p>\r\n<p>Array.prototype.distinct = function(){<br />\r\nvar self = this;<br />\r\nvar _a = this.concat().sort();<br />\r\n_a.sort(function(a,b){<br />\r\nif(a == b){<br />\r\nvar n = self.indexOf(a);<br />\r\nself.splice(n,1);<br />\r\n}<br />\r\n});<br />\r\nreturn self;<br />\r\n};</p>\r\n<p>得分点：<br />\r\n1，应试者起码应该自觉通过Array.prototype.distince来实现函数，若没有这样做，则扣分50%<br />\r\n2，应试者起码会给出答案1，得分30%，如果没有使用splice和concate，扣分20%<br />\r\n3，给出答案2的，得分80%，算法复杂度控制在O(n)<br />\r\n4，给出答案3的，得满分，算法复杂度控制在O(1)</p>\r\n<p>&nbsp;</p>', 'JavaScript', '2011-04-30 15:23:31'),
(508, 'concat()――链接或拷贝数组', '<p>concat() 方法用于连接两个或多个数组。  该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。</p>', 'JavaScript', '2011-04-30 15:22:51'),
(509, '能说明你的Javascript技术很烂的五个原因', '<p>　　<a href="http://news.cnblogs.com/n/97229/">http://news.cnblogs.com/n/97229/</a></p>\r\n<p id="page-note">　　本文是从 <a href="http://patrickavella.com/blog/5-reasons-your-javascript-stinks">5 Reasons Your Javascript Stinks</a> 这篇文章翻译而来。</p>\r\n<p>　　Javascript在互联网上名声很臭，但你又很难再找到一个像它这样如此动态、如此被广泛使用、如此根植于我们的生活中的另外一种语言。它的低学习门槛让很多人都称它为学前脚本语言，它另外一个让人嘲笑的东西是动态语言的概念是偏偏使用了高标准的静态数据类型。其实，你和Javascript都站错了立场，而现在，你让Javascript很生气。这里有五个原因能说明你的Javascript技术很烂。</p>\r\n<p><strong>1. 你没有使用命名空间。</strong></p>\r\n<p>　　是否还记得在大学里老师告诉你不要在家庭作业里使用全局变量？Javascript里的全局变量的使用方法也不例外。Web网页稍不留神就会变的混乱不堪、到处都是从互联网上各个角落里找来的乱糟糟的相互侵犯的脚本和脚本库。如果你把一个变量命名成loader()，那你是成心自找麻烦。如果你在无意识的情况下重载了一个函数，Javascript根本不会提醒你。你还把它叫做一种学前教育编程语言，还记得吧？我要说的是，你需要知道在做了这些后发生什么情况。</p>\r\n<blockquote>\r\n<p>function derp(){ alert(&ldquo;one&rdquo;); }<br />\r\nfunction derp(){ alert(&ldquo;two&rdquo;); }<br />\r\nderp();</p>\r\n</blockquote>\r\n<p>　　&ldquo;two&rdquo;，答案是&ldquo;two&rdquo;。并不是一定会这样，它也可能是&ldquo;one&rdquo;。所以，把你所有的代码都放在自己的命名空间里，这很容易。下面是定义自己的命名空间的一个简单做法。</p>\r\n<blockquote>\r\n<p>var foospace={};<br />\r\nfoospace.derp=function(){ alert(&ldquo;one&rdquo;); }<br />\r\nfunction derp(){ alert(&ldquo;two&rdquo;); }<br />\r\nfoospace.derp();</p>\r\n</blockquote>\r\n<p><strong>2. 你在变戏法，你把变量定义的东一个西一个。</strong></p>\r\n<p>　　你使用莫名其妙的数字字母组合作为变量名是一个双输的结局。在40行的代码块中寻找一个不带任何表意的字符变量，对于维护工作来说简直是场噩梦。把对变量的第一次声明混合到一个40行的代码块里同样也是一场噩梦。即使你自己遇到这样的变量时，你也要不由的问自己：&ldquo;这是在哪里定义的？&rdquo;，然后迅速的使用Ctrl+F组合在源代码里寻找这个变量最初定义的位置。不，不要这样，相反，这是对Javascript的滥用，是一种愚蠢的做法。你应该始终把变量定义在它的使用范围的顶部。并不能说因为这不是必须的，你就可以不这样做。</p>\r\n<blockquote>\r\n<p>function(){<br />\r\nvar a,//description<br />\r\nb; //description<br />\r\n//process&hellip;<br />\r\n}</p>\r\n</blockquote>\r\n<p><strong>3. 你没有理解Javascript的变量范围。</strong></p>\r\n<p>　　你是个天才的程序员，你吃的是C++、拉的是List。你知道什么是变量范围，你对你的变量有完全的控制，你就像太上皇似的的注视着它们。然而，Javascript却在你的咖啡里拉了一泡屎，并且大笑不止。</p>\r\n<blockquote>\r\n<p>var herp=&rdquo;one&rdquo;;<br />\r\n{<br />\r\nvar herp=&rdquo;two&rdquo;;<br />\r\n}<br />\r\nalert(herp);</p>\r\n</blockquote>\r\n<p>　　在这种情况下你得到的<tt>herp</tt>不是&ldquo;one&rdquo;，而是&ldquo;two&rdquo;。Javascript的变量有效范围并不是跟其它语言一样依赖于代码块。Javascript的变量范围是以<strong>函数</strong>为基础的。每个函数都有它自己的变量范围，Javascript这一点上表现的很酷，根本不理睬这毫无意义的花括弧包起来的范围。事实上，Javascript是如此的酷，以至于你甚至可以将变量范围像命名空间或变量那样进行传递。</p>\r\n<p><strong>4. 你以为Javascript的面向对象特征只是嫁接而来的。</strong></p>\r\n<p>　　Javascript，自从呱呱落地起，它就是一个面向对象的语言。所有的东西在Javascript里都是对象，所有的！甚至数字和字符这样的文字符号都可以通过它自身固有的构造器转化成对象。跟其它面向对象的语言比起来，Javascript的不同之处在于，它没有类(class)。Javascript对象像函数那样定义，甚至函数自己也是对象。Javascript有个属性叫做<strong>prototype</strong>，所有对象里都内置了这个属性，你可以通过它来改变对象的构造，修改对象、添加更多的变量、更多的功能。</p>\r\n<blockquote>\r\n<p>var derp; //will hold a Herp instance<br />\r\nvar Herp= function(){<br />\r\nthis.opinion=&rdquo;Javascript is cooler than BASIC.&rdquo;;<br />\r\n}<br />\r\nHerp.prototype.speak=function(){ alert(this.opinion); }<br />\r\nvar derp= new Herp();<br />\r\nderp.speak();</p>\r\n</blockquote>\r\n<p>　　如果这个看起来跟你毫不相干，我愿意介绍我的好朋友Google给你，Google擅长于帮助人们学习知识。面向对象对于我这篇简短的、低姿态的文章来说实在是个太大的话题。</p>\r\n<p><strong>5. 你使用&ldquo;new&rdquo;关键字时就像是盲人瞎马。</strong></p>\r\n<p>　　Javascript肯定是你的初恋女友，因为你显得无所适从。如果你想像真人那样取悦Javascript，你需要去了解对象符号。除了在需要实例化一个对象，或罕见的需要延时加载数据的情况外，你基本上不需要使用<strong>new</strong>关键字。在Javascript里分配大量的<strong>new</strong>变量地址是一项很慢的操作，为了效率起见，你应该始终使用对象符号。</p>\r\n<blockquote>\r\n<p>var rightway= [1, 2, 3];<br />\r\nvar wrongway= new Array(1, 2, 3);</p>\r\n</blockquote>\r\n<p>　　是否还记得我说过Javascript的变量范围是以函数为基础的？是否还记得有人说Javascript的对象像函数那样定义？如果你不使用<strong>new</strong>关键字来声明一个对象，你将会使这个对象成为全局范围内的对象。所以，永远使用<strong>new</strong>关键字来声明对象是一个好习惯。</p>\r\n<blockquote>\r\n<p>var derp=&rdquo;one&rdquo;;<br />\r\nvar Herp=function(){<br />\r\nthis.derp=&rdquo;two&rdquo;;<br />\r\n}<br />\r\nvar foo=Herp();<br />\r\nalert(derp);</p>\r\n</blockquote>\r\n<p>　　如果你这样写，Javascript并不会在意，而你真正弹出的答案是&ldquo;two&rdquo;！有很多方法可以防止对象做出这样的行为，可以以使用<strong>instanceOf</strong>，但更好的方法是正确的使用<strong>new</strong>关键字，这样显得更专业。</p>\r\n<p>　　现在你知道你的Javascript代码写的很烂了吧，如果你记住了上面所说的东西，你的代码就会有所改善。我喜欢用3个tab键来缩进代码，我喜欢用下划线来连接单词，我喜欢把函数名首字母大写来表示它是对象。当然，这个是另外一场讨论了。有很多原因会导致你的Javascript代码写的很烂，就像我有很多技术很烂一样，所以，尽情的在评论里表达你的意见，支持，反对，不吝赐教。</p>\r\n<p>　　非常感谢rogeliorv和 <a href="http://msujaws.wordpress.com/">Jared Wein</a>指出第五点中存在的错误。你们很强。</p>', 'JavaScript', '2011-05-01 8:56:49'),
(510, '页面元素拖拽 -- HTML中的setCapture和releaseCapture', '<p>setCapture函数的作用就是将后续的mouse事件都发送给这个对象，releaseCapture就是将鼠标事件还回去，由 document、window、object之类的自行来处理，这样就保证了在拖动的过程中，不会由于经过了其它的元素而受到干扰。另外，还有一个很重要的事情是，在Win32上，mouse move的事件不是一个连续的，也就是说，并不是我们每次移动1px的鼠标指针，就会发生一个mousemove，windows会周期性检查mouse 的位置变化来产生mousemove的事件。所以，如果是一个很小的页面对象，比如一个直径5px的圆点，如果没有setCapture和 releaseCapture，那么在鼠标按住之后，快速的移动鼠标，就有可能鼠标移动走了，但是小圆点还在原地，就是因为下一次的mousemove事件已经不再发给这个圆点对象了。</p>', 'JavaScript', '2011-04-30 15:20:59'),
(511, 'Javascript 面试题随笔之Function.call.call', '<a id="ctl02_TitleUrl" href="http://www.cnblogs.com/PrimerDotNet/archive/2011/04/14/2015548.html">Javascript 面试题随笔之Function.call.call</a>\r\n<p>今天无聊在群里面看到了一道面试题：</p>\r\n<pre title="code" class="brush: jscript;">\r\nfunction f1(){\r\n   alert(&quot;1&quot;);\r\n}\r\nfunction f2(){\r\n   alert(&quot;2&quot;);\r\n}\r\nvar f3=f1.call;\r\nf3.call(f2);\r\n</pre>\r\n<p>输出结果是2，后来想了一下，实在是让我大感JS的有趣，我的理解也不一定是正确的，只是想说出来，望有高手指正：我是这么理解：call函数是Function.prototype里面的函数，他在f1.call的情况下能调用f1，所以他的实现应该至少可以类似于</p>\r\n<p>&nbsp;</p>\r\n<pre title="code" class="brush: jscript;">\r\n Function.prototype.call = function(thispointer, arg1, arg2){\r\n	  thispointer = thispointer || window;\r\n	  thispointer.func = this;\r\n	  thispointer.func(arg1, arg2);\r\n	  delete thispointer.func;\r\n}\r\n</pre>\r\n<p>当f1.call.call(f2)被调用时，实际上的执行过程是：</p>\r\n<pre title="code" class="brush: jscript;">\r\nthispointer = f2;\r\nf2.func = f1.call;\r\nf2.func();\r\ndelete f2.func;\r\n</pre>\r\n<p>所以可以得到是f2.call()被调用了。就这样子。</p>', 'JavaScript', '2011-04-30 15:20:22'),
(512, '如何编写高质量的Javascript代码', '<p><a href="http://my.oschina.net/caiyuan/blog/13836">如何编写高质量的Javascript代码</a></p>', 'JavaScript', '2011-04-30 21:55:33');
INSERT INTO `list` (`id`, `title`, `content`, `cat`, `time`) VALUES
(532, '如何编写高质量的Javascript代码', '<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">http://my.oschina.net/caiyuan/blog/13836</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">优秀的<a href="http://www.phpied.com/">Stoyan Stefanov</a>在他的新书中（《Javascript Patterns》）介绍了很多编写高质量代码的技巧，比如避免使用全局变量，使用单一的var关键字，循环式预存长度等等。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">这篇文章不仅仅从代码本身来考虑如何优化编码，也从代码的设计阶段来考虑，包括书写API文档，同事的review，使用JSLint。这些习惯都能帮助你编写更加高质量的、更易于理解的、可维护的代码（让你的代码在多年之后仍使你引以为傲）。</p>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">编写可维护的代码</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">软件的BUG修复需要花费大量的精力。尤其当代码已经发布之后，随着时间的增长，维护的成本愈发的高。当你一发现BUG的时候，就立即去修复，这时候你的代码还是热乎的，你也不需要回忆，因为就是刚刚写好的。但是当你做了其他任务，几乎完全忘记了这份代码，这时候就需要：</p>\r\n<ul>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">重新学习和理解问题</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">理解代码是如何解决问题的</li>\r\n</ul>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">另外一个问题是，在大项目或者大公司里面，经常是解决BUG的人不是产生BUG的人，而且也不是发现BUG的人。所以减少理解代码的时间就是最重要的问题，无论这个代码是你自己以前写的还是团队中的其他成员写的，因为我们都想去搞搞新的有意思的东西，而不是去维护那些个陈旧的代码。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">还有一个开发中的普遍问题就是，往往读代码的时间比写代码的时间还要多。有时候你钻研一个问题，可以花整整一个下午的时间来考虑代码的编写。这个代码当时是可以工作的，但是随着开发的进行，其他东西发生了很大的变化，这时候也就需要你自己来重新审查修改编写代码。比如：</p>\r\n<ul>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">还有BUG没有解决</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">添加了新的功能</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">程序需要在新的环境中运行（比如一个新上市的浏览器）</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">代码有问题</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">代码需要重写因为修改了架构甚至要使用另一个语言</li>\r\n</ul>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">因为这些原因，也许你当时一个下午写好的代码，后面需要花费几周的时间来阅读。所以编写可维护的代码对于软件的成功至关重要。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">可维护的代码包括：</p>\r\n<ul>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">可读性</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">连续性</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">预见性</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">看起来是一个人写的</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">有文档</li>\r\n</ul>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">最少化全局变量</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">Javascript使用函数来约定作用域。一个在函数内部声明的变量在外部是不可见的。所以，全局变量也就是声明在任何函数之外的或者没有被声明的变量。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">Javascript中，在任何函数之外有个可访问的全局对象，每一个你创建的全局变量都是这个对象的一个属性。在浏览器中，为了方便，通常用window来指代这个全局变量。下面的代码就是说明如何创建一个全局变量：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nmyglobal = &quot;hello&quot;; // antipattern\r\n\r\nconsole.log(myglobal); // &quot;hello&quot;\r\n\r\nconsole.log(window.myglobal); // &quot;hello&quot;\r\n\r\nconsole.log(window[&quot;myglobal&quot;]); // &quot;hello&quot;\r\n\r\nconsole.log(this.myglobal); // &quot;hello</pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">全局变量的问题</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">全局变量的问题在于，他在你的所有代码或者一个页面中都共享。他们在同一个命名空间下面，这通常会造成变量名冲突&ndash;两个同名的变量，但是确实不同的用处。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">通常在一些页面中需要引入一些其他人的代码，比如：</p>\r\n<ul>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">第三方的JS库</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">广告伙伴的脚本</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">第三方的用户行为分析或者统计脚本</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">不同的组件、按钮等等</li>\r\n</ul>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">加入其中一个第三方组件定义了一个全局变量：result。然后在你的程序中，也定义了一个全局变量result。最后的这个result会覆盖点之前的result，这样第三方的脚本就会停止工作。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">所以，为了对其他的脚本友好，在一个页面中使用越少的全局变量越好。在后面会有一些方法来告诉你如何减少全局变量，比如使用命名空间，或者自执行的匿名函数，但是最好的避免全局变量的方法就是使用var关键字来声明变量。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">因为javascript的两个特性，创建一个全局变量非常的简单。第一，你可以使用一个甚至没有声明的变量，第二，在javascript中，所有未声明的变量都会成为全局对象的一个属性（就像一个声明了的全局变量一样）。看看这个例子：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nfunction sum(x,y){\r\n\r\n     result = x + y;\r\n\r\n     return result;\r\n\r\n}</pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">在这个代码中，result在没有被声明的情况下就被使用了，这个代码也能很好的工作，但是在调用了这个函数之后，就会多一个名为result的全局变量，这是所有问题的根源了。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">解决这个问题的办法就是使用var：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nfunction sum(x,y){\r\n\r\n     var result  = x + y;\r\n\r\n     return result;\r\n\r\n}</pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">两外一个不好的习惯就是在声明变量的时候使用链式的方法来赋值，这时候，a是局部变量，但是b就成为了全局变量。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nfunction foo(){\r\n\r\n     var a=b=0;\r\n\r\n     ....\r\n\r\n}</pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">这是因为，b = 0这个表达式先执行，执行的时候b并没有被声明，所以b就成为了全局变量，然后返回这个表达式的值0，给声明了的变量a，换句话说，就好像你输入的是：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nvar a = (b=0);</pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">如果你已经声明变量，那么这种链式的赋值没有问题：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nfunction foo(){\r\n\r\n     var a,b;\r\n\r\n     ...\r\n\r\n}</pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">另外一个避免使用全局变量的原因是考虑到程序的可移植性。如果你想让你的代码在不同的环境中都可以工作，那么使用全局变量就很可能会与新的系统中的全局变量冲突（或许在之前的系统中没有问题）。</p>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">忘记var的影响</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">使用var声明的全局变量和没有使用var生成的全局变量还有一个区别在于删除：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">使用var声明创建的全局变量不能被删除</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">没有使用var声明的全局变量可以被删除</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">这说明没有使用var声明生成的全局变量不是真正的变量，他们只是全局对象的属性。属性可以通过delete删除，但是变量不行：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\n// define three globals\r\n\r\nvar global_var = 1;\r\n\r\nglobal_novar = 2; // antipattern\r\n\r\n(function () {\r\n\r\n   global_fromfunc = 3; // antipattern\r\n\r\n}()); \r\n\r\n \r\n\r\n// attempt to delete\r\n\r\ndelete global_var; // false\r\n\r\ndelete global_novar; // true\r\n\r\ndelete global_fromfunc; // true \r\n\r\n \r\n\r\n// test the deletion\r\n\r\ntypeof global_var; // &quot;number&quot;\r\n\r\ntypeof global_novar; // &quot;undefined&quot;\r\n\r\ntypeof global_fromfunc; // &quot;undefined&quot;</pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">在ES5的严格模式下，给一个为声明的变量赋值会报错。</p>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">读取全局对象</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">在浏览器中，你可以通过window变量来读取全局对象（除非你在函数内部重新定义了window对象）。但在有的环境中，可能不叫window，那么你可以使用下面的代码来获取全局对象：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nvar global = (function(){\r\n\r\n     return this;\r\n\r\n})();</pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">这样可以获取到全局对象的原因是在function的内部，this指向全局对象。但是这在ES5的严格模式下会不起作用，你需要适配一些其他模式。当你开发自己的库的时候，你可以把你的代码封装在一个立即函数中，然后将this作为一个参数传进来。</p>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">单个var模式</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">在你的代码的顶部只是用一个var关键字，会有以下的好处：</p>\r\n<ul>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">对于所有需要的变量，在一个地方就可以全部看到</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">避免使用一个未定义的变量</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">帮助你记忆声明的变量，减少全局变量</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">更精简的代码</li>\r\n</ul>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">书写很简单：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nfunction func() {\r\n\r\n   var a = 1,\r\n\r\n       b = 2,\r\n\r\n       sum = a + b,\r\n\r\n       myobject = {},\r\n\r\n       i,\r\n\r\n       j;\r\n\r\n   // function body...\r\n\r\n}</pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">通过一个var和逗号来声明多个变量。在声明的时候给变量赋默认值也是不错的做法，可以避免一些逻辑错误，提高代码的可读性。而后你阅读的代码的时候也可以根据变量的默认值来方便的猜测变量的用途。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">你也可以在声明变量的时候做一些实际的工作，比如sum = a + b;另外，在操作DOM元素的时候，你也可以把DOM元素的引用保存在一个变量中：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nfunction updateElement() {\r\n\r\n   var el = document.getElementById(&quot;result&quot;),\r\n\r\n       style = el.style;\r\n\r\n   // do something with el and style...\r\n\r\n}</pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">滥用了的var</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">JavaScript允许你在函数内部有多个var语句，但是却都表现的如同在函数的顶部声明一样。这个特性在你使用一个变量然后在后面又声明了这个变量时会导致一些奇怪的逻辑问题。对于JavaScript来说，只要变量在同一个作用域，那么就认为是声明了的，就算是在var语句之前使用也一样。看看这个例子：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nmyname = &quot;global&quot;; // global variable\r\n\r\nfunction func() {\r\n\r\n    alert(myname); // &quot;undefined&quot;\r\n\r\n    var myname = &quot;local&quot;;\r\n\r\n    alert(myname); // &quot;local&quot;\r\n\r\n}\r\n\r\nfunc();</pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">在这个例子中，或许你期望第一次会弹出global，第二次弹出local。因为第一次的时候没有还没有使用var声明myname，这是应该是全局变量的myname，第二次声明了，然后alert之后应该是local的值。而事实上不是这样的，只要你在函数中出现了var myname，那么js就认为你在这个函数中声明了这个变量，但是在读取这个变量的值的时候，因为var语句还没有执行，所以是undefined，很奇怪的逻辑吧。上面的代码相当于：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nmyname = &quot;global&quot;; // global variable\r\n\r\nfunction func() {\r\n\r\n   var myname; // same as -&gt; var myname = undefined;\r\n\r\n   alert(myname); // &quot;undefined&quot;\r\n\r\n   myname = &quot;local&quot;;\r\n\r\n   alert(myname); // &quot;local&quot;\r\n\r\n}\r\n\r\nfunc();</pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">我们来解释一下这个现象，在代码的解析中，分两个步骤，第一步先处理变量函数的声明，这一步处理整个代码的上下文。第二步就是代码的运行时，创建函数表达式以及未定义的变量。实际上，我们只是假设了这个概念，这并不在ECMAScript的规范中，但是这个行为常常就是这样解释的。</p>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">for循环</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">在for循环中你会去迭代一些数组元素或者一些HTML元素。for循环常常如此：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nfor (var i = 0; i &lt; myarray.length; i++) {\r\n\r\n   // do something with myarray[i]\r\n\r\n}</pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">这样写的问题在于，每一次迭代的时候都会计算数组的长度，尤其在这个参数不是一个数组而是一组HTML元素的时候会降低你的程序的性能。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">HTML元素的集合在页面上，这样每次都会去再页面上查找相应的元素，这是非常耗时的。所以对于for循环，你需要预先保存数组的长度，这样写：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nfor (var i = 0, max = myarray.length; i &lt; max; i++) {\r\n\r\n   // do something with myarray[i]\r\n\r\n}</pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">这样缓存了参数的长度，在每次迭代的时候就不用再去查找计算了。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">在查找HTML元素集合的时候，缓存参数长度可以带来可观的性能提升，Safari下面提高两倍的速度，在IE7下面提高190倍的速度。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">需要注意的是，当你需要操作修改DOM元素的数量的时候，你肯定希望这个值是随时更新的而不是一个常量。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">使用下面的单一var模式，你也可以把var提到循环之外：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nfunction looper() {\r\n\r\n   var i = 0,\r\n\r\n        max,\r\n\r\n        myarray = [];\r\n\r\n   // ...\r\n\r\n   for (i = 0, max = myarray.length; i &lt; max; i++) {\r\n\r\n      // do something with myarray[i]\r\n\r\n   }\r\n\r\n}</pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">这个模式可以增强整个代码的连续性，但是不好的一点是当你重构代码的时候复制粘贴就没那么容易了。例如：如果你想在其他函数中也使用这个循环，那你需要确定在新的函数中处理好了i和max（或许还需要删掉这个）。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">这个函数还有两个点可以优化的：</p>\r\n<ul>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">可以少一个变量（不需要max）</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">递减到0，一个数字与0比较比这个数字与另外一个数字比较更快</li>\r\n</ul>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">所以就可以写为：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nvar i, myarray = [];\r\n\r\nfor (i = myarray.length; i--;) {\r\n\r\n   // do something with myarray[i]\r\n\r\n}</pre>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">针对第二点：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nvar myarray = [],\r\n\r\n    i = myarray.length;\r\n\r\nwhile (i--) {\r\n\r\n   // do something with myarray[i]\r\n\r\n}</pre>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">这是两个比较微小的点的优化。另外，JSLint可能对于i&ndash;会有意见。</p>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">for-in循环</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">for-in循环用来迭代非数组的对象。使用for-in循环通常也成为枚举。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">从技术上来说，你也可以用for-in来循环数组，因为数组也是对象，但是不推荐。如果数组有一些自定义的扩展函数，那么就会出错。另外，对象属性的顺序在for-in循环中也是不确定的。所以最好还是用普通的循环来循环数组用for-in来循环对象。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">在循环对象的过程中，使用hasOwnProperty()方法来检验是对象本身的属性还是原型链上的属性很重要。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">看看下面的这个例子。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\n// the object\r\n\r\nvar man = {\r\n\r\n   hands: 2,\r\n\r\n   legs: 2,\r\n\r\n   heads: 1\r\n\r\n}; \r\n\r\n \r\n\r\n// somewhere else in the code\r\n\r\n// a method was added to all objects\r\n\r\nif (typeof Object.prototype.clone === &quot;undefined&quot;) {\r\n\r\n   Object.prototype.clone = function () {};\r\n\r\n}</pre>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">在这个例子中，我们有一个简单的称作man的对象字面量。在其他man定义之前或之后的地方，对象原型有一个很有用的clone()方法。因为原型链的原因，所有的对象都自动获得了这个方法。为了在枚举man对象的时候出现clone方法，你需要使用hasOwnProperty方法来区别。如果没有区别来自原型链的方法，那么就会有一些意想不到的事情发生：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\n// 1.\r\n\r\n// for-in loop\r\n\r\nfor (var i in man) {\r\n\r\n   if (man.hasOwnProperty(i)) { // filter\r\n\r\n      console.log(i, &quot;:&quot;, man[i]);\r\n\r\n   }\r\n\r\n}\r\n\r\n/* result in the console\r\n\r\nhands : 2\r\n\r\nlegs : 2\r\n\r\nheads : 1\r\n\r\n*/\r\n\r\n// 2.\r\n\r\n// antipattern:\r\n\r\n// for-in loop without checking hasOwnProperty()\r\n\r\nfor (var i in man) {\r\n\r\n   console.log(i, &quot;:&quot;, man[i]);\r\n\r\n}\r\n\r\n/*\r\n\r\nresult in the console\r\n\r\nhands : 2\r\n\r\nlegs : 2\r\n\r\nheads : 1\r\n\r\nclone: function()\r\n\r\n*/</pre>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">另外一种使用方法如下：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nfor (var i in man) {\r\n\r\n   if (Object.prototype.hasOwnProperty.call(man, i)) { // filter\r\n\r\n      console.log(i, &quot;:&quot;, man[i]);\r\n\r\n   }\r\n\r\n}</pre>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">这样写的好处是可以防止man重新定义了hasOwnProperty方法导致的冲突。如果不想写这么长的一串，你也可以这样：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nvar i, hasOwn = Object.prototype.hasOwnProperty;\r\n\r\nfor (i in man) {\r\n\r\n    if (hasOwn.call(man, i)) { // filter\r\n\r\n        console.log(i, &quot;:&quot;, man[i]);\r\n\r\n    }\r\n\r\n}</pre>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">严格意义上讲，不适用hasOwnProperty也不是什么错误。根据任务的难度和你对代码的自信程度，你也可以不用这个直接循环。但是当你不确定的时候，最好还是使用这个方法检测一下。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">另外一种格式上的改变（不会通过jsLint的检查），去掉for的大括号，然后把if放在同一行。这样做的好处可以让循环体更加突出，缩进也就少一些：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\n// Warning: doesn''t pass JSLint\r\n\r\nvar i, hasOwn = Object.prototype.hasOwnProperty;\r\n\r\nfor (i in man) if (hasOwn.call(man, i)) { // filter\r\n\r\n    console.log(i, &quot;:&quot;, man[i]);\r\n\r\n}</pre>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">不要扩展内建的原型</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">扩展原型的构造函数，可以提供一些很强大的功能，但是有时候他太强大了。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">有时候你会去扩展Object(),Array(),Fucntion()的原型方法，这样会导致可维护性的问题，因为这会让你的代码的移植性变差。其他的开发人员使用你的代码的时候，可能只需要原生的方法，并不需要额外的功能。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">另外，你添加进去的方法，如果在循环的时候没有使用hasOwnProperty方法就会被遍历出来，这会让人很迷惑。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">所以，最好还是不要扩展基本的对象。除非是下面的情况：</p>\r\n<ul>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">你确定在将来根据ECMAScript规范，浏览器会添加相应的原型方法，那么是可以的，你只不过是提前实现了这个功能。</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">你确定的你要实现的方法不存在&ndash;或许有时候在代码的其他的地方实现了，或者有的浏览器支持，这都是不行的。</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">有非常清晰的文档，并且与团队成员沟通过</li>\r\n</ul>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">如果在这些情况之下，那么你就可以添加，最好是下面这种形式：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nif (typeof Object.protoype.myMethod !== &quot;function&quot;) {\r\n\r\n   Object.protoype.myMethod = function () {\r\n\r\n      // implementation...\r\n\r\n   };\r\n\r\n}</pre>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">switch模式</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">按照下面的风格写switch的话，可以提高你的代码可读性和健壮性：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nvar inspect_me = 0,\r\n\r\n    result = '''';\r\n\r\nswitch (inspect_me) {\r\n\r\ncase 0:\r\n\r\n   result = &quot;zero&quot;;\r\n\r\n   break;\r\n\r\ncase 1:\r\n\r\n   result = &quot;one&quot;;\r\n\r\n   break;\r\n\r\ndefault:\r\n\r\n   result = &quot;unknown&quot;;\r\n\r\n}</pre>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">需要注意下面几个方面：</p>\r\n<ul>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">将case和switch对齐。</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">case的内容缩进</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">每一个case之后都有一个清晰的break</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">避免顺序往下执行case，非要如此的话，文档一定要写清楚</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">最后使用default，保证在没有命中case的情况下也有反馈</li>\r\n</ul>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">避免隐藏的类型转换</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">Javascript在你比较两个变量的时候会进行类型的转换，这就是为什么 false == 0或者&rdquo;&quot; == 0会返回true。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">为了避免这种隐藏的类型转换带来的迷惑，最好使用===或者!==操作符来比较：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nvar zero = 0;\r\n\r\nif (zero === false) {\r\n\r\n   // not executing because zero is 0, not false\r\n\r\n} \r\n\r\n \r\n\r\n// antipattern\r\n\r\nif (zero == false) {\r\n\r\n   // this block is executed...\r\n\r\n}</pre>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">还有另外一种流派持这样的观点：当==够用时使用===就是多余的。比如，当你使用typeof的时候你知道会返回string，所以没必要使用严格的检验。然而，JSLint要求严格检验；他最大程度使代码在阅读的时候减少歧义，(&ldquo;这个==是故意呢还是疏漏？&rdquo;)。</p>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">避免使用eval()</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">如果你在你的代码中使用eval()，那么要记住&rdquo;eval() is evil&rdquo;。这个方法会将传入的字符串当做js代码来执行。如果代码是在运行前就确定的，那么没有必要使用eval()。如果代码是在运行时动态确定的，那么也有其他更安全的办法。例如使用方括号形式访问元素的属性：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\n// antipattern\r\n\r\nvar property = &quot;name&quot;;\r\n\r\nalert(eval(&quot;obj.&quot; + property));  \r\n\r\n \r\n\r\n// preferred\r\n\r\nvar property = &quot;name&quot;;\r\n\r\nalert(obj[property]);</pre>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">使用eval()还有安全问题，比如你运行网络上的一段代码，而这段代码又被别人篡改了。在处理Ajax请求返回的JSON数据的时候，最好还是使用浏览器内建的处理方法，如果对于低端的浏览器不支持的，可以从JSON.org上下载对应的处理库。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">另外还要记住使用setTimeout、setInterval以及Function的构造函数的是，传入的字符串的参数，js的处理方法跟eval()类似，所以也要注意。因为，js会把你传入的字符串解析执行：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\n// antipatterns\r\n\r\nsetTimeout(&quot;myFunc()&quot;, 1000);\r\n\r\nsetTimeout(&quot;myFunc(1, 2, 3)&quot;, 1000);  \r\n\r\n \r\n\r\n// preferred\r\n\r\nsetTimeout(myFunc, 1000);\r\n\r\nsetTimeout(function () {\r\n\r\n   myFunc(1, 2, 3);\r\n\r\n}, 1000);</pre>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">使用Function的构造函数，跟eval()差不多，也要注意。这是个非常有用的功能，但是常常被错用。如果你必须使用eval()，那么可以考虑new一个Function来替代。另外的一个好处就是，使用Function的构造函数，函数的作用域在本方法内，这样你使用var声明的变量就不会变成全局的。另外一个防止eval()生成全局变量的办法就是使用匿名函数。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">看看下面这个例子，只有un变量最终是全局的：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nconsole.log(typeof un); // &quot;undefined&quot;\r\n\r\nconsole.log(typeof deux); // &quot;undefined&quot;\r\n\r\nconsole.log(typeof trois); // &quot;undefined&quot;  \r\n\r\n \r\n\r\nvar jsstring = &quot;var un = 1; console.log(un);&quot;;\r\n\r\neval(jsstring); // logs &quot;1&quot;  \r\n\r\n \r\n\r\njsstring = &quot;var deux = 2; console.log(deux);&quot;;\r\n\r\nnew Function(jsstring)(); // logs &quot;2&quot;  \r\n\r\n \r\n\r\n jsstring = &quot;var trois = 3; console.log(trois);&quot;;\r\n\r\n (function () {\r\n\r\n    eval(jsstring);\r\n\r\n }()); // logs &quot;3&quot;  \r\n\r\n \r\n\r\n console.log(typeof un); // number\r\n\r\n console.log(typeof deux); // undefined\r\n\r\n console.log(typeof trois); // undefined</pre>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">eval()和Function构造函数的另一个区别就是eval()会影响到作用域，而Function则相当于一个沙盒。例如：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\n(function () {\r\n\r\n   var local = 1;\r\n\r\n   eval(&quot;local = 3; console.log(local)&quot;); // logs 3\r\n\r\n   console.log(local); // logs 3\r\n\r\n}());  \r\n\r\n \r\n\r\n(function () {\r\n\r\n   var local = 1;\r\n\r\n   Function(&quot;console.log(typeof local);&quot;)(); // logs undefined\r\n\r\n }());</pre>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">使用parseInt()转换处理数字</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">使用parseInt()你可以将字符串转为数字。这个方法支持第二个表示进制的参数，常常被忽略。问题常常在处理一段以0开始的字符串的时候。在ECMAS3标准中，以0开始表示八进制，但是在ES5中又改了，所以为了避免麻烦，最好还是标明第二个参数。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nvar month = &quot;06&quot;,\r\n\r\n    year = &quot;09&quot;;\r\n\r\nmonth = parseInt(month, 10);\r\n\r\nyear = parseInt(year, 10);</pre>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">在这个例子中，如果你使用parseInt(year)，就会返回0，因为09被认为是8进制数字，然而9是非法的八进制字符，所以返回0。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">其他的可以把字符串转为数字的方法有：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\n +&quot;08&quot; // result is 8\r\n\r\nNumber(&quot;08&quot;) // 8</pre>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">这些通常都比parseInt()快一些，因为parseInt并不只是简单的转换。但是如果你的输入是&rdquo;08 hello&rdquo;这样的，那么parseInt()也会返回8，但是其他的方法就只能返回NaN。</p>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">编码规范</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">编码的时候遵循一定的规范，可以让你的代码增强可移植性，并且更加便于阅读和理解。加入团队的新人，在阅读了代码规范之后，可以更加快速的溶入团队，并理解其他人员开发的代码。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">在一些讨论会议上，规范往往都是争论的焦点（比如缩进的形式）。所以如果你打算为你团队的编码规范提一些建议，那就准备好一场激烈的辩论和反对意见。要记住，建立和实施规范是非常重要的。</p>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">缩进</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">代码如果没有缩进，那基本上没法阅读了。比这更糟的是不规范的缩进，看着好像缩进了，但是乱七八糟摸不着头脑。所以缩进的使用必须规范。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">有些开发人员喜欢使用tab键来缩进，因为在每一个编辑器里面都可以自己设置想要的tab值。有的人喜欢四个空格。如果团队遵循统一的规范，这也不是什么问题。比如本文就是四个空格，这也是JSLint推荐的。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">那么什么该缩进呢？很简单，大括号。这样就是说包括函数体，循环，ifs，switch，以及对象字面量的属性。看看这个例子：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nfunction outer(a, b) {\r\n\r\n    var c = 1,\r\n\r\n        d = 2,\r\n\r\n        inner;\r\n\r\n    if (a &gt; b) {\r\n\r\n        inner = function () {\r\n\r\n            return {\r\n\r\n                r: c - d\r\n\r\n            };\r\n\r\n         };\r\n\r\n     } else {\r\n\r\n         inner = function () {\r\n\r\n             return {\r\n\r\n                 r: c + d\r\n\r\n             };\r\n\r\n         };\r\n\r\n     }\r\n\r\n     return inner;\r\n\r\n }</pre>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">大括号</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">应该使用大括号，尤其在那些可用可不用的地方，如果你的if语句或者for循环只有一句话，那么大括号不是必须的，但是这种时候最好用大括号。这可以让代码保持一致，并且便于升级。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">假设你的for循环只有一句。你可以不用大括号，也不会有什么错误。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\n// bad practice\r\n\r\nfor (var i = 0; i &lt; 10; i += 1)\r\n\r\n   alert(i);</pre>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">但是假如你以后要在这个循环里面添加其他东西呢？</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\n // bad practice\r\n\r\n for (var i = 0; i &lt; 10; i += 1)\r\n\r\n    alert(i);\r\n\r\n    alert(i + &quot; is &quot; + (i % 2 ? &quot;odd&quot; : &quot;even&quot;));</pre>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">这时候，虽然第二个alert有缩进，但他还是在循环之外的。所以，无论何时，都应该是用大括号。if语句一样：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\n// bad\r\n\r\nif (true)\r\n\r\n   alert(1);\r\n\r\nelse\r\n\r\n   alert(2);  \r\n\r\n \r\n\r\n// better\r\n\r\nif (true) {\r\n\r\n   alert(1);\r\n\r\n } else {\r\n\r\n    alert(2);\r\n\r\n }</pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">大括号位置</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">开发人员也经常争论大括号的位置，放在同一行还是下一行呢？</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">在具体的例子中，这是个见仁见智的问题。但也有例外，假如程序根据不同的位置做不同的解析呢？这是因为插入分号机制，js对此并不挑剔，他会在你没有添加分号的行之后帮你添加。这在函数返回一个对象字面量然后大括号写在下一行的时候出问题：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\n// warning: unexpected return value\r\n\r\nfunction func() {\r\n\r\n   return\r\n\r\n  // 下面的读取不到\r\n\r\n   {\r\n\r\n      name : &quot;Batman&quot;\r\n\r\n   }\r\n\r\n}</pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">如果你想让这个函数返回一个有name属性的对象字面量，这个函数是做不到的，因为插入的分号，返回的应该是一个undefied值。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">所以，最后的结论是，必须使用大括号，并且写在同一行。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nfunction func() {\r\n\r\n   return {\r\n\r\n      name : &quot;Batman&quot;\r\n\r\n   };\r\n\r\n}</pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">关于分号：跟大括号一样，必须写。这不只是推行严格的写程序的规范，更是在必要的时候解决一些不清楚的地方，比如前面的例子。</p>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">空格</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">正确的使用空格也可以增加程序的可读性和连贯性。写句子的时候你会在逗号和句号之后有一些停顿。在js中可以模仿这样的逻辑。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">应该使用空格地方有：</p>\r\n<ul>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">循环中的分号之后</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">循环中的变量初始化for (var i = 0, max = 10; i &lt; max; i += 1) {&hellip;}</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">数组中的逗号分隔符之后var a = [1, 2, 3];</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">对象字面量中的逗号var o = {a: 1, b: 2}</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">函数参数间myFunc(a, b, c)</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">在函数声明时候的大括号前面function myFunc() {}</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">匿名函数var myFunc = function () {};</li>\r\n</ul>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">另外一些使用空格比较好的地方就是在那些操作符的两边，比如+, -, *, =, &lt;, &gt;, &lt;=, &gt;=, ===, !==, &amp;&amp;, ||, +=,等等。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\n// generous and consistent spacing\r\n\r\n// makes the code easier to read\r\n\r\n// allowing it to &quot;breathe&quot;\r\n\r\nvar d = 0,\r\n\r\n    a = b + 1;\r\n\r\nif (a &amp;&amp; b &amp;&amp; c) {\r\n\r\n    d = a % c;\r\n\r\n    a += d;\r\n\r\n}  \r\n\r\n \r\n\r\n // antipattern\r\n\r\n // missing or inconsistent spaces\r\n\r\n // make the code confusing\r\n\r\n var d = 0,\r\n\r\n     a = b + 1;\r\n\r\n if (a &amp;&amp; b &amp;&amp; c) {\r\n\r\n     d = a % c;\r\n\r\n     a += d;\r\n\r\n }</pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">最后一个关于空格要注意的，大括号前面的空格。最好使用空格：</p>\r\n<ul>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">在函数定义，id-else，case，循环以及对象字面量的大括号前面使用空格</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">在大括号}与else、while之间使用空格</li>\r\n</ul>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">反对增加空格的一个说法是增加文件体积，但是在压缩之后并不存在这个问题。提高代码可读性经常被忽视的一个方面就是垂直的空格，你可以使用空行来分开代码，就好像写文章时候的段落一样。</p>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">命名规范</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">可以提高代码移植性和可维护性的一个方面是命名规范。也就是说，在取变量名的时候总是采取一贯的做法。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">无论采用什么样的命名规范，其实都不是很重要，重要的是确定下来这个规范，然后遵守它。</p>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">构造函数首字母大写</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">javascript中没有类，但是可以使用new来达到同样的目的。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">因为构造函数也是函数，如果能从名字上就能区别它是构造函数还是普通函数，对于开发者是非常有用的。所以将构造函数的首字母大写，普通函数的首字母小写作为提示。这样一眼就能区别。</p>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">单词的分隔</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">当你的变量名或者函数名是由好几个单词构成的时候，如果能顺利区分变量名由那几个单词构成，也是非常不错的体验。这种命名规范成为驼峰式。所谓驼峰式就是以小写字母开始，后面的每个单词第一个字母大写。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">对于构造函数第一个字母大写，MyConstructor()，对于普通的函数，就采用驼峰式myFunction(), calculateArea()。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">那么变量怎么办呢，有的人使用驼峰式，但是更好的办法是使用下划线来区分。first_name,favorite_bands, 以及 old_company_name。这也可以让你一眼就能区分函数和变量。</p>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">其他命名规范</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">有时候，开发人员也会使用命名规范来替代和弥补一些语言的特性。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">例如，在javascript中，并没有提供定义常量的办法（虽然有Number.MAX_VALUE），所以开发人员使用全大写的名称来表示不可更改的常量。var PI = 3.14, MAX_WIDTH = 800。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">另外一种规范是使用全局变量名的首字母。这样做可以强化开发者使全局变量最少，并且容易辨认。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">另外一种规范是在函数中模拟私有成员。虽然可以在javascript中实现私有变量，但是开发人员为了更加容易区别，所以给他加一个下划线的前缀。例如：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nvar person = {\r\n\r\n    getName: function () {\r\n\r\n        return this._getFirst() + '' '' + this._getLast();\r\n\r\n    },  \r\n\r\n \r\n\r\n    _getFirst: function () {\r\n\r\n        // ...\r\n\r\n    },\r\n\r\n    _getLast: function () {\r\n\r\n         // ...\r\n\r\n     }\r\n\r\n };</pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">在这个例子中，getName是一个公有函数，是API的一部分，_getFirst，_getLast本意是私有的。虽然仍然是公有函数，但hi加上了这个前缀，表示在以后的版本中不保证能运行，所以不应该被直接使用。注意在JSLint中不推荐这样做，除非你设置nomen选项为false。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">还有其他几种表示私有成员的规范：</p>\r\n<ul>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">在末尾使用下划线，比如name_以及getElements_</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">使用一个下划线表示保护成员_protected，两个下划线表示私有成员__private</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">在firefox中，有些不是语言原生的变量，以两个下划线开始，两个下划线结束__proto__以及__parent__</li>\r\n</ul>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">写注释</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">必须给你的代码写注释，就算它看起来不会被别人接手。有时候，你研究完一个问题，然后你看着代码觉得那是显而易见的，但是过一两周之后回头再看，你也会摸不着头脑的。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">当然，也不能过分的注释：每个变量每一行代码都注释。但是通常都需要对函数的功能，参数，返回值写文档，以及一些其他的复杂的逻辑和算法。想想，你的代码的阅读者，只需要读注释就能大体上了解你的代码在做什么需要什么，这比直接读代码理解要快的多。当你有五六行的代码是做一个具体的任务，那么阅读者就可以通过一行代码了解你的目的，然后跳过这些代码。关于注释，没有硬性的比例说是多少代码需要多少注释。有时候，有些代码（比如正则表达式）注释的内容肯定比代码本身多。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">写注释是必须遵守的规范，而且要保持注释的更新，一个过时的注释带给人的迷惑还不如不写注释。（<a href="http://net.tutsplus.com/tutorials/javascript-ajax/the-essentials-of-writing-high-quality-javascript/">译文</a>）</p>', '性能', '2011-04-30 11:14:22');
