-- phpMyAdmin SQL Dump
-- version 2.11.6
-- http://www.phpmyadmin.net
--
-- 主机: localhost
-- 生成日期: 2011 年 09 月 18 日 10:26
-- 服务器版本: 6.0.4
-- PHP 版本: 5.2.0RC4

SET SQL_MODE="NO_AUTO_VALUE_ON_ZERO";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;

--
-- 数据库: `notes`
--

-- --------------------------------------------------------

--
-- 表的结构 `list`
--

CREATE TABLE IF NOT EXISTS `list` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'id',
  `title` varchar(100) NOT NULL,
  `content` text NOT NULL COMMENT '内容',
  `cat` varchar(500) NOT NULL COMMENT '分类',
  `marrow` varchar(11) NOT NULL,
  `time` varchar(50) NOT NULL COMMENT '时间',
  PRIMARY KEY (`id`)
) ENGINE=MyISAM  DEFAULT CHARSET=gbk AUTO_INCREMENT=617 ;

--
-- 导出表中的数据 `list`
--

INSERT INTO `list` (`id`, `title`, `content`, `cat`, `marrow`, `time`) VALUES
(2, 'Frame中的scrolling="yes/no/auto"', '在设置Frame时，有一属性是scrolling="yes/no/auto"，IE6的mozilla都支持，但很显然地，IE的开发人员在这个地方懒了一下，他们对auto的理解很不人性化。auto的意思是自动，就是要的时候有，不要的时候没有。但如果设成auto，则在网页过长需要出竖起滚动条时，IE会自动地把水平滚动条也显示出来，哪怕网页完全不超宽。而设成yes时，IE则会一直出竖直滚动条，而不随便出水平条，这差不多是对的。所以如果要用Frame的话，还是要把这个属性设成Yes，这完全是为迁就IE。 mozilla则在任何时候都是对的。(google) \r\n', 'CSS', '0', '2011-01-05 21:12:30'),
(5, 'CSS方法解决chrome 12像素字体限制', '<p>CSS方法解决chrome 12像素字体限制：中文版的chrome有个12px字体限制的问题，就是当字体小于12px时候都以12px来显示，可以使用Webkit 的内核的 -webkit-text-size-adjust 的私有 CSS 属性来解决，比如下面的代码就可以成功的解决，通过它即可实现字体大小不随终端设备或浏览器影响。样式定义如下： #chrome10px{ -webkit-text-size-adjust:none; font-size:10px}</p>', 'CSS', '0', '2011-01-05 21:00:30'),
(4, 'FCKeditor', '<pre class="brush: jscript;" title="code">\r\nvar oFCKeditor = new FCKeditor(''content'');//传入参数为表单元素（由FCKeditor生成的input或textarea）的name\r\noFCKeditor.BasePath=''FCKEditor-syntaxhighlight/fckeditor/'';//指定FCKeditor根路径，也就是fckeditor.js所在的路径\r\noFCKeditor.Height=''200px'';\r\noFCKeditor.ToolbarSet=''Syntax2Demo'';//&lsquo;Default&rsquo;指定工具栏\r\noFCKeditor.Value=&quot;&quot;;//默认值\r\noFCKeditor.Create();\r\n</pre>', 'FCKeditor', '0', '2011-04-30 12:37:46'),
(7, 'table的浮动', '<p>给table定义align=&quot;left&quot;或align=&quot;right&quot;时就像是给div标签定义浮动，所以记得给父层定义清除浮动的样式，要不然js获取父层的offsetHeight时其值时0</p>', 'CSS', '0', '2011-01-04 21:11:30'),
(6, 'iframe,object和img底部会有间隙', 'iframe,object和img一样，有时候在非IE浏览器下底部会有间隙，定义vertical-align:top清除下就行了', 'CSS', '0', '2011-01-04 21:31:30'),
(3, '更改SVN中已经提交的版本的注释', '更改SVN中已经提交的版本的注释，提示说“请管理员创建pre-revprop-change钩子”，解决方法为在hooks目录下创建pre-revprop-change.bat，里面的代码如下：pre-revprop-change.bat所示(google) \r\n', 'SVN', '0', '2011-01-05 21:10:30'),
(1, 'input按钮文字隐藏', '<p>用line-height:9999px可以达到隐藏input按钮的文字的效果</p>', 'CSS', '0', '2011-05-01 14:12:30'),
(8, 'text-indent:-9999px隐藏input按钮文字要注意的细节', '<p>用text-indent:-9999px隐藏input按钮的文字时，一定要给这按钮float或display:block样式，否则在IE6和IE7下会出现整行显示不了的问题。</p>', 'CSS', '0', '2011-04-30 15:34:20'),
(9, '有浮动没有清除的层在FF下用js获取到的offsetheight的值为0', '有浮动没有清除的层在FF下用js获取到的offsetheight的值为0\r\n', 'JavaScript', '0', '2011-01-03 20:31:30'),
(10, 'Web性能优化', 'Web性能优化最佳实践中最重要的一条是减少HTTP请求，它也是YSlow中比重最大的一条规则。减少HTTP请求的方案主要有合并JavaScript和CSS文件、CSS Sprites、图像映射（Image Map）和使用Data URI来编码图片。CSS Sprites和图像映射现在已经随处可见了，但由于IE6和IE7不支持Data URI以及性能问题，这项技术尚未大量使用。目前大部分网页中的JavaScript和CSS文件数量和开发时一致，少量的网页会根据实际情况采取本地合并，这些合并中相当多的是有选择地手动完成，每次新的合并都需要重新在本地完成并上传到服务器，比较的随意和繁琐，同样文件的压缩也有类似的情况。而利用服务端的合并和压缩，我们就可以按照开发的逻辑尽可能让文件的颗粒度变小，利用网页中URL的规则来自动实现文件的合并和压缩，这会相当的灵活和高效。(<a href="http://dancewithnet.com/2010/06/08/minify-js-and-css-files-in-server/" target="_blank">随网之舞</a>)', '性能', '0', '2011-01-03 20:21:30'),
(11, 'a链接标签妙用', '<p>a链接标签不错，设置了href属性时就表现出了a标签的独特之处，没有设置href属性时它就是一个没有手型没有链接的内联元素非常好用</p>', 'HTML', '0', '2011-09-18 18:05:46'),
(16, 'textarea滚动条', '<p>IE下textarea文本区域默认是有滚动的，其他浏览器只有当内容输入过多的时候才出现滚动条。设置了overflow:hidden时，在所有浏览器中就算输入的内容再多滚动条都是被隐藏。设置overflow:auto时，在所有浏览器中都没滚动条，只有在内容输入过多时才出现滚动条，这很人性化(Opera除外)。</p>', 'CSS', '0', '2011-04-30 21:50:07'),
(15, 'CSS3旋转', '<pre class="brush: css;" title="code">\r\n-o-transform:rotate(30deg); -moz-transform:rotate(30deg); -webkit-transform:rotate(30deg);</pre>', 'CSS3', '0', '2011-01-02 19:10:30'),
(13, 'CSS3圆角', '<pre title="code" class="brush: css;">\r\nborder-radius:10px;-moz-border-radius:10px;-webkit-border-radius:10px;border:1px solid #eee</pre>', 'CSS3', '0', '2011-01-03 19:10:30'),
(14, 'CSS3阴影', '<pre class="brush: css;" title="code">\r\nbox-shadow:5px 5px 5px #333; -moz-box-shadow:5px 5px 5px #333;-webkit-box-shadow:5px 5px 5px #999;</pre>', 'CSS3', '0', '2011-01-02 19:10:30'),
(393, 'Firefox3下的getElementsByClassName', '<p>Firefox3实现的原生getElementsByClassName方法返回的不是javascript数组（Array），而是html element collection，这个东西可以用标准的方式遍历，但是却与Array没有共同的prototype（这个指javascript里面的原型继承的prototype）。所以，很不幸，如果你用了Prototype库的那个返回Array的方法写程序，然后使用了Array增强方法里面的first()等方法或者Emmerable里面的each()等方法，那么程序一定会出错。此时你可以$A一下这个html element collection，但是这不是好方法。因为其实Prototype在1.6以后就不推荐使用getElementsByClassName方法了。</p>', 'JavaScript', '0', '2011-04-30 21:51:28'),
(394, 'CSS个浏览器hack', '<pre class="brush: css;" title="code">\r\n#test{ \r\n　　　　　　　　color:red; /* 所有浏览器都支持 */ \r\n　　　　　　　　color:red !important;/* Firefox、IE7支持 */ \r\n　　　　　　　　_color:red; /* IE6支持 */ \r\n　　　　　　　　*color:red; /* IE6、IE7支持 */ \r\n　　　　　　　　*+color:red; /* IE7支持 */ \r\n　　　　　　　　color:red\\9; /* IE6、IE7、IE8支持 */ \r\n　　　　　　　　color:red\\0; /* IE8支持 */ \r\n　　　　　　　　} \r\nbody:nth-of-type(1) p{color:red;} /* Chrome、Safari支持 */\r\n</pre>', 'CSS', '0', '2011-04-30 15:34:48'),
(395, '设置file input的尺寸', '<p>通常情况下给file input设置宽或是设置size都不能把浏览按钮的宽度增宽，其实只要设置font-size就可以达到给浏览按钮增加宽度。</p>', 'CSS', '0', '2011-04-30 21:52:16'),
(396, 'Lazyload实现方式', '<p>把有图片的标签的HTML放在textarea标签内作为value，或者作为一段HTML的注释，这样可以使浏览器略过分析该HTML，图片也就不会加载</p>', '性能', '0', '2011-09-18 17:57:41'),
(403, '开启Fckeditor上传图片功能', '<p><strong>开启Fckeditor上传图片功能<br />\r\n</strong></p>\r\n<p>打开editor/filemanager/connectors/php目录下config.php，找到<br />\r\n&nbsp;</p>\r\n<pre class="brush: php;" title="code">\r\n$Config[''Enabled''] = false ; </pre>\r\n<p>更改为</p>\r\n<p>&nbsp;</p>\r\n<pre class="brush: php;" title="code">\r\n$Config[''Enabled''] = true ; </pre>\r\n<p>并在相应目录下建立userfiles上传目录后，Fckeditor上传图片功能开启。</p>\r\n<p>&nbsp;</p>\r\n<p>打开editor/filemanager/connectors/php目录下config.php文件，找到<br />\r\n&nbsp;</p>\r\n<pre class="brush: php;" title="code">\r\n$Config[''UserFilesPath''] = ''/userfiles/'' ; \r\n</pre>\r\n<p>更改为</p>\r\n<pre class="brush: php;" title="code">\r\n$Config[''UserFilesPath''] = ''/项目目录/userfiles/'' ; </pre>\r\n<p><strong>注意：此处userfiles文件夹是针对http://localhost/的根目录而言的。</strong></p>\r\n<p>&nbsp;</p>\r\n<p><strong>Fckeditor上传图片文件名重名及中文乱码解决方法</strong></p>\r\n<p>&nbsp;打开editor/filemanager/connectors/php目录下commands.php，找到FileUpload函数，在<br />\r\n&nbsp;</p>\r\n<pre class="brush: php;" title="code">\r\n$sExtension = substr( $sFileName, ( strrpos($sFileName, ''.'') + 1 ) ) ;\r\n$sExtension = strtolower( $sExtension ) ; </pre>\r\n<p>后添加</p>\r\n<p>&nbsp;</p>\r\n<pre class="brush: php;" title="code">\r\n$sFileName = rand(0,100).&quot;.&quot;.$sExtension; </pre>\r\n<p>此处rand函数可根据需要自行改变重命名规则。</p>\r\n<p>　　另一种上传图片文件名乱码解决方法为使用iconv函数对文件名进行编码转换，但仍然存在重名问题，所以针对Fckeditor上传图片文件名最好还是重命名。</p>', 'FCKEditor', '0', '2011-01-07 22:49:29'),
(408, 'FCKeditor', '<pre class="brush: jscript;" title="code">\r\nFCKConfig.ImageUpload = true ;\r\nFCKConfig.ImageUploadURL = FCKConfig.BasePath + ''filemanager/connectors/'' + _QuickUploadLanguage + ''/connector.'' + _QuickUploadExtension + ''?Command=FileUpload&amp;Type=Image&amp;CurrentFolder=%2F'' ;\r\nFCKConfig.ImageUploadAllowedExtensions	= &quot;.(jpg|gif|jpeg|png|bmp)$&quot; ;		// empty for all\r\nFCKConfig.ImageUploadDeniedExtensions	= &quot;&quot; ;							// empty for no one</pre>\r\n<p>FCKConfig.ImageUploadURL的地址改成如上所示后，通过点击图片按钮上传的图片就会自动放在image文件夹中去了。</p>', 'FCKeditor', '0', '2011-01-07 23:21:14'),
(547, 'HTML5自定义属性的规范', '<p><a href="http://www.infoq.com/cn/articles/dojo-1.6-html5">http://www.infoq.com/cn/articles/dojo-1.6-html5</a></p>\r\n<p>HTML5中已经有了针对自定义属性的规范。所有自定义属性都必须以data-作为前缀。这样就可以很方便的将HTML标准属性与自定义属性区分开来，不仅提供了代码的可读性也避免了与标准属性冲突的风险。</p>', 'HTML5', '0', '2011-04-30 16:06:13'),
(548, '翻译：HTML5介绍：视频和音频<三>', '<p>&nbsp;<a href="http://www.riameeting.com/node/803">http://www.riameeting.com/node/803</a></p>', 'HTML5', '0', '2011-04-30 16:06:49'),
(544, 'tagName vs nodeName', '<p>&nbsp;<a href="http://aleembawany.com/2009/02/11/tagname-vs-nodename/">http://aleembawany.com/2009/02/11/tagname-vs-nodename/</a></p>', 'JavaScript', '0', '2011-04-30 14:54:15'),
(545, '异步加载脚本', '<p>参考资料</p>\r\n<ol>\r\n    <li><a href="http://www.cnblogs.com/rubylouvre/archive/2011/04/12/2011175.html">http://www.cnblogs.com/rubylouvre/archive/2011/04/12/2011175.html</a></li>\r\n    <li><a href="http://www.iteye.com/topic/1019020">http://www.iteye.com/topic/1019020</a></li>\r\n    <li><a href="http://bbs.blueidea.com/thread-3020271-1-1.html">http://bbs.blueidea.com/thread-3020271-1-1.html</a></li>\r\n    <li><a href="http://seajs.com">http://seajs.com/</a></li>\r\n</ol>\r\n<pre title="code" class="brush: jscript;">\r\n(function(){\r\nvar scriptParent = document.getElementsByTagName(&quot;head&quot;)[0],\r\nscriptFlag = 1,\r\nscriptStack = [],\r\nbackStack = [],\r\nscriptUsed = {};\r\nfunction pushStack(){\r\n    scriptStack.push(slice.call(arguments));\r\n    if(scriptFlag==0){\r\n        scriptFlag = 1;\r\n        shiftStack();\r\n    }\r\n}\r\nfunction shiftStack(){\r\n    if(scriptStack.length){\r\n        var ls = scriptStack.shift();\r\n        ls.shift().apply(null,ls);\r\n    }\r\n    else if(backStack.length){\r\n        backStack.pop()();\r\n        shiftStack();\r\n    }\r\n    else{\r\n        scriptFlag = 0;\r\n    }\r\n}\r\nfunction loadScript(url,charset){\r\n    if(scriptUsed[url]){\r\n        setTimeout(shiftStack);\r\n        return ;\r\n    }\r\n    \r\n    var t = document.createElement(&quot;script&quot;);\r\n    t.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;);\r\n    \r\n    if(charset){\r\n        t.setAttribute(&quot;charset&quot;,charset);\r\n    }\r\n    \r\n    t.onreadystatechange = t.onload = function(){\r\n        if(!t.readyState || t.readyState == ''loaded'' || t.readyState == ''complete''){\r\n            t.onreadystatechange = t.onload = null;\r\n            t.parentNode.removeChild(t);\r\n            scriptUsed[url] = true;\r\n            shiftStack();\r\n        }\r\n    };\r\n    t.src = url;\r\n    scriptParent.appendChild(t);\r\n}\r\nvar Script = {\r\n    load:function(urls,callBack,charset){\r\n        if(callBack){\r\n            backStack.push(callBack);\r\n        }\r\n        \r\n        if(typeof urls == &quot;string&quot;){\r\n            pushStack(loadScript,urls,charset);\r\n        }\r\n        else{\r\n            for(var i=0;i&lt;urls.length;i+=1){\r\n                pushStack(loadScript,urls[i],charset);\r\n            }\r\n        }\r\n        return Script;\r\n    }\r\n};\r\nif(document.attachEvent){\r\n    document.attachEvent(&quot;onreadystatechange&quot;,function(){\r\n        if(document.readyState == &quot;complete&quot; || document.readyState == &quot;loaded&quot;){\r\n            shiftStack();\r\n        }\r\n    });\r\n}\r\nelse{\r\n    document.addEventListener(&quot;DOMContentLoaded&quot;, shiftStack, false);\r\n}\r\nwindow.Script = Script;\r\n})();</pre>', 'JavaScript', '0', '2011-05-01 15:42:57'),
(551, 'JS中getElementsByTagName()', '在JS中getElementsByTagName()获得的是一个类似于数组的NodeList对象，但除了有个length属性和下标取值以外再也没有别的数组方法了，因为他不是一个真正的数组对象。', 'JavaScript', '0', '2011-04-30 17:20:53'),
(552, '[翻译]F2E大会上关于@font-face的分享', '<a href=''https://lijing00333.wordpress.com/2011/04/29/lessons-on-font-face-from-the-f2e-summit/''>https://lijing00333.wordpress.com/2011/04/29/lessons-on-font-face-from-the-f2e-summit/</a>\r\n<p>原文：<a href="http://www.nczonline.net/blog/2011/04/05/lessons-on-font-face-from-the-f2e-summit/">http://www.nczonline.net/blog/2011/04/05/lessons-on-font-face-from-the-f2e-summit/</a><br /> \r\n标题：Lessons on @font-face from the F2E Summit<br /> \r\n作者：<a href="http://www.nczonline.net">NCZakas</a><br /> \r\n译文：F2E大会上关于@font-face的分享</p> \r\n<p>上周我参与组织了Yahoo F2E大会，这次大会聚集了Yahoo全球各地的前端工程师，其中@font-face是本次大会最受关注的话题之一，我们讨论了它的种种优势和缺陷，好记性不如烂笔头，我得赶紧把这些知识点记录下来，本篇内容来自于 Matt Seeley 关于“yahoo.com/tablet”的专题分享“<a href="http://www.slideshare.net/mattseeley/yahoocomtablet">iPad版Yahoo首页实战</a>”（Lessons from the Tablet Front Page），以及来自于Adam Wang关于面向未来的CSS3的专题分享“<a href="http://li228-21.members.linode.com/slide/f2e_summit_adam.html">无名小站新版首页案例分析</a>”（Case Study:<br /> \r\nWretch New Front Page），在这里我只是将他们的分享做了摘录。</p> \r\n<p><strong>兼容性</strong></p> \r\n<p>如果你不清楚&lt;video&gt;和&lt;audio&gt;标签的兼容性问题的话，你可能也不会知道 @font-face 的兼容性情况，尽管在桌面浏览器中可以通过 OpenType、TrueType 和 WOFF 可以比较好的做到兼容，但在移动终端则没办法轻易做到兼容。iOS4.1 和较早的版本只支持 SVG 字体，而 Android 只支持 TrueType 字体。iOS4.2 及后续版本开始同时支持 OpenType、TrueType 和 SVG 字体。也就是说，要想兼容 iOS 和 Android，只要将 css 代码精简成如下模样即可：</p> \r\n<pre>@font-face {\r\n    font-family: "Gotham Medium";\r\n    font-weight: normal;\r\n    font-style: normal;\r\n    src: url(gothmed.ttf) format(truetype),\r\n        url(gothmed.svg#id) format(svg);\r\n}</pre> \r\n<p><span id="more-219"></span><br /> \r\n也许这还不是最糟的，毕竟兼容性问题不止这么简单，因为在 IE9 中，src 属性不支持多值定义。比如上段代码会被错误的解析成：</p> \r\n<pre>@font-face {\r\n    font-family: "Gotham Medium";\r\n    font-weight: normal;\r\n    font-style: normal;\r\n    src: url(gothmed.ttf)%20format(truetype),%20url(gothmed.svg#id)%20format(svg);\r\n}</pre> \r\n<p>看到没，整个 src 属性被 URL 转码。也就是说在 IE8 及以下版本的浏览器中，将会发起一个类似这个 URL 的请求：</p> \r\n<pre>/gothmed.ttf)%20format(truetype),%20url(gotmed.svg</pre> \r\n<p>我们看到#之后的字串被当成 URL 的 hash 部分，并不参于组成 HTTP 请求地址。这样的话，每次浏览页面都会造成一个404的请求。因此尽管在早期版本的IE中不支持src的多值定义，依然会发起一个 HTTP 请求。</p> \r\n<p>为了解决这个问题，Matt 使用了 dataURI  来代替 TTF 字体文件，这样在IE8及更早版本的浏览器中就不会再发请求了。Matt 同样提及 dataURI 并不能代替 SVG 字体，因为 dataURI 的长度在 iOS 中受到了限制。</p> \r\n<p><strong>意外情形</strong></p> \r\n<p>Matt 同样指出了给 SVG 字体定义 text-overflow: ellipsis 样式时的意外情形，其他字体的这种样式定义是没问题的。当给 SVG 字体定义 text-overflow: ellipsis 的时候，所有的字符都莫名其妙的不见了，只剩下省略号。比如&#8221;My text&#8230;&#8221;最终显示成了&#8221;&#8230;&#8221;。</p> \r\n<p><strong>性能</strong></p> \r\n<p>说到性能，我通常会提到用户体验，以及更重要的关系户感官体验的性能(user-perceived performance)。Matt 和 Adam 在各自专题中都有提到事关@font-face的性能问题，Matt指出iOS中的<a href="http://paulirish.com/2009/fighting-the-font-face-fout/">文本样式短失效</a>（FOUT）问题实际上是“无文本闪烁”，他发现尽管网页渲染完毕，使用网页字体的文本内容也会因为字体文件没有下载完成而显示为空，他进一步指出，字体的下载只有在使用网页字体的dom元素被渲染的时候才会开始。这里我们采用了一种hack的手法来将字体下载时机提前――将字体定义放在&lt;html&gt;标签上，当然，更好的方式还有待进一步研究发掘。</p> \r\n<p>网页字体的另一个性能问题是字体文件的大小，在美国我们可以肆无忌惮的使用网页字体，因为字体无非由26个英文字母和一些标点符号组成而已，Adam 提到在亚洲文字的字体文件则要庞大的多，有的甚至能达到4～5MB。因此，如果你想在亚洲网站中应用非标准的字体，你需要重新审视由此造成的性能问题。</p> \r\n<p><strong>小结</strong></p> \r\n<p>看起来我们还有很长的路要走，还需要更深入的研究在网速允许的情况下@font-face的应用，除了兼容性和性能问题之外，还有很多难题需要攻克，非常感谢 Matt 和Adam 的分享，让我们更好的理解围绕网页字体的页面设计原理。</p> ', 'CSS', '0', '2011-05-01 16:21:26'),
(554, '一个简单的行拖动效果', '<pre class="brush:js;">\r\n\r\n//http://www.cnblogs.com/rubylouvre/archive/2011/04/16/2018148.html by 司徒正美\r\n        window.onload = function(){\r\n         //绑定事件\r\n        var addEvent = document.addEventListener ? function(el,type,callback){\r\n          el.addEventListener( type, callback, !1 );\r\n        } : function(el,type,callback){\r\n          el.attachEvent( &quot;on&quot; + type, callback );\r\n        }\r\n        //精确获取样式\r\n        var getStyle = document.defaultView ? function(el,style){\r\n          return document.defaultView.getComputedStyle(el, null).getPropertyValue(style)\r\n        } : function(el,style){\r\n          style = style.replace(/\\-(\\w)/g, function($, $1){\r\n            return $1.toUpperCase();\r\n          });\r\n          return el.currentStyle[style];\r\n        }\r\n        var dragManager = {\r\n          y:0,\r\n          draging:function(e){//mousemove时拖动行\r\n            var handler = dragManager.handler;\r\n            if(handler){\r\n              e = e || event;\r\n              //http://www.lxj.com/dev/front-end/javascript/Notes/%E9%80%89%E4%B8%AD%E6%96%87%E6%9C%AC.shtml\r\n              if(window.getSelection){//w3c\r\n                window.getSelection().removeAllRanges();\r\n              }else  if(document.selection){\r\n                document.selection.empty();//IE\r\n              }\r\n              var y = e.clientY;\r\n              var down = y &gt; dragManager.y;//是否向下移动\r\n              var tr = document.elementFromPoint(e.clientX,e.clientY);\r\n              if(tr &amp;&amp; tr.nodeName == &quot;TD&quot;){\r\n                tr = tr.parentNode\r\n                dragManager.y = y;\r\n                if( handler !== tr){\r\n                  tr.parentNode.insertBefore(handler, (down ? tr.nextSibling : tr));\r\n                }\r\n              };\r\n            }\r\n          },\r\n          dragStart:function(e){\r\n            e = e || event;\r\n            var handler = e.target || e.srcElement;\r\n            if(handler.nodeName === &quot;TD&quot;){\r\n              handler = handler.parentNode;\r\n              dragManager.handler = handler;\r\n              if(!handler.getAttribute(&quot;data-background&quot;)){\r\n                handler.setAttribute(&quot;data-background&quot;,getStyle(handler,&quot;background-color&quot;))\r\n              }\r\n              //显示为可移动的状态\r\n              handler.style.backgroundColor = &quot;#ccc&quot;;\r\n              handler.style.cursor = &quot;move&quot;;\r\n              dragManager.y = e.clientY;\r\n            }\r\n          },\r\n          dragEnd:function(){\r\n            var handler = dragManager.handler\r\n            if (handler) {\r\n              handler.style.backgroundColor = handler.getAttribute(&quot;data-background&quot;);\r\n              handler.style.cursor = &quot;default&quot;;\r\n              dragManager.handler = null;\r\n            }\r\n          },\r\n          main:function(el){\r\n            addEvent(el,&quot;mousedown&quot;,dragManager.dragStart);\r\n            addEvent(document,&quot;mousemove&quot;,dragManager.draging);\r\n            addEvent(document,&quot;mouseup&quot;,dragManager.dragEnd);\r\n          }\r\n        }\r\n        var el = document.getElementById(&quot;table&quot;);\r\n        dragManager.main(el);\r\n      }\r\n</pre>\r\n<p><textarea id="runcode1" style="width:80%" rows="10">   &lt;!doctype html&gt;  &lt;html&gt;    &lt;head&gt;      &lt;title&gt;行拖动 by 司徒正美&lt;/title&gt;      &lt;script&gt;              window.onload = function(){          //绑定事件          var addEvent = document.addEventListener ? function(el,type,callback){            el.addEventListener( type, callback, !1 );          } : function(el,type,callback){            el.attachEvent( &quot;on&quot; + type, callback );          }          //精确获取样式          var getStyle = document.defaultView ? function(el,style){            return document.defaultView.getComputedStyle(el, null).getPropertyValue(style)          } : function(el,style){            style = style.replace(/\\-(\\w)/g, function($, $1){              return $1.toUpperCase();            });            return el.currentStyle[style];          }          var dragManager = {            y:0,            draging:function(e){//mousemove时拖动行              var handler = dragManager.handler;              if(handler){                e = e || event;                if(window.getSelection){//w3c                  window.getSelection().removeAllRanges();                }else  if(document.selection){                  document.selection.empty();//IE                }                var y = e.clientY;                var down = y &gt; dragManager.y;//是否向下移动                var tr = document.elementFromPoint(e.clientX,e.clientY);                if(tr &amp;&amp; tr.nodeName == &quot;TD&quot;){                  tr = tr.parentNode                  dragManager.y = y;                  if( handler !== tr){                    tr.parentNode.insertBefore(handler, (down ? tr.nextSibling : tr));                  }                };              }            },            dragStart:function(e){              e = e || event;              var handler = e.target || e.srcElement;              if(handler.nodeName === &quot;TD&quot;){                handler = handler.parentNode;                dragManager.handler = handler;                if(!handler.getAttribute(&quot;data-background&quot;)){                  handler.setAttribute(&quot;data-background&quot;,getStyle(handler,&quot;background-color&quot;))                }                //显示为可移动的状态                handler.style.backgroundColor = &quot;#ccc&quot;;                handler.style.cursor = &quot;move&quot;;                dragManager.y = e.clientY;              }            },            dragEnd:function(){              var handler = dragManager.handler              if (handler) {                handler.style.backgroundColor = handler.getAttribute(&quot;data-background&quot;);                handler.style.cursor = &quot;default&quot;;                dragManager.handler = null;              }            },            main:function(el){              addEvent(el,&quot;mousedown&quot;,dragManager.dragStart);              addEvent(document,&quot;mousemove&quot;,dragManager.draging);              addEvent(document,&quot;mouseup&quot;,dragManager.dragEnd);              }          }          var el = document.getElementById(&quot;table&quot;);          dragManager.main(el);          }              &lt;/script&gt;      &lt;style&gt;        .table{          width:60%;          border: 1px solid red;          border-collapse: collapse;        }        .table td{          border: 1px solid red;          height: 20px;        }      &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;      &lt;h1&gt;行拖动 by 司徒正美&lt;/h1&gt;      &lt;table  id=&quot;table&quot; class=&quot;table&quot;&gt;        &lt;tbody&gt;          &lt;tr&gt;            &lt;td&gt;1&lt;/td&gt;            &lt;td&gt;One&lt;/td&gt;            &lt;td&gt;dom.require&lt;/td&gt;          &lt;/tr&gt;          &lt;tr id=&quot;2&quot; &gt;            &lt;td class=&quot;2&quot;&gt;2&lt;/td&gt;            &lt;td&gt;Two&lt;/td&gt;            &lt;td&gt;ControlJS &lt;/td&gt;          &lt;/tr&gt;          &lt;tr id=&quot;3&quot; &gt;            &lt;td class=&quot;3&quot;&gt;3&lt;/td&gt;            &lt;td&gt;Three&lt;/td&gt;            &lt;td&gt;HeadJS&lt;/td&gt;          &lt;/tr&gt;          &lt;tr id=&quot;4&quot; &gt;            &lt;td class=&quot;4&quot;&gt;4&lt;/td&gt;            &lt;td&gt;Four&lt;/td&gt;            &lt;td&gt;LAB.js&lt;/td&gt;          &lt;/tr&gt;          &lt;tr id=&quot;5&quot; &gt;            &lt;td class=&quot;5&quot;&gt;5&lt;/td&gt;            &lt;td&gt;Five&lt;/td&gt;            &lt;td&gt;$script.js&lt;/td&gt;          &lt;/tr&gt;          &lt;tr id=&quot;6&quot; &gt;            &lt;td class=&quot;6&quot;&gt;6&lt;/td&gt;            &lt;td&gt;Six&lt;/td&gt;            &lt;td&gt;NBL.js&lt;/td&gt;          &lt;/tr&gt;        &lt;/tbody&gt;      &lt;/table&gt;    &lt;/body&gt;  &lt;/html&gt;  </textarea></p>\r\n<p><button type="button" title="runcode1" class="runcode">运行代码</button></p>', 'JavaScript', '0', '2011-05-02 11:41:39'),
(433, '形式参数和实际参数', '<p>函数的参数分为形参和实参两种。在本小节中，进一步介绍形参、实参的特点和两者的关系。形参出现在函数定义中，在整个函数体内都可以使用，离开该函数则不能使用。实参出现在主调函数中，进入被调函数后，实参变量也不能使用。形参和实参的功能是作数据传送。发生函数调用时，主调函数把实参的值传送给被调函数的形参从而实现主调函数向被调函数的数据传送。 函数的形参和实参具有以下特点：&nbsp;<br />\r\n1. 形参变量只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元。因此，形参只有在函数内部有效。函数调用结束返回主调函数后则不能再使用该形参变量。&nbsp;<br />\r\n2. 实参可以是常量、变量、表达式、函数等，无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值，以便把这些值传送给形参。因此应预先用赋值，输入等办法使实参获得确定值。&nbsp;<br />\r\n3. 实参和形参在数量上，类型上，顺序上应严格一致，否则会发生类型不匹配&rdquo;的错误。&nbsp;<br />\r\n4. 函数调用中发生的数据传送是单向的。即只能把实参的值传送给形参，而不能把形参的值反向地传送给实参。 因此在函数调用过程中，形参的值发生改变，而实参中的值不会变化。</p>\r\n<div id="postmessage_183841">就例如一下一段函数</div>\r\n<pre title="code" class="brush: jscript;">\r\nvar a;\r\na = 0;\r\nfunction func(b)\r\n{\r\nb = 1;\r\ndocument.write(b);\r\n}\r\ndocument.write(a+&quot;&lt;br&gt;&quot;)\r\nfunc(a);\r\ndocument.write(&quot;&lt;br&gt;&quot;+a)</pre>\r\n<div>我希望的是，变量a经过func(a)之后，变成1，<br />\r\n但是出了这个func()这个函数体之后，a的值还是0。<br />\r\n这下大家应该明白了吧。<br />\r\n有什么办法使得a出了这个func()这个函数体之后，a的值变成1呢？<br />\r\n这个就是形参和实参的区别啦。</div>', 'JavaScript', '0', '2011-09-18 17:59:14'),
(434, '我是一个最硬心软的人，不关心的人我是不骂他的', '<p>&nbsp;我是一个最硬心软的人，不关心的人我是不骂他的</p>', '随笔', '0', '2011-09-18 17:58:19'),
(439, 'Javascript取和设FCKeditor值', '<p>利用Javascript取和设FCKeditor值也是非常容易的，如下：</p>\r\n<pre title="code" class="brush: jscript;">\r\n// 获取编辑器中HTML内容 \r\nfunction getEditorHTMLContents(EditorName) { \r\nvar oEditor = FCKeditorAPI.GetInstance(EditorName); \r\nreturn(oEditor.GetXHTML(true)); \r\n} \r\n\r\n// 获取编辑器中文字内容 \r\nfunction getEditorTextContents(EditorName) { \r\nvar oEditor = FCKeditorAPI.GetInstance(EditorName); \r\nreturn(oEditor.EditorDocument.body.innerText); \r\n} \r\n\r\n// 设置编辑器中内容 \r\nfunction SetEditorContents(EditorName, ContentStr) { \r\nvar oEditor = FCKeditorAPI.GetInstance(EditorName) ; \r\noEditor.SetHTML(ContentStr) ; \r\n}</pre>\r\n<p>&nbsp;</p>', 'FCKeditor', '0', '2011-01-09 10:23:00'),
(473, 'Lazyload', '<p>Lazyload的一个作用就是延迟html渲染。原理是先保存元素里面的html，当判断元素在加载范围里面时，再加载里面的html。程序主要是做判断的部分，而如何保存和加载就看各位的想象力了。以下几种方法个人认为还不错的： <br />\r\n1，ajax法：保存地址，加载时利用ajax读取实际内容并插入到元素中；使用恰当的话能有效节省服务器资源，特别是要读数据库的地方，但响应速度受网络影响，而且不利seo，类似的还可以用iframe。 <br />\r\n2，textarea法：把html保存到一个textarea中，加载时把value插入元素中；利用了textarea的特性，第二个实例就使用了这个方法，淘宝用的也是这个方式，使用简单，响应速度快。不过仅仅是html的话，貌似也没必要延迟，可以考虑关联一些dom操作之类的。 <br />\r\n2，注释法：把html保存到一个注释中，加载时把内容插入元素中；跟textarea法类似，但效率应该更好，加载时找出nodeType为8的节点，再把nodeValue插入元素中；但在ie如果用innerHTML添加注释会被自动忽略掉，使用时注意。</p>', '性能', '0', '2011-01-09 20:47:22'),
(474, '去掉字符串的空格', '<pre class="brush: jscript;" title="code">\r\n	//去掉字符串的空格\r\n	String.prototype.trim = function(){\r\n		return this.replace(/(^[\\s]*)|([\\s]*$)/g, &quot;&quot;);\r\n	}\r\n</pre>', 'JavaScript', '0', '2011-01-09 20:51:50'),
(476, 'Firefox、chrome、safari中的textarea控件拉伸的功能', '<p>目前的Firefox、chrome、safari中的textarea控件，可以有拉伸的功能，有时这非常酷，但再好的东西并不是所有人都喜欢，你可以用CSS把这个功能屏蔽掉。 <br />\r\n解决方法:</p>\r\n<pre class="brush: css;" title="code">\r\nresize: none;</pre>\r\n<p>或者:</p>\r\n<pre class="brush: css;" title="code">\r\n    max-width:300px; \r\n    max-height:300px; \r\n    width:300px; \r\n    height:300px;  </pre>', 'CSS', '0', '2011-01-10 19:34:10'),
(484, '电脑对比', '<p><a href="http://product.pchome.net/compare_param_289672,300808.html">http://product.pchome.net/compare_param_289672,300808.html</a></p>\r\n<p><a href="http://php.tech.sina.com.cn/notebook/compare.php?d_id=10755,9848">http://php.tech.sina.com.cn/notebook/compare.php?d_id=10755,9848</a></p>', '随笔', '0', '2011-04-30 21:53:37'),
(485, 'Clarksfield和Arrandale', '<p><span style="color: rgb(255, 0, 0);"><strong>Clarksfield比Arrandale好</strong></span></p>\r\n<p>Arrandale是目前酷睿i3/i5处理器的内核代号，Clarksfield是酷睿i7的内核代号，不是架构。Arrandale内核的处理器均采用32nm工艺制作，为双核四线程，有3或4MB的三级缓存，内部集成GPU。Clarksfield采用45nm工艺制作，为四核八线程，有6或8MB的三级缓存，所以从性能上后者明显强于前者</p>', '随笔', '0', '2011-01-15 10:45:34'),
(543, 'JavaScript的事件代理', '<p>参考资料</p>\r\n<ol>\r\n    <li><a target="_blank" href="http://www.danwebb.net/2008/2/8/event-delegation-made-easy-in-jquery">http://www.danwebb.net/2008/2/8/event-delegation-made-easy-in-jquery</a></li>\r\n    <li><a target="_blank" href="http://blog.csdn.net/weinideai/archive/2009/01/19/3835839.aspx">http://blog.csdn.net/weinideai/archive/2009/01/19/3835839.aspx</a></li>\r\n    <li><a target="_blank" href="http://ghsky.com/2010/08/kissy-event-model-part-two.html">http://ghsky.com/2010/08/kissy-event-model-part-two.html</a></li>\r\n</ol>\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>\r\n<p><span style="font-family: Arial;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你想给网页添加点JavaScript的交互性，也许你已经听过JavaScript的<span style="color: #ff0000;">事件代理</span>（<span style="color: #ff0000;">event delegation</span>），并且觉得这是那些发烧友级别的JavaScript程序员才会关心的什么费解的设计模式之一。事实上，如果你已经知道怎么添加JavaScript的<span style="color: #ff0000;">事件处理器</span>（<span style="color: #ff0000;">event handler</span>），实现事件代理也是件轻而易举的事情。</span></p>\r\n<p><span style="font-family: Arial;">&nbsp;&nbsp;&nbsp;&nbsp; JavaScript事件是所有网页互动性的根基（我指的是<span style="background-color: #ff9900;">真正的互动性</span>，而不仅是那些<span style="background-color: #ff9900;">CSS下拉菜单</span>）。在传统的事件处理中，你按照需要为每一个元素添加或者是删除事件处理器。然而，<span style="color: #339966;">事件处理器</span>将有可能<span style="color: #339966;">导致</span><span style="background-color: #ff9900;">内存泄露或者是性能下降</span>&mdash;&mdash;你用得越多这种风险就越大。<span style="color: #339966;">JavaScript事件代理</span>则是<span style="color: #339966;">一种简单的技巧</span>，通过它你可以把<span style="color: #339966;">事件处理器</span><span style="background-color: #ff9900;">添加</span>到<span style="color: #339966;">一个父级元素</span>上，这样就避免了把事件处理器添加到多个子级元素上。</span></p>\r\n<p><span style="font-family: Arial;"><strong>它是怎么运作的呢？</strong></span></p>\r\n<p><span style="font-family: Arial;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #339966;">事件代理</span>用到了<span style="color: #339966;">两个</span>在JavaSciprt事件中<span style="background-color: #ff9900;">常被忽略</span>的<span style="color: #339966;">特性</span>：<span style="color: #ff0000;">事件冒泡</span>以及<span style="color: #ff0000;">目标元素</span>。当一个元素上的事件被触发的时候，比如说鼠标点击了一个按钮，<span style="color: #ff0000;">同样的事件</span>将会在<span style="background-color: #ff9900;">那个元素的所有祖先元素</span>中<span style="color: #ff0000;">被触发</span>。这一过程被称为<span style="color: #ff0000;">事件冒泡</span>；这个事件从<span style="color: #ff0000;">原始元素</span>开始一直<span style="color: #ff0000;">冒泡到</span><span style="background-color: #ff9900;">DOM树的</span><span style="color: #ff0000;">最上层</span>。任何一个事件的<span style="color: #ff0000;">目标元素</span>都是<span style="background-color: #ff9900;">最开始的那个元素</span>，在我们的这个例子中也就是按钮，并且它在我们的元素对象中<span style="color: #ff0000;"><span style="text-decoration: underline;">以属性的形式</span></span>出现。使用事件代理，我们可以把<span style="color: #ff0000;">事件处理器</span><span style="color: #339966;">添加</span>到<span style="color: #ff0000;">一个元素上</span>，等待<span style="color: #ff0000;">一个事件</span>从<span style="color: #339966;">它的子级元素</span>里<span style="color: #ff0000;">冒泡上来</span>，并且可以得知这个事件是<span style="color: #339966;">从哪个元素开始</span>的。</span></p>\r\n<p><span style="font-family: Arial;"><strong>这对我有什么好处呢？</strong></span></p>\r\n<p><span style="font-family: Arial;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 想象一下现在我们有一个10列、100行的HTML表格，你希望在用户点击表格中的某一单元格的时候做点什么。比如说我有一次就需要让表格中的每一个单元格在被点击的时候变成可编辑状态。如果把事件处理器加到这1000个单元格会产生一个很大的性能问题，并且有可能导致内存泄露甚至是浏览器的崩溃。相反地，使用事件代理，你只需要把<span style="color: #339966;">一个事件处理器</span><span style="background-color: #ff9900;">添加到</span><span style="color: #339966;">table元素上</span>就可以了，这个函数可以把<span style="color: #339966;">点击事件</span>给截下来，并且判断出是哪个单元格被点击了。</span></p>\r\n<p><span style="font-family: Arial;"><strong>用代码写出来是什么样呢？</strong></span></p>\r\n<p><span style="font-family: Arial;">&nbsp;&nbsp;&nbsp;&nbsp; 代码很简单，我们所要关心的只是如何检测目标元素而已。比方说我们有一个table元素，ID是&ldquo;report&rdquo;，我们为这个表格<span style="background-color: #ff9900;">添加</span><span style="color: #339966;">一个事件处理器</span>以<span style="color: #339966;">调用editCell函数</span>。editCell函数<span style="color: #ff0000;">需要判断</span><span style="background-color: #ff9900;">传到table来的事件</span>的<span style="color: #ff0000;">目标元素</span>。考虑到我们要写的几个函数中都有可能用到这一功能，所以我们把它单独放到一个名为getEventTarget的函数中：</span></p>\r\n<p><span style="font-family: Arial;">function getEventTarget(e) {<br />\r\n&nbsp; e = e || window.event;<br />\r\n&nbsp; return e.target || e.srcElement;<br />\r\n}</span></p>\r\n<p><span style="font-family: Arial;"><span style="color: #ff0000;">e</span>这个变量表示的<span style="color: #ff0000;">是</span>一个<span style="color: #ff0000;">事件对象</span>，我们只需要写一点点跨浏览器的代码来返回<span style="background-color: #339966;">目标元素</span>，在IE里目标元素放在srcElemnt属性中，而在其它浏览器里则是target属性。</span></p>\r\n<p><span style="font-family: Arial;">接下来就是editCell函数了，这个函数调用到了getEventTarget函数。一旦我们得到了目标元素，剩下的事情就是看看它是否是我们所需要的那个元素了。</span></p>\r\n<p style="padding-left: 30px;"><span style="font-family: Arial;">function editCell(e) </span></p>\r\n<p style="padding-left: 30px;"><span style="font-family: Arial;">{<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;var target = getEventTarget(e);<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(target.tagName.toLowerCase() ==''td'') </span></p>\r\n<p style="padding-left: 30px;"><span style="font-family: Arial;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DO SOMETHING WITH THE CELL<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />\r\n}</span></p>\r\n<p><span style="font-family: Arial;">在editCell函数中，我们通过检查<span style="color: #339966;">目标元素标签名称</span>的方法来确定它是否是一个表格的单元格。这种检查也许过于简单了点；如果它是这个目标元素单元格里的另一个元素呢？我们需要为代码做一点小小的修改以便于其找出父级的td元素。如果说有些单元格不需要被编辑怎么办呢？此种情况下我们可以为那些不可编辑的单元格添加一个指定的样式名称，然后在把单元格变成可编辑状态之前先检查它是否不包含那个样式名称。选择总是多样化的，你只需找到适合你应用程序的那一种。</span></p>\r\n<p><span style="font-family: Arial;"><strong>有哪些优点和缺点呢？</strong></span></p>\r\n<p><span style="font-family: Arial;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JavaScript事件代理带来的好处有：</span></p>\r\n<p><span style="font-family: Arial;">那些需要<span style="background-color: #339966;">创建的以及驻留在内存中</span>的<span style="color: #339966;">事件处理器</span>少了。这是很重要的一点，这样我们就提高了性能，并降低了崩溃的风险。 <br />\r\n在DOM更新后无须重新绑定事件处理器了。如果你的页面是动态生成的，比如说通过Ajax，你不再需要在元素被载入或者卸载的时候来添加或者删除事件处理器了。 <br />\r\n潜在的问题也许并不那么明显，但是一旦你注意到这些问题，你就可以轻松地避免它们：</span></p>\r\n<p><span style="font-family: Arial;">你的事件管理代码有成为性能瓶颈的风险，所以尽量使它能够短小精悍。 </span></p>\r\n<p><span style="font-family: Arial;">不是所有的事件都能冒泡的。blur、focus、load和unload不能像其它事件一样冒泡。事实上blur和focus可以用事件捕获而非事件冒泡的方法获得（在IE之外的其它浏览器中）。 <br />\r\n在管理鼠标事件的时候有些需要注意的地方。如果你的代码处理mousemove事件的话你遇上性能瓶颈的风险可就大了，因为mousemove事件触发非常频繁。而mouseout则因为其怪异的表现而变得很难用事件代理来管理。 </span></p>\r\n<p><span style="font-family: Arial;"><br />\r\n总结：<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 已经有一些使用主流类库的事件代理示例出现了，比如说jQuery、Prototype以及Yahoo! UI。你也可以找到那些不用任何类库的例子，比如说Usable Type blog上的这一个。</span><span style="font-family: Arial;">一旦需要的话，事件代理将是你工具箱里的一件得心应手的工具，而且它很容易实现。<br />\r\n</span></p>', 'JavaScript', '1', '2011-04-30 22:19:45'),
(489, 'gracecode.com', '<p><a href="http://www.gracecode.com/archives/3044/">http://www.gracecode.com/archives/3044/</a></p>\r\n<p><a href="http://code.taobao.org/svn/nginx_concat_module/trunk">http://code.taobao.org/svn/nginx_concat_module/trunk</a></p>', '性能', '0', '2011-01-17 21:21:15');
INSERT INTO `list` (`id`, `title`, `content`, `cat`, `marrow`, `time`) VALUES
(495, '漫谈B端的沙箱技术', '<p><a href="http://www.infoq.com/cn/articles/sandboxOnB">http://www.infoq.com/cn/articles/sandboxOnB</a></p>\r\n<p>从语言学的角度上来说，允许代码无节制地使用全局变量，是最错误的选择之一。而更可怕的，就是一个变量&quot;可能&quot;成为全局的（在未知的时间与地点）。但是这两项，却伴随JavaScript这门语言成功地走到了现在。</p>\r\n<p>也许是限于浏览器应用的规模，所以这一切还迟迟没有酿成灾难。在此之前，出现了两种解决方案。一种是ECMA在新的规范（Edition 5）中对此做出了限制，其中最重要的一条便是eval()的使用变得不再随意和无度。而另一种方案，则是相对没有那么官僚与学术的，尽管也拥有一个同样学术的名字：沙箱。</p>\r\n<p>沙箱（Sandbox）并不是一个新东西，即使对于JavaScript来说，也已经存在了相当长的时间。在SpiderMonkey JS的源代码中，就明确地将一个闭包描述为一个沙箱。这包含着许多潜在的信息：它有一个初始环境，可以被重置，可以被复制，以及最重要的，在它内部的所有操作，不会影响到外部</p>\r\n<p>当然事实上远非如此。JavaScript里的闭包只是一个&quot;貌似沙箱&quot;的东西--仍然是出于JavaScript早期的语言规范的问题，闭包不得不允许那些&quot;合法泄漏&quot;给外部的东西。而对于这一切无法忍受的前端工程师们，开始寻求另外的解决之道，这其中相对较早的尝试，是基于IFRAME的实践。例如dean.edwards在2006年提出过的方案（注1）：</p>\r\n<pre title="code" class="brush: jscript;">\r\na_frames.document.write(\r\n  &quot;&lt;script&gt;&quot;+\r\n  &quot;var MSIE/*@cc_on =1@*/;&quot;+ // sniff\r\n  &quot;parent.sandbox=MSIE?this:{eval:function(s){return eval(s)}}&quot;+\r\n  &quot;&lt;\\/script&gt;&quot;\r\n);\r\n</pre>\r\n<p>显然，由于在不同的IFRAME中运行着各自的JavaScript引擎实例，所以上述的方案也意味着沙箱是&quot;引擎&quot;这个级别的：在任何一个沙箱中的崩溃，将导致该引擎以及对应IFRAME崩溃。但--理论上说--不会影响整个浏览器。</p>\r\n<p>问题是，这并不那么理想。往往的，引擎会导致整个浏览器锁在那里，例如用alert()弹出一个对话框而又因为某种意外失去了焦点。又或者单个的IFRAME会导致全局的CPU被耗光，例如一个死循环。于是更加复杂的方案--在JavaScritp中包含一个完整的执行器--出现了。最有名的则是Narrative JavaScript，它内建了一个执行器，用于逐行地解释执行JavaScript代码，这使得它可以控制所有的代码执行序列，或者随时重置整个执行引擎--如同一个沙箱所要做的那样。</p>\r\n<p>这一切或者太过依赖于环境，又或者太过复杂，但都不乏追随者。例如jsFiddle这个项目（注2）在&quot;嵌入或装载&quot;这样的路子上就已经有了不俗的成绩。但是，YUI在新版本中却给出了它自己的选择：以更加明确的编程约定，来实现应用级别的沙箱。这包括一个非常简单的、新的YUI语法：</p>\r\n<pre title="code" class="brush: jscript;">\r\nYUI().use(''dom-base'', function(Y) {\r\n  // Y是一个新的沙箱\r\n});\r\n</pre>\r\n<p>在''dom-base''位置上，可以是1到N个字符串，表明一个需要在沙箱中装载的模块列表。这可以是沙箱的初始列表，或者后续的callback函数(亦即是用户代码)所需依赖的模块列表。在这种实现方案中，YUI为每个沙箱维护各自的装载模块列表和上下文环境中的变量、成员。但是出于JavaScript语言自己的局限，这个沙箱依然是相当脆弱的。例如下一示例中沙箱内的代码就会污染到全局：</p>\r\n<pre title="code" class="brush: jscript;">\r\nYUI().use('''', function(Y) {\r\n  abc = 1234;  //&lt;--这里可能导致一个全局变量''abc''被隐式地声明\r\n});\r\n</pre>\r\n<p>同样，在上述的沙箱里也可以使用类似window、document等全局变量、修改它们的成员或无限制地调用方法（例如使用setTimeout()来创建时钟）。所以YUI的沙箱事实上是靠&quot;规约&quot;来约束的，而不是真正意义上的沙箱。当然，这也意味着，如果用户能按照规约来处理沙箱内的代码，那么也就能自由地享用它带来的便利：安全、移植和有效的隔离副作用。</p>\r\n<p>而我们再穷究其根底，YUI沙箱的实质不过是一行:</p>\r\n<pre title="code" class="brush: jscript;">\r\n\r\n// code from yui.js\r\n//  - mod.fn(this, name)\r\nmod.entryFunc(sandbox, modName);\r\n</pre>\r\n<p>其实际含义是：</p>\r\n<ul>\r\n    <li>mod ：沙箱当前装载的模块；</li>\r\n    <li>entryFunc : 上述模块的入口函数；</li>\r\n    <li>sandbox ：当前的沙箱的实例，即YUI()返回值；</li>\r\n    <li>modName：模块名</li>\r\n</ul>\r\n<p>除了依赖关系（以及可能需要的异步加载）之外，YUI沙箱环境仅是用下面的代码来简单地调用callback函数：</p>\r\n<pre title="code" class="brush: jscript;">\r\ncallback(Y, response);\r\n</pre>\r\n<p>然而这些需求的实现并不那么复杂。首先，我们设定数据结构mod为一个对象：</p>\r\n<pre title="code" class="brush: jscript;">\r\n{ name:modName, fn: entryFunc, req: [], use: [] }</pre>\r\n<p>则一个环境对象env，将包括多个mod(将它们处理成对象而非数组，主要是便于使用名字来索引模块)和以及对它们进行管理操作的方法：</p>\r\n<pre title="code" class="brush: jscript;">\r\n\r\n{ mods:{}, used:{}, add:..., use:...}\r\n</pre>\r\n<p>最后，所谓一个沙箱sandbox，就是上述环境对象的一个实例，并在初始时sandbox.mods与sandbox.used为空。由此简单的实现为：</p>\r\n<pre title="code" class="brush: jscript;">\r\n/**\r\n * tiny sandbox framework\r\n * mirror from YUI3 by aimingoo.\r\n**/\r\nfunction Sandbox() {\r\n  if (!(this instanceof arguments.callee)) return new arguments.callee();\r\n  this.mods = this.mods || {};\r\n  this.used = {};\r\n}\r\n\r\nSandbox.prototype = {\r\n  add: function(modName, entryFunc, reqArr, useArr) {\r\n    this.mods[modName] = { fn: entryFunc, req: reqArr, use: useArr }\r\n  },\r\n\r\n  use: function() { \r\n    var mods = [].slice.call(arguments, 0); 	// 0..length-2 is modNames\r\n    var callback = mods.pop();  	// length-1 is callback\r\n    var recursive_load = function(name, mod) {\r\n      if (!this.used[name] &amp;&amp; (mod=this.mods[name])) {\r\n        mod.req.forEach(recursive_load, this);\r\n        mod.fn(this, name);\r\n        mod.use.forEach(recursive_load, this);\r\n        this.used[name] = true;\r\n      }\r\n    }\r\n    mods.forEach(recursive_load, this);\r\n    callback(this);\r\n  }\r\n}\r\n</pre>\r\n<p>现在我们来尝试一个与YUI类似的语法风格：</p>\r\n<pre title="code" class="brush: jscript;">\r\nSandbox().use('''', function(){\r\n   alert(''user code.'');\r\n});\r\n</pre>\r\n<p>或者，先向整个Sandbox环境注册一些模块（在真实的框架实现中，这一步可能是通过框架的装载器来初始化）：</p>\r\n<pre title="code" class="brush: jscript;">\r\n\r\n// for test, entry of mods\r\nf1 = function() { alert(''f1'') };\r\nf2 = function() { alert(''f2'') };\r\nf3 = function() { alert(''f3'') };\r\n\r\n// mods for global/common env.\r\nSandbox.prototype.mods = {\r\n  ''core'': { fn: f1, req: [], use: [] },\r\n  ''oo'':   { fn: f2, req: [''core''], use: [''xml''] },\r\n  ''xml'':  { fn: f3, req: [], use: [] }\r\n}\r\n</pre>\r\n<p>然后再尝试在一个沙箱实例中运行代码：</p>\r\n<pre title="code" class="brush: jscript;">\r\n// f1 -&gt; f2 -&gt; f3 -&gt; user code\r\nSandbox().use(''oo'', function(){\r\n   alert(''user code.'');\r\n});\r\n</pre>\r\n<p>其实即便是上述代码中用于处理模块依赖的逻辑，也并不是什么&quot;神奇的&quot;代码或者技巧。除开这些，这样的沙箱隔离泄露的能力还抵不过一个嵌入式DSL语言。而后者所应用的技巧很简单，看不出什么花招（注3)：</p>\r\n<pre title="code" class="brush: jscript;">\r\nwith (YUI()) this.eval(&quot;... mod_context ... &quot;);\r\n</pre>\r\n<p>这样一来，在mod_context里的代码就只会在YUI()的一个实例中造成污染了。当然，仍然是源于JavaScript的限制，我们还是无法避免一个变量泄露到全局--除非，我们回到js in js这个项目（注4），真的在环境中重新初始化一个js引擎。</p>\r\n<p>从这一意义上来说，引擎级别的沙箱与操作系统的进程一样，带来的是终级的解决方案，所以Chrome、IE等等主流浏览器纷纷有了&quot;独立进程&quot;模式。而在这样的背景之下，试图用&quot;框架内置沙箱&quot;来改善ECMAScript ed3中一些设计疏失的种种努力，不过是一张张空头的支票罢了。</p>', 'JavaScript', '0', '2011-05-02 15:41:19'),
(496, '[].slice.call(arguments, 0)', '<pre title="code" class="brush: jscript;">\r\nfunction argumentsArray(){\r\n	var mods = [].slice.call(arguments, 0); //将函数的形参储存为数组\r\n	return mods;\r\n}\r\ndocument.write(argumentsArray(1,2)+''&lt;br/&gt;'');//输出结果为:[1,2]\r\ndocument.write(argumentsArray(1,2,3)+''&lt;br/&gt;'');//输出结果为:[1,2,3]\r\ndocument.write(argumentsArray(''a'',''b'')+''&lt;br/&gt;'');//输出结果为:[''a'',''b'']\r\ndocument.write(argumentsArray(''a'',''b'',''h'',''j'')+''&lt;br/&gt;'');//输出结果为:[''a'',''b'',''h'',''j'']\r\ndocument.write(argumentsArray(''a'',''b'',''y'')+''&lt;br/&gt;'');//输出结果为:[''a'',''b'',''y'']</pre>', 'JavaScript', '1', '2011-05-01 16:45:45'),
(501, 'css3实战:制作一个弹性滑动的图片显示', '<p>css3实战&mdash;制作一个弹性滑动的图片显示</p>\r\n<pre title="code" class="brush: css;">\r\n    .flexbox {\r\n        background-color:#ffffff;\r\n \r\n        display: -webkit-box;\r\n        display: -moz-box;\r\n        display: box;\r\n \r\n        -webkit-box-orient: horizontal;\r\n        -moz-box-orient: horizontal;\r\n        box-orient: horizontal;\r\n \r\n        box-align: stretch;\r\n        \r\n        margin-top:20px;\r\n        position: relative;\r\n        overflow:hidden;\r\n \r\n        text-shadow: 1px 1px 1px rgba(240,240,240,0.7);\r\n        \r\n        box-shadow:0 0 10px #cccccc;\r\n        -webkit-box-shadow: 0 0 10px #cccccc;\r\n        -moz-box-shadow:0 0 10px #cccccc;\r\n \r\n    }\r\n \r\n    .flexbox &gt; div {\r\n        -webkit-box-flex: 1;\r\n        -moz-box-flex: 1;\r\n        box-flex: 1;\r\n \r\n        box-align: stretch;\r\n        \r\n        -moz-transition: all 0.5s ease-out;\r\n        -o-transition: all 0.5s ease-out;\r\n        -webkit-transition: all 0.5s ease-out;\r\n        transition: all 0.5s ease-out;\r\n        width: 0;\r\n    }\r\n \r\n    .flexbox &gt; div:hover {\r\n        width: 500px;\r\n    }</pre>\r\n<pre title="code" class="brush: xhtml;">\r\n    &lt;div class=&quot;flexbox&quot;&gt; \r\n        &lt;div&gt; \r\n           &lt;img src=&quot;images/1.png&quot; alt=&quot;死神1&quot; /&gt; \r\n        &lt;/div&gt; \r\n        &lt;div&gt; \r\n            &lt;img src=&quot;images/2.png&quot; alt=&quot;死神2&quot; /&gt; \r\n        &lt;/div&gt; \r\n        &lt;div&gt; \r\n            &lt;img src=&quot;images/3.png&quot; alt=&quot;死神3&quot; /&gt; \r\n        &lt;/div&gt; \r\n        &lt;div&gt; \r\n            &lt;img src=&quot;images/1.png&quot; alt=&quot;死神4&quot; /&gt; \r\n        &lt;/div&gt; \r\n        &lt;div&gt; \r\n            &lt;img src=&quot;images/2.png&quot; alt=&quot;死神5&quot; /&gt; \r\n        &lt;/div&gt; \r\n    &lt;/div&gt; </pre>', 'CSS3', '0', '2011-04-30 22:38:07'),
(502, '在IE下的JS编程需注意的内存释放问题', '<p>在IE下的JS编程需注意的内存释放问题</p>\r\n<p><a href="http://bbs.51js.com/viewthread.php?tid=51770">http://bbs.51js.com/viewthread.php?tid=51770</a></p>\r\n<p>在IE下的JS编程中，以下的编程方式都会造成即使关闭IE也无法释放内存的问题，下面分类给出：<br />\r\n<br />\r\n<font color="red">1、给DOM对象添加的属性是一个对象的引用。范例：</font><br />\r\nvar MyObject = {};<br />\r\ndocument.getElementById(''myDiv'').myProp = MyObject;<br />\r\n<font color="green">解决方法</font>：<br />\r\n在window.onunload事件中写上: document.getElementById(''myDiv'').myProp = null;<br />\r\n<br />\r\n<br />\r\n<font color="red">2、DOM对象与JS对象相互引用。范例：</font><br />\r\nfunction Encapsulator(element) {<br />\r\n&nbsp;&nbsp;this.elementReference = element;<br />\r\n&nbsp;&nbsp;element.myProp = this;<br />\r\n}<br />\r\nnew&nbsp;&nbsp;Encapsulator(document.getElementById(''myDiv''));<br />\r\n<font color="green">解决方法</font>：<br />\r\n在onunload事件中写上: document.getElementById(''myDiv'').myProp = null;<br />\r\n<br />\r\n<br />\r\n<font color="red">3、给DOM对象用attachEvent绑定事件。范例：</font><br />\r\nfunction doClick() {}<br />\r\nelement.attachEvent(&quot;onclick&quot;, doClick);<br />\r\n<font color="green">解决方法</font>：<br />\r\n在onunload事件中写上: element.detachEvent(''onclick'', doClick);<br />\r\n<br />\r\n<br />\r\n<font color="red">4、从外到内执行appendChild。这时即使调用removeChild也无法释放。范例：</font><br />\r\nvar parentDiv =&nbsp;&nbsp;document.createElement(&quot;div&quot;);<br />\r\nvar childDiv = document.createElement(&quot;div&quot;);<br />\r\ndocument.body.appendChild(parentDiv);<br />\r\nparentDiv.appendChild(childDiv);<br />\r\n<font color="green">解决方法</font>：<br />\r\n从内到外执行appendChild:<br />\r\nvar parentDiv =&nbsp;&nbsp;document.createElement(&quot;div&quot;);<br />\r\nvar childDiv = document.createElement(&quot;div&quot;);<br />\r\nparentDiv.appendChild(childDiv);<br />\r\ndocument.body.appendChild(parentDiv);<br />\r\n<br />\r\n<br />\r\n<font color="red">5、反复重写同一个属性会造成内存大量占用(但关闭IE后内存会被释放)。范例：</font><br />\r\nfor(i = 0; i &lt; 5000; i++) {<br />\r\n&nbsp;&nbsp;hostElement.text = &quot;asdfasdfasdf&quot;;<br />\r\n}<br />\r\n这种方式相当于定义了5000个属性！<br />\r\n<font color="green">解决方法：</font><br />\r\n其实没什么解决方法:P~~~就是编程的时候尽量避免出现这种情况咯~~</p>', '性能', '0', '2011-09-18 18:11:54'),
(499, 'Object.prototype.toString', '<p>为什么要用Object.prototype.toString而不是Function.prototype.toString或者其它？这是和他们的toString解释方式有关系的。下面是ECMA中对Object.prototype.toString的解释：</p>\r\n<p><code>Object.prototype.toString( )<br />\r\nWhen the toString method is called, the following steps are taken:<br />\r\n1. Get the [[Class]] property of this object.<br />\r\n2. Compute a string value by concatenating the three strings &ldquo;[object &ldquo;, Result (1), and &ldquo;]&rdquo;.<br />\r\n3. Return Result (2)<br />\r\n</code></p>\r\n<p>其过程简单说来就是：1、获取对象的类名（对象类型）。2、然后将[object、获取的类名、]组合并返回。</p>\r\n<p>ECMA中对Array有如下说明：</p>\r\n<p><code>The [[Class]] property of the newly constructed object is set to &ldquo;Array&rdquo;.</code></p>\r\n<p>因此我们用如下代码来检测数组：</p>\r\n<pre><span class="keywords">function</span> isArray(o) { <br />&nbsp;&nbsp;<span class="keywords">return</span> Object.<span class="global">prototype</span>.<span class="global">toString</span>.call(o) === <span class="string">''[object Array]''</span>;&nbsp;&nbsp;<br />}</pre>\r\n<p>function isArray(o) {&lt;br/&gt;  return Object.prototype.toString.call(o) === ''[object Array]''; &lt;br/&gt;}</p>\r\n<p>这种方式既解决了instanceof存在的跨页面问题，也解决了属性检测方式所存在的问题，实在是一种妙招，一个很好的解决方案。</p>\r\n<p>除此之外，这种解决办法也可以应用于判断Date,Function等类型的对象。</p>', 'JavaScript', '1', '2011-03-10 22:18:06'),
(500, 'You can see what we do，but we do more than what you see', '<p>前端: <br />\r\nYou can see what we do，but we do more than what you see.</p>', '随笔', '0', '2011-04-30 21:53:59'),
(503, '程序测试题', '<p>http://bbs.51js.com/viewthread.php?tid=45812&amp;extra=page%3D1</p>\r\n<p>我认识了一个程序员,讲到我们毕业生出来工资大概多少的时候,他出了一道题,说,这个题目的月薪是1000 ,如果做不出 说明你现在可能还需要努力突破￥1000 ,而不是突破￥5000   请用程序打印出a b c d e f g h i j k l这十二个字符的全部组合，每种组合占一行 你的结果可能会是 a b c d e a b c d f &hellip;&hellip; 请用任何你熟悉的语言写出程序   10分钟内完成</p>\r\n<pre title="code" class="brush: jscript;">\r\nvar stack = new Array(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;,&quot;g&quot;,&quot;h&quot;,&quot;i&quot;,&quot;j&quot;,&quot;k&quot;,&quot;l&quot;);\r\nvar buff = new Array();\r\n\r\nfunction getComb(stack, buff)\r\n{\r\n	if(stack.length + buff.length &lt; 5) return; //字母不够了，不用再试\r\n	while(stack.length &gt; 0) //字母还没用完\r\n	{\r\n		buff.push(stack.shift()); //选取字母\r\n		if(buff.length &lt; 5) //还没到5个字母\r\n		{\r\n			getComb(stack.slice(0), buff.slice(0)); //继续选取\r\n		}\r\n		else if(buff.length == 5)\r\n		{\r\n			document.write(buff+&quot;&lt;br&gt;&quot;); //够数量了，输出\r\n		}\r\n		buff.pop(); //丢弃用过的字母\r\n	}\r\n\r\n	return;\r\n}\r\ngetComb(stack, buff);</pre>', 'JavaScript', '0', '2011-04-30 22:38:50'),
(504, 'javascript中的作用域scope', '<p>javascript中的作用域scope</p>\r\n<p>在一般程序设计语言中，作用域是按块来划分的。即&ldquo;变量定义在哪个块之内，这个块就是变量的有效范围&rdquo;。而在javascript中，变量的作用域是按函数来划分的&mdash;&mdash;变量在某个函数范围内有效。比如：</p>\r\n<p>var f = false;</p>\r\n<p>if(true) { var f = true; } &nbsp; //此时f位于if内，也就是块内，等价于还是全局范围内</p>\r\n<p>alert(f) &nbsp;//所以，结果为true</p>\r\n<p>&nbsp;</p>\r\n<p>再如下例：</p>\r\n<p>var f = false;</p>\r\n<p>function test() {</p>\r\n<p>　　var f = true; &nbsp;//这是函数内定义的变量，只在函数内部有效，函数执行完毕后，该变量将被释放</p>\r\n<p>}</p>\r\n<p>test();</p>\r\n<p>alert(f) //结果为false，并没有因为test()的执行而改变</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>再有，在javascript中声明的全局变量都可以看作是window对象的一个属性，比如：</p>\r\n<p>var test = &quot;this is a test&quot;;</p>\r\n<p>alert(window.test == test) &nbsp;//结果为true</p>\r\n<p>这正好验证了上边所说的全局变量也是window对象的属性</p>\r\n<p>&nbsp;</p>\r\n<p>最后，我们来看</p>\r\n<p>function test() {</p>\r\n<p>　　f = false;</p>\r\n<p>}</p>\r\n<p>test();</p>\r\n<p>alert(f) //结果为false</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>', 'JavaScript', '0', '2011-04-30 15:19:49'),
(505, '最佳的"addEvent"是怎样诞生的', '<h2>最佳的&quot;addEvent&quot;是怎样诞生的</h2>\r\n<p>&nbsp;IE的 JScript 存在内存泄露的bug 想必大家都清楚或者有耳闻了。这是由于IE的内存回收管理器的一个设计错误导致的。当我们编写脚本的时候创建了交叉引用，例如如下代码： window.onload = function () {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; var x = document.getElementsByTagName(&rsquo;H3&rsquo;);&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; for (var i=0;i&lt;x.length;i++)&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x[i].onclick = openClose;&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x[i].relatedElement = x[i].nextSibling; // simplified situation&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x[i].relatedElement.relatedElement = x[i];&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;<br />\r\n}或者在函数中使用脚本语言最常见的闭句Closures的时候，IE都无法回收内存。而闭句在给DOM对象注册事件处理器(event handler)的时候最为常用。Novemberborn提供了一些example可以让你运行并切实感受到这个bug。&nbsp;&nbsp;<br />\r\n我最喜爱的QuirkMode  去年初意识到这个bug存在巨大隐患，觉得有必要呼吁广大web开发者关注并竭力避免这个问题，于是举办了一个慈善邀请赛，鼓励大家提交各自  addEvent/removeEvent 方案。并终于在去年10月下旬宣布了他们认为的胜利者：John  Resig，让John赢得胜利的代码如下：&nbsp;&nbsp;&nbsp;<br />\r\n<br />\r\nfunction addEvent( obj, type, fn ) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp; if ( obj.attachEvent ) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; obj[&rsquo;e&rsquo;+type+fn] = fn;&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; obj[type+fn] = function(){obj[&rsquo;e&rsquo;+type+fn]( window.event );}&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; obj.attachEvent( &rsquo;on&rsquo;+type, obj[type+fn] );&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp; } else&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; obj.addEventListener( type, fn, false );&nbsp;&nbsp;<br />\r\n}&nbsp;&nbsp;<br />\r\nfunction removeEvent( obj, type, fn ) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp; if ( obj.detachEvent ) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; obj.detachEvent( &rsquo;on&rsquo;+type, obj[type+fn] );&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; obj[type+fn] = null;&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp; } else&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; obj.removeEventListener( type, fn, false );&nbsp;&nbsp;<br />\r\n}&nbsp;&nbsp;<br />\r\nQuirkMode 对选择John为胜利者的解释概括来说就是以上代码最简洁有效，在避免内存问题的同时还巧妙的保证了this关键字在ie的attachEvent中能正常工作。缺点当然还是存在：&nbsp;&nbsp;&nbsp;<br />\r\n<br />\r\n不支持 Netscape 4 和 Explorer 5 Mac。(有可能国内的程序员会嗤之以鼻，但国外很强调广泛的兼容性)&nbsp;&nbsp;&nbsp;<br />\r\n在 removeEvent 中遗漏了remove obj[&quot;e&quot;+type+fn]。&nbsp;&nbsp;&nbsp;<br />\r\n总之不管怎么说，简单取胜。&nbsp;&nbsp;<br />\r\n结果一出，众多参赛与评论者不服气，很快又挑出了John的代码的几处毛病：&nbsp;&nbsp;&nbsp;<br />\r\n<br />\r\naddEvent中本身就使用了闭句，所以没有根本解决IE内存泄露的问题。&nbsp;&nbsp;&nbsp;<br />\r\n没有解决同类型的事件可能被重复注册而被IE重复执行的问题。&nbsp;&nbsp;&nbsp;<br />\r\n几个高手于是提出了改进性的方案： /*&nbsp;&nbsp;<br />\r\nOriginal idea by John Resig&nbsp;&nbsp;<br />\r\nTweaked by Scott Andrew LePera, Dean Edwards and Peter-Paul Koch&nbsp;&nbsp;<br />\r\nFixed for IE by Tino Zijdel (crisp)&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; Note that in IE this will cause memory leaks and still doesn&rsquo;t  quite function the same as in browsers that do support the W3C event  model:&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; - event execution order is not the same (LIFO in IE against FIFO)&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; - functions attached to the same event on the same element multiple times will also get executed multiple times in IE&nbsp;&nbsp;<br />\r\n*/&nbsp;&nbsp;<br />\r\nfunction addEvent( obj, type, fn ) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; if (obj.addEventListener)&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj.addEventListener( type, fn, false );&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; else if (obj.attachEvent) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj[&quot;e&quot;+type+fn] = fn;&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj.attachEvent( &quot;on&quot;+type, function() { obj[&quot;e&quot;+type+fn](); } );&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;<br />\r\n}&nbsp;&nbsp;<br />\r\nfunction removeEvent( obj, type, fn ) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; if (obj.removeEventListener)&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj.removeEventListener( type, fn, false );&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; else if (obj.detachEvent) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj.detachEvent( &quot;on&quot;+type, obj[&quot;e&quot;+type+fn] );&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj[&quot;e&quot;+type+fn] = null;&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;<br />\r\n}&nbsp;&nbsp;<br />\r\n很明显，虽然修正了John代码的一些不足。但内存泄露依然存在，部分浏览器依然不支持，还是无法避免ie重复注册。另外根据注释:当在同一个对象上注册多个事件处理器的时候，IE与其他浏览器的执行顺序是不同的，这又是一个隐患。&nbsp;&nbsp;<br />\r\n<br />\r\n几天之后，一个被认为最严谨的方案由Dean Edwards 提出。Dean他的方案与众不同：&nbsp;&nbsp;&nbsp;<br />\r\n<br />\r\n不执行对象检测(Object detection)&nbsp;&nbsp;&nbsp;<br />\r\n没有调用 addeventListener/attachEvent 方法&nbsp;&nbsp;&nbsp;<br />\r\n保持this关键字的运行于正确的上下文环境&nbsp;&nbsp;&nbsp;<br />\r\n正确传递 event 对象参数&nbsp;&nbsp;&nbsp;<br />\r\n完全跨浏览器至此(包括IE4和NS4)&nbsp;&nbsp;&nbsp;<br />\r\n不存在内存泄露&nbsp;&nbsp;&nbsp;<br />\r\nDean的代码如下： // written by Dean Edwards, 2005&nbsp;&nbsp;<br />\r\n// <a target="_blank" href="http://dean.edwards.name/function%C2%A0">http://dean.edwards.name/function </a>  ; <br />\r\naddEvent(element, type, handler) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; // assign each event handler a unique ID&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; // 为事件处理函数设定一个唯一值&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; if (!handler.$$guid) handler.$$guid = addEvent.guid++;&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; // create a hash table of event types for the element&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; if (!element.events) element.events = {};&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; // create a hash table of event handlers for each element/event pair&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; var handlers = element.events[type];&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; if (!handlers) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handlers = element.events[type] = {};&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // store the existing event handler (if there is one)&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 如果对象已经注册有事件处理，那么要保留下来,并保存为第一个&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (element[&quot;on&quot; + type]) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handlers[0] = element[&quot;on&quot; + type];&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; // store the event handler in the hash table&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; handlers[handler.$$guid] = handler;&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; // assign a global event handler to do all the work&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; // 指派一个全局函数做统一的事件处理，同时避免了反复注册&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; element[&quot;on&quot; + type] = handleEvent;&nbsp;&nbsp;<br />\r\n};&nbsp;&nbsp;<br />\r\n// a counter used to create unique IDs&nbsp;&nbsp;<br />\r\naddEvent.guid = 1;function removeEvent(element, type, handler) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; // delete the event handler from the hash table&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; if (element.events &amp;&amp; element.events[type]) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete element.events[type][handler.$$guid];&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;<br />\r\n};function handleEvent(event) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; // grab the event object (IE uses a global event object)&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; event = event || window.event;&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; // get a reference to the hash table of event handlers&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; // 这里的 this 随 handlerEvent function 被触发的source element 变化而变化&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; var handlers = this.events[event.type];&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; // execute each event handler&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; for (var i in handlers) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //这样写才能保证注册的事件处理函数中的 this 得到正确的引用，直接handlers[i]()是不行的&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.$$handleEvent = handlers[i];&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.$$handleEvent(event);&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;<br />\r\n};&nbsp;&nbsp;<br />\r\n这段代码相比之前就大了不少了，不过确实很精妙。可是这段代码却引入了其他的问题，比如无法处理事件处理函数的返回值，for..in循环可能因为  (Object.prototype)的错误应用而中断等等...很快Dean推出一个&quot;updated version&quot;。&nbsp;&nbsp;<br />\r\n<br />\r\n要做到最好真的好辛苦。&nbsp;&nbsp;<br />\r\n<br />\r\n目前似乎Dean的最终版本是最全面的解决方案。不过就我个人意见，感觉有些吹毛求疵了。尽量使用浏览器本身的实现和保持简单是我一贯坚持的主张。但洋人这种严谨的态度，还是让我深深敬佩。</p>', 'JavaScript', '0', '2011-04-30 15:25:08');
INSERT INTO `list` (`id`, `title`, `content`, `cat`, `marrow`, `time`) VALUES
(506, 'javascript跨浏览器事件框架myEvent.js', '<p>IE与现代浏览器在DOM中最大的差异是什么无疑就是event了。各个浏览器接口的差异以及够头疼了，而IE甚至Firefox早期版本由于内存管理机制不完善，很容易在事件处理中导致内存泄漏。</p>\r\n<p>event究竟有多么复杂？可见前辈的6年前的努力：<a href="http://blog.csdn.net/alex197963/archive/2009/08/18/4458737.aspx">最佳的addEvent是怎样诞生的</a>，后起之秀jQuery也付出了一千六百多行血汗代码（v 1.5.1）搞定了6年后出现的各种核的浏览器。</p>\r\n<p>我参考前辈的代码以及自己的理解尝试写了一个事件框架，我的框架完成了一个事件机制的核心，它能提供统一接口实现多事件绑定以及避免内存泄漏等其他一些问题，更重要的是性能还不错。</p>\r\n<p><strong>我的手法：</strong></p>\r\n<ol>\r\n    <li>所有回调函数根据元素、事件类型、回调函数唯一ID缓存在一个_create对象中（其内部具体结构可见下面源码的关于_cache的注释）。</li>\r\n    <li>事件绑定使用一个_create代理函数处理，并且一个元素的各类型事件全部通过此进行分发，同时运用apply方法让IE的指针指向元素。</li>\r\n    <li>通过数组队列解决IE回调函数执行顺序的问题。</li>\r\n    <li>fix函数将处理回调函数传入的event参数以及其他兼容问题。此处参考了jQuery.event.fix。</li>\r\n    <li>断开事件与元素的循环引用避免内存泄漏。</li>\r\n</ol>\r\n<p><strong>一、核心实现：</strong></p>\r\n<pre class="brush:javascript">\r\n \r\n// myEvent 0.2\r\n// 2011.04.06 - TangBin - planeart.cn - MIT Licensed\r\n/**\r\n * 事件框架\r\n * @namespace\r\n * @see http://www.planeart.cn/?p=1285\r\n */\r\nvar myEvent = (function () {\r\nvar _fid = 1,\r\n	_guid = 1,\r\n	_time = (new Date).getTime(),\r\n	_nEid = ''{$eid}'' + _time,\r\n	_nFid = ''{$fid}'' + _time,\r\n	_DOM = document.addEventListener,\r\n	_noop = function () {},\r\n	_create = function (guid) {\r\n		return function (event) {\r\n			event = api.fix(event || window.event);\r\n			var i = 0,\r\n				type = (event || (event = document.event)).type,\r\n				elem = _cache[guid].elem,\r\n				data = arguments,\r\n				events = _cache[guid].events[type];\r\n \r\n			for (; i &lt; events.length; i ++) {\r\n				if (events[i].apply(elem, data) === false) event.preventDefault();\r\n			};\r\n		};\r\n	},\r\n	_cache = {/*\r\n		1: {\r\n			elem: (HTMLElement),\r\n			events: {\r\n				click: [(Function), (..)],\r\n				(..)\r\n			},\r\n			listener: (Function)\r\n		},\r\n		(..)\r\n	*/};\r\n \r\nvar api = {\r\n \r\n	/**\r\n	 * 事件绑定\r\n	 * @param	{HTMLElement}	元素\r\n	 * @param	{String}		事件名\r\n	 * @param	{Function}		要绑定的函数\r\n	 */\r\n	bind: function (elem, type, callback) {\r\n		var guid = elem[_nEid] || (elem[_nEid] = _guid ++);\r\n \r\n		if (!_cache[guid]) _cache[guid] = {\r\n			elem: elem,\r\n			listener: _create(guid),\r\n			events: {}\r\n		};\r\n \r\n		if (type &amp;&amp; !_cache[guid].events[type]) {\r\n			_cache[guid].events[type] = [];\r\n			api.add(elem, type, _cache[guid].listener);\r\n		};\r\n \r\n		if (callback) {\r\n			if (!callback[_nFid]) callback[_nFid] = _fid ++;\r\n			_cache[guid].events[type].push(callback);\r\n		} else\r\n			return _cache[guid];\r\n	},\r\n \r\n	/**\r\n	 * 事件卸载\r\n	 * @param	{HTMLElement}	元素\r\n	 * @param	{String}		事件名\r\n	 * @param	{Function}		要卸载的函数\r\n	 */\r\n	unbind: function (elem, type, callback) {\r\n		var events, i, list,\r\n			guid = elem[_nEid],\r\n			handler = _cache[guid];\r\n \r\n		if (!handler) return;\r\n		events = handler.events;\r\n \r\n		if (callback) {\r\n \r\n			list = events[type];\r\n			if (!list) return;\r\n			for (i = 0; i &lt; list.length; i ++) {\r\n				list[i][_nFid] === callback[_nFid] &amp;&amp; list.splice(i--, 1);\r\n			};\r\n			if (list.length === 0) return api.unbind(elem, type);\r\n \r\n		} else if (type) {\r\n \r\n			delete events[type];\r\n			api.remove(elem, type, handler.listener);\r\n \r\n		} else {\r\n \r\n			for (i in events) {\r\n				api.remove(elem, i, handler.listener);\r\n			};\r\n			delete _cache[guid];\r\n \r\n		};\r\n	},\r\n \r\n	/**\r\n	 * 事件触发 (注意：不会触发浏览器默认行为与冒泡)\r\n	 * @param	{HTMLElement}	元素\r\n	 * @param	{String}		事件名\r\n	 * @param	{Array}			(可选)附加数据\r\n	 */\r\n	triggerHandler: function (elem, type, data) {\r\n		var guid = elem[_nEid],\r\n			event = {\r\n				type: type,\r\n				target: elem,\r\n				currentTarget: elem,\r\n				preventDefault: _noop,\r\n				stopPropagation: _noop\r\n			};\r\n \r\n		data = data || [];\r\n		data.unshift(event);\r\n \r\n		guid &amp;&amp; _cache[guid].listener.apply(elem, data);\r\n \r\n		try {\r\n			elem[''on'' + type] &amp;&amp; elem[''on'' + type].apply(elem, data);\r\n			//elem[type] &amp;&amp; elem[type]();\r\n		} catch (e) {};\r\n	},\r\n \r\n	// 原生事件绑定接口\r\n	add: _DOM ? function (elem, type, listener) {\r\n		elem.addEventListener(type, listener, false);\r\n	} : function (elem, type, listener) {\r\n		elem.attachEvent(''on'' + type, listener);\r\n	},\r\n \r\n	// 原生事件卸载接口\r\n	remove: _DOM ? function (elem, type, listener) {\r\n		elem.removeEventListener(type, listener, false);\r\n	} : function (elem, type, listener) {\r\n		elem.detachEvent(''on'' + type, listener);\r\n	},\r\n \r\n	// 修正\r\n	fix: function (event) {\r\n		if (_DOM) return event;\r\n		var name,\r\n			newEvent = {},\r\n			doc = document.documentElement,\r\n			body = document.body;\r\n \r\n		newEvent.target = event.srcElement || document;\r\n		newEvent.target.nodeType === 3 &amp;&amp; (newEvent.target = newEvent.target.parentNode);\r\n		newEvent.preventDefault = function () {event.returnValue = false};\r\n		newEvent.stopPropagation = function () {event.cancelBubble = true};\r\n		newEvent.pageX = newEvent.clientX + (doc &amp;&amp; doc.scrollLeft || body &amp;&amp; body.scrollLeft || 0) - (doc &amp;&amp; doc.clientLeft || body &amp;&amp; body.clientLeft || 0);\r\n		newEvent.pageY = newEvent.clientY + (doc &amp;&amp; doc.scrollTop  || body &amp;&amp; body.scrollTop  || 0) - (doc &amp;&amp; doc.clientTop  || body &amp;&amp; body.clientTop  || 0);\r\n		newEvent.relatedTarget = event.fromElement === newEvent.target ? event.toElement : event.fromElement;\r\n \r\n		// !!IE写event会极其容易导致内存泄漏，Firefox写event会报错\r\n		// 拷贝event\r\n		for (name in event) newEvent[name] = event[name];\r\n \r\n		return newEvent;\r\n	}\r\n \r\n};\r\n \r\nreturn api;\r\n})();\r\n</pre>\r\n<p>我给一万个元素绑定事件进行了测试，测试工具为sIEve，结果：</p>\r\n<blockquote>\r\n<table width="340" border="1" cellpadding="7" cellspacing="2">\r\n    <tbody>\r\n        <tr>\r\n            <td width="100">事件框架</td>\r\n            <td width="73">耗时</td>\r\n            <td width="117">内存</td>\r\n        </tr>\r\n        <tr>\r\n            <td colspan="3" align="center" bgcolor="#F7F7F7">IE8</td>\r\n        </tr>\r\n        <tr>\r\n            <td>jQuery.bind</td>\r\n            <td>1064 MS</td>\r\n            <td>79.80 MB</td>\r\n        </tr>\r\n        <tr>\r\n            <td>myEvent.bind</td>\r\n            <td>623 MS</td>\r\n            <td>35.82 MB</td>\r\n        </tr>\r\n        <tr>\r\n            <td colspan="3" align="center" bgcolor="#F7F7F7">IE6</td>\r\n        </tr>\r\n        <tr>\r\n            <td>jQuery.bind</td>\r\n            <td>2503 MS</td>\r\n            <td>74.23 MB</td>\r\n        </tr>\r\n        <tr>\r\n            <td height="35">myEvent.bind</td>\r\n            <td>1810 MS</td>\r\n            <td>28.48 MB</td>\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n</blockquote>\r\n<p>可以看到无论是执行效率还是内存占用myEvent都比有一定优势，这是可能是由于jQuery事件机制过于强大导致其性能的损耗。<br />\r\n测试样本：<a href="http://www.planeart.cn/demo/myEvent/">http://www.planeart.cn/demo/myEvent/</a></p>\r\n<p><strong>二、扩展自定义事件机制</strong><br />\r\njQuery是可以自定义事件的，它用一个special命名空间存储自定义事件，我在上面代码的基础上模仿jQuery自定义事件机制，并把其著名的ready事件与另外一个jQuery hashchange事件插件移植过来。</p>\r\n<p>这两个自定义事件非常重要，ready事件可以在DOM就绪给元素绑定事件，比传统使用window.onload要快很多；hashchange事件可以监听锚点改变，常用于解决AJAX历史记录问题，如Twitter新版本就就采用此处理AJAX，使用锚点机制除了可以提高AJAX应用程序的用户体验外，如果按照一定规则还能被google索引到。</p>\r\n<p>当然，我前面文章实现的imgReady事件也可以通过此扩展进来，稍后更新。</p>\r\n<pre class="brush:javascript">\r\n \r\n// myEvent 0.2.2\r\n// 2011.04.07 - TangBin - planeart.cn - MIT Licensed\r\n/**\r\n * 事件框架\r\n * @namespace\r\n * @see http://www.planeart.cn/?p=1285\r\n */\r\nvar myEvent = (function () {\r\n \r\nvar _ret, _name,\r\n	_fid = 1,\r\n	_guid = 1,\r\n	_time = (new Date).getTime(),\r\n	_nEid = ''{$eid}'' + _time,\r\n	_nFid = ''{$fid}'' + _time,\r\n	_DOM = document.addEventListener,\r\n	_noop = function () {},\r\n	_create = function (guid) {\r\n		return function (event) {\r\n			event = myEvent.fix(event || window.event);\r\n			var type = (event || (event = document.event)).type,\r\n				elem = _cache[guid].elem,\r\n				data = arguments,\r\n				events = _cache[guid].events[type],\r\n				i = 0,\r\n				length = events.length;\r\n \r\n			for (; i &lt; length; i ++) {\r\n				if (events[i].apply(elem, data) === false) event.preventDefault();\r\n			};\r\n \r\n			event = elem = null;\r\n		};\r\n	},\r\n	_cache = {/*\r\n		1: {\r\n			elem: (HTMLElement),\r\n			events: {\r\n				click: [(Function), (..)],\r\n				(..)\r\n			},\r\n			listener: (Function)\r\n		},\r\n		(..)\r\n	*/};\r\n \r\nvar API = function () {};\r\nAPI.prototype = {\r\n \r\n	/**\r\n	 * 事件绑定\r\n	 * @param	{HTMLElement}	元素\r\n	 * @param	{String}		事件名\r\n	 * @param	{Function}		要绑定的函数\r\n	 */\r\n	bind: function (elem, type, callback) {\r\n		var events, listener,\r\n			guid = elem[_nEid] || (elem[_nEid] = _guid ++),\r\n			special = this.special[type] || {},\r\n			cacheData = _cache[guid];\r\n \r\n		if (!cacheData) cacheData = _cache[guid] = {\r\n			elem: elem,\r\n			listener: _create(guid),\r\n			events: {}\r\n		};\r\n \r\n		events = cacheData.events;\r\n		listener = cacheData.listener;\r\n		if (!events[type]) events[type] = [];\r\n		if (!callback[_nFid]) callback[_nFid] = _fid ++;\r\n		if (!special.setup || special.setup.call(elem, listener) === false) {\r\n			events[type].length === 0 &amp;&amp; this.add(elem, type, listener);\r\n		};\r\n		events[type].push(callback);\r\n	},\r\n \r\n	/**\r\n	 * 事件卸载\r\n	 * @param	{HTMLElement}	元素\r\n	 * @param	{String}		事件名\r\n	 * @param	{Function}		要卸载的函数\r\n	 */\r\n	unbind: function (elem, type, callback) {\r\n		var events, special, i, list, fid,\r\n			guid = elem[_nEid],\r\n			cacheData = _cache[guid];\r\n \r\n		if (!cacheData) return;\r\n		events = cacheData.events;\r\n \r\n		if (callback) {\r\n \r\n			list = events[type];\r\n			fid = callback[_nFid];\r\n			if (!list) return;\r\n \r\n			for (i = 0; i &lt; list.length; i ++) {\r\n				list[i][_nFid] === fid &amp;&amp; list.splice(i--, 1);\r\n			};\r\n			if (!list.length) this.unbind(elem, type);\r\n \r\n		} else if (type) {\r\n \r\n			special = this.special[type] || {};\r\n			if (!special.teardown || special.teardown.call(elem) === false) {\r\n				this.remove(elem, type, cacheData.listener);\r\n			};\r\n			delete events[type];\r\n \r\n		} else {\r\n \r\n			for (i in events) {\r\n				this.remove(elem, i, cacheData.listener);\r\n			};\r\n			delete _cache[guid];\r\n \r\n		};\r\n \r\n	},\r\n \r\n	/**\r\n	 * 事件触发 (注意：不会触发浏览器默认行为与冒泡)\r\n	 * @param	{HTMLElement}	元素\r\n	 * @param	{String}		事件名\r\n	 * @param	{Array}			(可选)附加数据\r\n	 */\r\n	triggerHandler: function (elem, type, data) {\r\n		var guid = elem[_nEid],\r\n			cacheData = _cache[guid],\r\n			event = {\r\n				type: type,\r\n				target: elem,\r\n				currentTarget: elem,\r\n				preventDefault: _noop,\r\n				stopPropagation: _noop\r\n			};\r\n \r\n		data = data || [];\r\n		data.unshift(event);\r\n \r\n		cacheData &amp;&amp; cacheData.events[type] &amp;&amp; _cache[guid].listener.apply(elem, data);\r\n \r\n		try {\r\n			elem[''on'' + type] &amp;&amp; elem[''on'' + type].apply(elem, data);\r\n			//elem[type] &amp;&amp; elem[type]();\r\n		} catch (e) {};\r\n	},\r\n \r\n	// 自定义事件接口\r\n	special: {},\r\n \r\n	// 原生事件绑定接口\r\n	add: _DOM ? function (elem, type, listener) {\r\n		elem.addEventListener(type, listener, false);\r\n	} : function (elem, type, listener) {\r\n		elem.attachEvent(''on'' + type, listener);\r\n	},\r\n \r\n	// 原生事件卸载接口\r\n	remove: _DOM ? function (elem, type, listener) {\r\n		elem.removeEventListener(type, listener, false);\r\n	} : function (elem, type, listener) {\r\n		elem.detachEvent(''on'' + type, listener);\r\n	},\r\n \r\n	// 修正\r\n	fix: function (event) {\r\n		if (_DOM) return event;\r\n \r\n		var name,\r\n			newEvent = {},\r\n			doc = document.documentElement,\r\n			body = document.body;\r\n \r\n		newEvent.target = event.srcElement || document;\r\n		newEvent.target.nodeType === 3 &amp;&amp; (newEvent.target = newEvent.target.parentNode);\r\n		newEvent.preventDefault = function () {event.returnValue = false};\r\n		newEvent.stopPropagation = function () {event.cancelBubble = true};\r\n		newEvent.pageX = newEvent.clientX + (doc &amp;&amp; doc.scrollLeft || body &amp;&amp; body.scrollLeft || 0) - (doc &amp;&amp; doc.clientLeft || body &amp;&amp; body.clientLeft || 0);\r\n		newEvent.pageY = newEvent.clientY + (doc &amp;&amp; doc.scrollTop  || body &amp;&amp; body.scrollTop  || 0) - (doc &amp;&amp; doc.clientTop  || body &amp;&amp; body.clientTop  || 0);\r\n		newEvent.relatedTarget = event.fromElement === newEvent.target ? event.toElement : event.fromElement;\r\n \r\n		// !!直接写event IE导致内存泄漏，Firefox会报错\r\n		// 伪装event\r\n		for (name in event) newEvent[name] = event[name];\r\n		return newEvent;\r\n	}\r\n \r\n};\r\n \r\nreturn new API();\r\n})();\r\n \r\n// DOM就绪事件\r\nmyEvent.ready = (function () {\r\n	var readyList = [], DOMContentLoaded,\r\n		readyBound = false, isReady = false;\r\n \r\n	function ready () {\r\n		if (!isReady) {\r\n			if (!document.body) return setTimeout(ready, 13);\r\n			isReady = true;\r\n \r\n			if (readyList) {\r\n				var fn, i = 0;\r\n				while ((fn = readyList[i++])) {\r\n					fn.call(document, {});\r\n				};\r\n				readyList = null;\r\n			};\r\n		};\r\n	};\r\n \r\n	function bindReady () {\r\n		if (readyBound) return;\r\n \r\n		readyBound = true;\r\n \r\n		if (document.readyState === ''complete'') {\r\n			return ready();\r\n		};\r\n \r\n		if (document.addEventListener) {\r\n			document.addEventListener(''DOMContentLoaded'', DOMContentLoaded, false);\r\n			window.addEventListener(''load'', ready, false);\r\n		} else if (document.attachEvent) {\r\n			document.attachEvent(''onreadystatechange'', DOMContentLoaded);\r\n			window.attachEvent(''onload'', ready);\r\n			var toplevel = false;\r\n			try {\r\n				toplevel = window.frameElement == null;\r\n			} catch (e) {};\r\n \r\n			if (document.documentElement.doScroll &amp;&amp; toplevel) {\r\n				doScrollCheck();\r\n			};\r\n		};\r\n	};\r\n \r\n	myEvent.special.ready = {\r\n		setup: bindReady,\r\n		teardown: function () {}\r\n	};\r\n \r\n	if (document.addEventListener) {\r\n		DOMContentLoaded = function () {\r\n			document.removeEventListener(''DOMContentLoaded'', DOMContentLoaded, false);\r\n			ready();\r\n		};\r\n	} else if (document.attachEvent) {\r\n		DOMContentLoaded = function () {\r\n			if (document.readyState === ''complete'') {\r\n				document.detachEvent(''onreadystatechange'', DOMContentLoaded);\r\n				ready();\r\n			};\r\n		};\r\n	};\r\n \r\n	function doScrollCheck () {\r\n		if (isReady) return;\r\n \r\n		try {\r\n			document.documentElement.doScroll(''left'');\r\n		} catch (e) {\r\n			setTimeout(doScrollCheck, 1);\r\n			return;\r\n		};\r\n		ready();\r\n	};\r\n \r\n	return function (callback) {\r\n		bindReady();\r\n \r\n		if (isReady) {\r\n			callback.call(document, {});\r\n		} else if (readyList) {\r\n			readyList.push(callback);\r\n		};\r\n \r\n		return this;\r\n	};\r\n})();\r\n \r\n// Hashchange Event v1.3\r\n(function (window, undefined) {\r\n    var config = {\r\n			delay: 50,\r\n			src: null,\r\n			domain: null\r\n		},\r\n		str_hashchange = ''hashchange'',\r\n        doc = document,\r\n		isIE = !-[1,],\r\n        fake_onhashchange, special = myEvent.special,\r\n        doc_mode = doc.documentMode,\r\n        supports_onhashchange = ''on'' + str_hashchange in window &amp;&amp; (doc_mode === undefined || doc_mode &gt; 7);\r\n \r\n    function get_fragment(url) {\r\n        url = url || location.href;\r\n        return ''#'' + url.replace(/^[^#]*#?(.*)$/, ''$1'');\r\n    };\r\n \r\n    special[str_hashchange] = {\r\n        setup: function () {\r\n            if (supports_onhashchange) return false;\r\n \r\n            myEvent.ready(fake_onhashchange.start);\r\n        },\r\n        teardown: function () {\r\n            if (supports_onhashchange) return false;\r\n            myEvent.ready(fake_onhashchange.stop);\r\n        }\r\n    };\r\n \r\n	/** @inner */\r\n    fake_onhashchange = (function () {\r\n        var self = {},\r\n            timeout_id, last_hash = get_fragment(),\r\n			/** @inner */\r\n            fn_retval = function (val) {\r\n                return val;\r\n            },\r\n            history_set = fn_retval,\r\n            history_get = fn_retval;\r\n \r\n        self.start = function () {\r\n            timeout_id || poll();\r\n        };\r\n \r\n        self.stop = function () {\r\n            timeout_id &amp;&amp; clearTimeout(timeout_id);\r\n            timeout_id = undefined;\r\n        };\r\n \r\n        function poll() {\r\n            var hash = get_fragment(),\r\n                history_hash = history_get(last_hash);\r\n            if (hash !== last_hash) {\r\n                history_set(last_hash = hash, history_hash);\r\n                myEvent.triggerHandler(window, str_hashchange);\r\n            } else if (history_hash !== last_hash) {\r\n                location.href = location.href.replace(/#.*/, '''') + history_hash;\r\n            };\r\n            timeout_id = setTimeout(poll, config.delay);\r\n        };\r\n \r\n        isIE &amp;&amp; !supports_onhashchange &amp;&amp; (function () {\r\n            var iframe,iframe_src, iframe_window;\r\n \r\n            self.start = function () {\r\n                if (!iframe) {\r\n                    iframe_src = config.src;\r\n                    iframe_src = iframe_src &amp;&amp; iframe_src + get_fragment();\r\n \r\n					iframe = doc.createElement(''<iframe tabindex="-1" style="display:none" title="empty" src="'' + (iframe_src || ''javascript:0'') + ''"></iframe>'');\r\n					myEvent.bind(iframe, ''load'', function () {\r\n						myEvent.unbind(iframe, ''load'');\r\n						iframe_src || history_set(get_fragment());\r\n                        poll();\r\n                    });\r\n					doc.getElementsByTagName(''html'')[0].appendChild(iframe);\r\n					iframe_window = iframe.contentWindow;\r\n                    doc.onpropertychange = function () {\r\n                        try {\r\n                            if (event.propertyName === ''title'') {\r\n                                iframe_window.document.title = doc.title;\r\n                            };\r\n                        } catch (e) {};\r\n                    };\r\n                };\r\n            };\r\n \r\n            self.stop = fn_retval;\r\n \r\n			/** @inner */\r\n            history_get = function () {\r\n                return get_fragment(iframe_window.location.href);\r\n            };\r\n \r\n			/** @inner */\r\n            history_set = function (hash, history_hash) {\r\n                var iframe_doc = iframe_window.document,\r\n                    domain = config.domain;\r\n                if (hash !== history_hash) {\r\n					iframe_doc.title = doc.title;\r\n                    iframe_doc.open();\r\n                    domain &amp;&amp; iframe_doc.write(''<script>document.domain="'' + domain + ''"</script>'');\r\n					iframe_doc.close();\r\n                    iframe_window.location.hash = hash;\r\n                };\r\n            };\r\n        })();\r\n \r\n        return self;\r\n    })();\r\n})(this);\r\n</pre>\r\n<p>ready事件是伪事件，调用方式：</p>\r\n<pre class="brush:javascript">\r\n \r\nmyEvent.ready(function () {\r\n    //[code..]\r\n});\r\n</pre>\r\n<p>hashchange事件可以采用标准方式绑定：</p>\r\n<pre class="brush:javascript">\r\n \r\nmyEvent.bind(window, ''hashchange'', function () {\r\n    //[code..]\r\n});\r\n</pre>\r\n<p>这里有一些文章值得阅读：<br />\r\n<a href="http://www.cnblogs.com/rubylouvre/archive/2010/03/26/1696182.html">javascript 跨浏览器的事件系统</a>(司徒正美。他博客有一系列的讲解)<br />\r\n<a href="http://typeof.net/2010/08/compatibility-with-elegance/">更优雅的兼容</a>（BELLEVE INVIS）</p>', 'JavaScript', '0', '2011-04-30 15:24:33'),
(507, '数组去重――一道前端校招试题', '<p><a href="https://lijing00333.wordpress.com/2011/02/08/%e6%95%b0%e7%bb%84%e5%8e%bb%e9%87%8d%e2%80%94%e2%80%94%e4%b8%80%e9%81%93%e5%89%8d%e7%ab%af%e6%a0%a1%e6%8b%9b%e8%af%95%e9%a2%98/">https://lijing00333.wordpress.com/2011/02/08/%e6%95%b0%e7%bb%84%e5%8e%bb%e9%87%8d%e2%80%94%e2%80%94%e4%b8%80%e9%81%93%e5%89%8d%e7%ab%af%e6%a0%a1%e6%8b%9b%e8%af%95%e9%a2%98/ </a></p>\r\n<h2 class="entry-title">数组去重&mdash;&mdash;一道前端校招试题</h2>\r\n<p>很多校招题是没有严格的标准答案的，只有知识点，只要几个关键点能答上来，不管程序是否真的能跑通，都可以拿分的。比如最常见的一道题：</p>\r\n<p>试题：<br />\r\n有这样一个数组，成员都是数字，例如<br />\r\nvar a = [1,2,3,4,5,2,3,4,6,7,8];<br />\r\n请实现a.distinct()方法，用来给数组a去掉重复值，要求对Array的原型进行扩展方法，并尽可能做到效率最优。</p>\r\n<p>考察点：<br />\r\n1，考察应试者是否理解原型链<br />\r\n2，考察应试者是否由意识的控制算法的时间复杂度，了解应试者对专业课知识的掌握程度<br />\r\n3，考察应试者对js数组函数的了解程度</p>\r\n<p>答案1：</p>\r\n<p>Array.prototype.distinct = function(){<br />\r\nvar a = [],b=[],oa = this.concat();<br />\r\nfor(var i = 1;i&lt;oa.length;i++){<br />\r\nfor(var j = 0;j&lt;i;j++){<br />\r\nif(b.indexOf(j)&gt;-1)continue;<br />\r\nif(oa[j] == oa[i]){<br />\r\nb.push(j);<br />\r\n}<br />\r\n}<br />\r\n}<br />\r\nthis.splice(0,this.length);<br />\r\nfor(var i = 0;i&lt;oa.length;i++){<br />\r\nif(b.indexOf(i)&gt;-1)continue;<br />\r\nthis.push(oa[i ]);<br />\r\n}<br />\r\nreturn this;<br />\r\n};</p>\r\n<p>&nbsp;</p>\r\n<p>答案2：</p>\r\n<p>Array.prototype.distinct = function(){<br />\r\nfor(var i = 0;i&lt;this.length;i++){<br />\r\nvar n = this[i ];<br />\r\nthis.splice(i,1,null);<br />\r\nif(this.indexOf(n) &lt; 0){<br />\r\nthis.splice(i,1,n);//不存在重复<br />\r\n}else{<br />\r\nthis.splice(i,1);//存在重复<br />\r\n}<br />\r\n}<br />\r\nreturn this;<br />\r\n};</p>\r\n<p>答案3：</p>\r\n<p>Array.prototype.distinct = function(){<br />\r\nvar self = this;<br />\r\nvar _a = this.concat().sort();<br />\r\n_a.sort(function(a,b){<br />\r\nif(a == b){<br />\r\nvar n = self.indexOf(a);<br />\r\nself.splice(n,1);<br />\r\n}<br />\r\n});<br />\r\nreturn self;<br />\r\n};</p>\r\n<p>得分点：<br />\r\n1，应试者起码应该自觉通过Array.prototype.distince来实现函数，若没有这样做，则扣分50%<br />\r\n2，应试者起码会给出答案1，得分30%，如果没有使用splice和concate，扣分20%<br />\r\n3，给出答案2的，得分80%，算法复杂度控制在O(n)<br />\r\n4，给出答案3的，得满分，算法复杂度控制在O(1)</p>\r\n<p>&nbsp;</p>', 'JavaScript', '1', '2011-04-30 15:23:31'),
(508, 'concat()――链接或拷贝数组', '<p>concat() 方法用于连接两个或多个数组。  该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。</p>', 'JavaScript', '0', '2011-04-30 15:22:51'),
(509, '能说明你的Javascript技术很烂的五个原因', '<p>　　<a href="http://news.cnblogs.com/n/97229/">http://news.cnblogs.com/n/97229/</a></p>\r\n<p id="page-note">　　本文是从 <a href="http://patrickavella.com/blog/5-reasons-your-javascript-stinks">5 Reasons Your Javascript Stinks</a> 这篇文章翻译而来。</p>\r\n<p>　　Javascript在互联网上名声很臭，但你又很难再找到一个像它这样如此动态、如此被广泛使用、如此根植于我们的生活中的另外一种语言。它的低学习门槛让很多人都称它为学前脚本语言，它另外一个让人嘲笑的东西是动态语言的概念是偏偏使用了高标准的静态数据类型。其实，你和Javascript都站错了立场，而现在，你让Javascript很生气。这里有五个原因能说明你的Javascript技术很烂。</p>\r\n<p><strong>1. 你没有使用命名空间。</strong></p>\r\n<p>　　是否还记得在大学里老师告诉你不要在家庭作业里使用全局变量？Javascript里的全局变量的使用方法也不例外。Web网页稍不留神就会变的混乱不堪、到处都是从互联网上各个角落里找来的乱糟糟的相互侵犯的脚本和脚本库。如果你把一个变量命名成loader()，那你是成心自找麻烦。如果你在无意识的情况下重载了一个函数，Javascript根本不会提醒你。你还把它叫做一种学前教育编程语言，还记得吧？我要说的是，你需要知道在做了这些后发生什么情况。</p>\r\n<blockquote>\r\n<p>function derp(){ alert(&ldquo;one&rdquo;); }<br />\r\nfunction derp(){ alert(&ldquo;two&rdquo;); }<br />\r\nderp();</p>\r\n</blockquote>\r\n<p>　　&ldquo;two&rdquo;，答案是&ldquo;two&rdquo;。并不是一定会这样，它也可能是&ldquo;one&rdquo;。所以，把你所有的代码都放在自己的命名空间里，这很容易。下面是定义自己的命名空间的一个简单做法。</p>\r\n<blockquote>\r\n<p>var foospace={};<br />\r\nfoospace.derp=function(){ alert(&ldquo;one&rdquo;); }<br />\r\nfunction derp(){ alert(&ldquo;two&rdquo;); }<br />\r\nfoospace.derp();</p>\r\n</blockquote>\r\n<p><strong>2. 你在变戏法，你把变量定义的东一个西一个。</strong></p>\r\n<p>　　你使用莫名其妙的数字字母组合作为变量名是一个双输的结局。在40行的代码块中寻找一个不带任何表意的字符变量，对于维护工作来说简直是场噩梦。把对变量的第一次声明混合到一个40行的代码块里同样也是一场噩梦。即使你自己遇到这样的变量时，你也要不由的问自己：&ldquo;这是在哪里定义的？&rdquo;，然后迅速的使用Ctrl+F组合在源代码里寻找这个变量最初定义的位置。不，不要这样，相反，这是对Javascript的滥用，是一种愚蠢的做法。你应该始终把变量定义在它的使用范围的顶部。并不能说因为这不是必须的，你就可以不这样做。</p>\r\n<blockquote>\r\n<p>function(){<br />\r\nvar a,//description<br />\r\nb; //description<br />\r\n//process&hellip;<br />\r\n}</p>\r\n</blockquote>\r\n<p><strong>3. 你没有理解Javascript的变量范围。</strong></p>\r\n<p>　　你是个天才的程序员，你吃的是C++、拉的是List。你知道什么是变量范围，你对你的变量有完全的控制，你就像太上皇似的的注视着它们。然而，Javascript却在你的咖啡里拉了一泡屎，并且大笑不止。</p>\r\n<blockquote>\r\n<p>var herp=&rdquo;one&rdquo;;<br />\r\n{<br />\r\nvar herp=&rdquo;two&rdquo;;<br />\r\n}<br />\r\nalert(herp);</p>\r\n</blockquote>\r\n<p>　　在这种情况下你得到的<tt>herp</tt>不是&ldquo;one&rdquo;，而是&ldquo;two&rdquo;。Javascript的变量有效范围并不是跟其它语言一样依赖于代码块。Javascript的变量范围是以<strong>函数</strong>为基础的。每个函数都有它自己的变量范围，Javascript这一点上表现的很酷，根本不理睬这毫无意义的花括弧包起来的范围。事实上，Javascript是如此的酷，以至于你甚至可以将变量范围像命名空间或变量那样进行传递。</p>\r\n<p><strong>4. 你以为Javascript的面向对象特征只是嫁接而来的。</strong></p>\r\n<p>　　Javascript，自从呱呱落地起，它就是一个面向对象的语言。所有的东西在Javascript里都是对象，所有的！甚至数字和字符这样的文字符号都可以通过它自身固有的构造器转化成对象。跟其它面向对象的语言比起来，Javascript的不同之处在于，它没有类(class)。Javascript对象像函数那样定义，甚至函数自己也是对象。Javascript有个属性叫做<strong>prototype</strong>，所有对象里都内置了这个属性，你可以通过它来改变对象的构造，修改对象、添加更多的变量、更多的功能。</p>\r\n<blockquote>\r\n<p>var derp; //will hold a Herp instance<br />\r\nvar Herp= function(){<br />\r\nthis.opinion=&rdquo;Javascript is cooler than BASIC.&rdquo;;<br />\r\n}<br />\r\nHerp.prototype.speak=function(){ alert(this.opinion); }<br />\r\nvar derp= new Herp();<br />\r\nderp.speak();</p>\r\n</blockquote>\r\n<p>　　如果这个看起来跟你毫不相干，我愿意介绍我的好朋友Google给你，Google擅长于帮助人们学习知识。面向对象对于我这篇简短的、低姿态的文章来说实在是个太大的话题。</p>\r\n<p><strong>5. 你使用&ldquo;new&rdquo;关键字时就像是盲人瞎马。</strong></p>\r\n<p>　　Javascript肯定是你的初恋女友，因为你显得无所适从。如果你想像真人那样取悦Javascript，你需要去了解对象符号。除了在需要实例化一个对象，或罕见的需要延时加载数据的情况外，你基本上不需要使用<strong>new</strong>关键字。在Javascript里分配大量的<strong>new</strong>变量地址是一项很慢的操作，为了效率起见，你应该始终使用对象符号。</p>\r\n<blockquote>\r\n<p>var rightway= [1, 2, 3];<br />\r\nvar wrongway= new Array(1, 2, 3);</p>\r\n</blockquote>\r\n<p>　　是否还记得我说过Javascript的变量范围是以函数为基础的？是否还记得有人说Javascript的对象像函数那样定义？如果你不使用<strong>new</strong>关键字来声明一个对象，你将会使这个对象成为全局范围内的对象。所以，永远使用<strong>new</strong>关键字来声明对象是一个好习惯。</p>\r\n<blockquote>\r\n<p>var derp=&rdquo;one&rdquo;;<br />\r\nvar Herp=function(){<br />\r\nthis.derp=&rdquo;two&rdquo;;<br />\r\n}<br />\r\nvar foo=Herp();<br />\r\nalert(derp);</p>\r\n</blockquote>\r\n<p>　　如果你这样写，Javascript并不会在意，而你真正弹出的答案是&ldquo;two&rdquo;！有很多方法可以防止对象做出这样的行为，可以以使用<strong>instanceOf</strong>，但更好的方法是正确的使用<strong>new</strong>关键字，这样显得更专业。</p>\r\n<p>　　现在你知道你的Javascript代码写的很烂了吧，如果你记住了上面所说的东西，你的代码就会有所改善。我喜欢用3个tab键来缩进代码，我喜欢用下划线来连接单词，我喜欢把函数名首字母大写来表示它是对象。当然，这个是另外一场讨论了。有很多原因会导致你的Javascript代码写的很烂，就像我有很多技术很烂一样，所以，尽情的在评论里表达你的意见，支持，反对，不吝赐教。</p>\r\n<p>　　非常感谢rogeliorv和 <a href="http://msujaws.wordpress.com/">Jared Wein</a>指出第五点中存在的错误。你们很强。</p>', 'JavaScript', '0', '2011-05-01 8:56:49'),
(510, '页面元素拖拽 -- HTML中的setCapture和releaseCapture', '<p>setCapture函数的作用就是将后续的mouse事件都发送给这个对象，releaseCapture就是将鼠标事件还回去，由 document、window、object之类的自行来处理，这样就保证了在拖动的过程中，不会由于经过了其它的元素而受到干扰。另外，还有一个很重要的事情是，在Win32上，mouse move的事件不是一个连续的，也就是说，并不是我们每次移动1px的鼠标指针，就会发生一个mousemove，windows会周期性检查mouse 的位置变化来产生mousemove的事件。所以，如果是一个很小的页面对象，比如一个直径5px的圆点，如果没有setCapture和 releaseCapture，那么在鼠标按住之后，快速的移动鼠标，就有可能鼠标移动走了，但是小圆点还在原地，就是因为下一次的mousemove事件已经不再发给这个圆点对象了。</p>', 'JavaScript', '0', '2011-04-30 15:20:59'),
(511, 'Javascript 面试题随笔之Function.call.call', '<a id="ctl02_TitleUrl" href="http://www.cnblogs.com/PrimerDotNet/archive/2011/04/14/2015548.html">Javascript 面试题随笔之Function.call.call</a>\r\n<p>今天无聊在群里面看到了一道面试题：</p>\r\n<pre title="code" class="brush: jscript;">\r\nfunction f1(){\r\n   alert(&quot;1&quot;);\r\n}\r\nfunction f2(){\r\n   alert(&quot;2&quot;);\r\n}\r\nvar f3=f1.call;\r\nf3.call(f2);\r\n</pre>\r\n<p>输出结果是2，后来想了一下，实在是让我大感JS的有趣，我的理解也不一定是正确的，只是想说出来，望有高手指正：我是这么理解：call函数是Function.prototype里面的函数，他在f1.call的情况下能调用f1，所以他的实现应该至少可以类似于</p>\r\n<p>&nbsp;</p>\r\n<pre title="code" class="brush: jscript;">\r\n Function.prototype.call = function(thispointer, arg1, arg2){\r\n	  thispointer = thispointer || window;\r\n	  thispointer.func = this;\r\n	  thispointer.func(arg1, arg2);\r\n	  delete thispointer.func;\r\n}\r\n</pre>\r\n<p>当f1.call.call(f2)被调用时，实际上的执行过程是：</p>\r\n<pre title="code" class="brush: jscript;">\r\nthispointer = f2;\r\nf2.func = f1.call;\r\nf2.func();\r\ndelete f2.func;\r\n</pre>\r\n<p>所以可以得到是f2.call()被调用了。就这样子。</p>', 'JavaScript', '0', '2011-04-30 15:20:22');
INSERT INTO `list` (`id`, `title`, `content`, `cat`, `marrow`, `time`) VALUES
(532, '如何编写高质量的Javascript代码', '<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;"><a target="_blank" href="http://my.oschina.net/caiyuan/blog/13836">http://my.oschina.net/caiyuan/blog/13836</a></p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">优秀的<a href="http://www.phpied.com/">Stoyan Stefanov</a>在他的新书中（《Javascript Patterns》）介绍了很多编写高质量代码的技巧，比如避免使用全局变量，使用单一的var关键字，循环式预存长度等等。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">这篇文章不仅仅从代码本身来考虑如何优化编码，也从代码的设计阶段来考虑，包括书写API文档，同事的review，使用JSLint。这些习惯都能帮助你编写更加高质量的、更易于理解的、可维护的代码（让你的代码在多年之后仍使你引以为傲）。</p>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">编写可维护的代码</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">软件的BUG修复需要花费大量的精力。尤其当代码已经发布之后，随着时间的增长，维护的成本愈发的高。当你一发现BUG的时候，就立即去修复，这时候你的代码还是热乎的，你也不需要回忆，因为就是刚刚写好的。但是当你做了其他任务，几乎完全忘记了这份代码，这时候就需要：</p>\r\n<ul>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">重新学习和理解问题</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">理解代码是如何解决问题的</li>\r\n</ul>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">另外一个问题是，在大项目或者大公司里面，经常是解决BUG的人不是产生BUG的人，而且也不是发现BUG的人。所以减少理解代码的时间就是最重要的问题，无论这个代码是你自己以前写的还是团队中的其他成员写的，因为我们都想去搞搞新的有意思的东西，而不是去维护那些个陈旧的代码。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">还有一个开发中的普遍问题就是，往往读代码的时间比写代码的时间还要多。有时候你钻研一个问题，可以花整整一个下午的时间来考虑代码的编写。这个代码当时是可以工作的，但是随着开发的进行，其他东西发生了很大的变化，这时候也就需要你自己来重新审查修改编写代码。比如：</p>\r\n<ul>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">还有BUG没有解决</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">添加了新的功能</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">程序需要在新的环境中运行（比如一个新上市的浏览器）</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">代码有问题</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">代码需要重写因为修改了架构甚至要使用另一个语言</li>\r\n</ul>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">因为这些原因，也许你当时一个下午写好的代码，后面需要花费几周的时间来阅读。所以编写可维护的代码对于软件的成功至关重要。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">可维护的代码包括：</p>\r\n<ul>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">可读性</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">连续性</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">预见性</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">看起来是一个人写的</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">有文档</li>\r\n</ul>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">最少化全局变量</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">Javascript使用函数来约定作用域。一个在函数内部声明的变量在外部是不可见的。所以，全局变量也就是声明在任何函数之外的或者没有被声明的变量。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">Javascript中，在任何函数之外有个可访问的全局对象，每一个你创建的全局变量都是这个对象的一个属性。在浏览器中，为了方便，通常用window来指代这个全局变量。下面的代码就是说明如何创建一个全局变量：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nmyglobal = &quot;hello&quot;; // antipattern\r\n\r\nconsole.log(myglobal); // &quot;hello&quot;\r\n\r\nconsole.log(window.myglobal); // &quot;hello&quot;\r\n\r\nconsole.log(window[&quot;myglobal&quot;]); // &quot;hello&quot;\r\n\r\nconsole.log(this.myglobal); // &quot;hello</pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">全局变量的问题</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">全局变量的问题在于，他在你的所有代码或者一个页面中都共享。他们在同一个命名空间下面，这通常会造成变量名冲突&ndash;两个同名的变量，但是确实不同的用处。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">通常在一些页面中需要引入一些其他人的代码，比如：</p>\r\n<ul>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">第三方的JS库</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">广告伙伴的脚本</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">第三方的用户行为分析或者统计脚本</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">不同的组件、按钮等等</li>\r\n</ul>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">加入其中一个第三方组件定义了一个全局变量：result。然后在你的程序中，也定义了一个全局变量result。最后的这个result会覆盖点之前的result，这样第三方的脚本就会停止工作。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">所以，为了对其他的脚本友好，在一个页面中使用越少的全局变量越好。在后面会有一些方法来告诉你如何减少全局变量，比如使用命名空间，或者自执行的匿名函数，但是最好的避免全局变量的方法就是使用var关键字来声明变量。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">因为javascript的两个特性，创建一个全局变量非常的简单。第一，你可以使用一个甚至没有声明的变量，第二，在javascript中，所有未声明的变量都会成为全局对象的一个属性（就像一个声明了的全局变量一样）。看看这个例子：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nfunction sum(x,y){\r\n\r\n     result = x + y;\r\n\r\n     return result;\r\n\r\n}</pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">在这个代码中，result在没有被声明的情况下就被使用了，这个代码也能很好的工作，但是在调用了这个函数之后，就会多一个名为result的全局变量，这是所有问题的根源了。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">解决这个问题的办法就是使用var：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nfunction sum(x,y){\r\n\r\n     var result  = x + y;\r\n\r\n     return result;\r\n\r\n}</pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">两外一个不好的习惯就是在声明变量的时候使用链式的方法来赋值，这时候，a是局部变量，但是b就成为了全局变量。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nfunction foo(){\r\n\r\n     var a=b=0;\r\n\r\n     ....\r\n\r\n}</pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">这是因为，b = 0这个表达式先执行，执行的时候b并没有被声明，所以b就成为了全局变量，然后返回这个表达式的值0，给声明了的变量a，换句话说，就好像你输入的是：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nvar a = (b=0);</pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">如果你已经声明变量，那么这种链式的赋值没有问题：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nfunction foo(){\r\n\r\n     var a,b;\r\n\r\n     ...\r\n\r\n}</pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">另外一个避免使用全局变量的原因是考虑到程序的可移植性。如果你想让你的代码在不同的环境中都可以工作，那么使用全局变量就很可能会与新的系统中的全局变量冲突（或许在之前的系统中没有问题）。</p>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">忘记var的影响</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">使用var声明的全局变量和没有使用var生成的全局变量还有一个区别在于删除：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">使用var声明创建的全局变量不能被删除</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">没有使用var声明的全局变量可以被删除</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">这说明没有使用var声明生成的全局变量不是真正的变量，他们只是全局对象的属性。属性可以通过delete删除，但是变量不行：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\n// define three globals\r\n\r\nvar global_var = 1;\r\n\r\nglobal_novar = 2; // antipattern\r\n\r\n(function () {\r\n\r\n   global_fromfunc = 3; // antipattern\r\n\r\n}()); \r\n\r\n \r\n\r\n// attempt to delete\r\n\r\ndelete global_var; // false\r\n\r\ndelete global_novar; // true\r\n\r\ndelete global_fromfunc; // true \r\n\r\n \r\n\r\n// test the deletion\r\n\r\ntypeof global_var; // &quot;number&quot;\r\n\r\ntypeof global_novar; // &quot;undefined&quot;\r\n\r\ntypeof global_fromfunc; // &quot;undefined&quot;</pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">在ES5的严格模式下，给一个为声明的变量赋值会报错。</p>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">读取全局对象</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">在浏览器中，你可以通过window变量来读取全局对象（除非你在函数内部重新定义了window对象）。但在有的环境中，可能不叫window，那么你可以使用下面的代码来获取全局对象：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nvar global = (function(){\r\n\r\n     return this;\r\n\r\n})();</pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">这样可以获取到全局对象的原因是在function的内部，this指向全局对象。但是这在ES5的严格模式下会不起作用，你需要适配一些其他模式。当你开发自己的库的时候，你可以把你的代码封装在一个立即函数中，然后将this作为一个参数传进来。</p>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">单个var模式</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">在你的代码的顶部只是用一个var关键字，会有以下的好处：</p>\r\n<ul>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">对于所有需要的变量，在一个地方就可以全部看到</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">避免使用一个未定义的变量</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">帮助你记忆声明的变量，减少全局变量</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">更精简的代码</li>\r\n</ul>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">书写很简单：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nfunction func() {\r\n\r\n   var a = 1,\r\n\r\n       b = 2,\r\n\r\n       sum = a + b,\r\n\r\n       myobject = {},\r\n\r\n       i,\r\n\r\n       j;\r\n\r\n   // function body...\r\n\r\n}</pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">通过一个var和逗号来声明多个变量。在声明的时候给变量赋默认值也是不错的做法，可以避免一些逻辑错误，提高代码的可读性。而后你阅读的代码的时候也可以根据变量的默认值来方便的猜测变量的用途。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">你也可以在声明变量的时候做一些实际的工作，比如sum = a + b;另外，在操作DOM元素的时候，你也可以把DOM元素的引用保存在一个变量中：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nfunction updateElement() {\r\n\r\n   var el = document.getElementById(&quot;result&quot;),\r\n\r\n       style = el.style;\r\n\r\n   // do something with el and style...\r\n\r\n}</pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">滥用了的var</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">JavaScript允许你在函数内部有多个var语句，但是却都表现的如同在函数的顶部声明一样。这个特性在你使用一个变量然后在后面又声明了这个变量时会导致一些奇怪的逻辑问题。对于JavaScript来说，只要变量在同一个作用域，那么就认为是声明了的，就算是在var语句之前使用也一样。看看这个例子：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nmyname = &quot;global&quot;; // global variable\r\n\r\nfunction func() {\r\n\r\n    alert(myname); // &quot;undefined&quot;\r\n\r\n    var myname = &quot;local&quot;;\r\n\r\n    alert(myname); // &quot;local&quot;\r\n\r\n}\r\n\r\nfunc();</pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">在这个例子中，或许你期望第一次会弹出global，第二次弹出local。因为第一次的时候没有还没有使用var声明myname，这是应该是全局变量的myname，第二次声明了，然后alert之后应该是local的值。而事实上不是这样的，只要你在函数中出现了var myname，那么js就认为你在这个函数中声明了这个变量，但是在读取这个变量的值的时候，因为var语句还没有执行，所以是undefined，很奇怪的逻辑吧。上面的代码相当于：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nmyname = &quot;global&quot;; // global variable\r\n\r\nfunction func() {\r\n\r\n   var myname; // same as -&gt; var myname = undefined;\r\n\r\n   alert(myname); // &quot;undefined&quot;\r\n\r\n   myname = &quot;local&quot;;\r\n\r\n   alert(myname); // &quot;local&quot;\r\n\r\n}\r\n\r\nfunc();</pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">我们来解释一下这个现象，在代码的解析中，分两个步骤，第一步先处理变量函数的声明，这一步处理整个代码的上下文。第二步就是代码的运行时，创建函数表达式以及未定义的变量。实际上，我们只是假设了这个概念，这并不在ECMAScript的规范中，但是这个行为常常就是这样解释的。</p>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">for循环</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">在for循环中你会去迭代一些数组元素或者一些HTML元素。for循环常常如此：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nfor (var i = 0; i &lt; myarray.length; i++) {\r\n\r\n   // do something with myarray[i]\r\n\r\n}</pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">这样写的问题在于，每一次迭代的时候都会计算数组的长度，尤其在这个参数不是一个数组而是一组HTML元素的时候会降低你的程序的性能。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">HTML元素的集合在页面上，这样每次都会去再页面上查找相应的元素，这是非常耗时的。所以对于for循环，你需要预先保存数组的长度，这样写：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nfor (var i = 0, max = myarray.length; i &lt; max; i++) {\r\n\r\n   // do something with myarray[i]\r\n\r\n}</pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">这样缓存了参数的长度，在每次迭代的时候就不用再去查找计算了。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">在查找HTML元素集合的时候，缓存参数长度可以带来可观的性能提升，Safari下面提高两倍的速度，在IE7下面提高190倍的速度。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">需要注意的是，当你需要操作修改DOM元素的数量的时候，你肯定希望这个值是随时更新的而不是一个常量。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">使用下面的单一var模式，你也可以把var提到循环之外：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nfunction looper() {\r\n\r\n   var i = 0,\r\n\r\n        max,\r\n\r\n        myarray = [];\r\n\r\n   // ...\r\n\r\n   for (i = 0, max = myarray.length; i &lt; max; i++) {\r\n\r\n      // do something with myarray[i]\r\n\r\n   }\r\n\r\n}</pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">这个模式可以增强整个代码的连续性，但是不好的一点是当你重构代码的时候复制粘贴就没那么容易了。例如：如果你想在其他函数中也使用这个循环，那你需要确定在新的函数中处理好了i和max（或许还需要删掉这个）。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">这个函数还有两个点可以优化的：</p>\r\n<ul>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">可以少一个变量（不需要max）</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">递减到0，一个数字与0比较比这个数字与另外一个数字比较更快</li>\r\n</ul>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">所以就可以写为：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nvar i, myarray = [];\r\n\r\nfor (i = myarray.length; i--;) {\r\n\r\n   // do something with myarray[i]\r\n\r\n}</pre>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">针对第二点：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nvar myarray = [],\r\n\r\n    i = myarray.length;\r\n\r\nwhile (i--) {\r\n\r\n   // do something with myarray[i]\r\n\r\n}</pre>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">这是两个比较微小的点的优化。另外，JSLint可能对于i&ndash;会有意见。</p>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">for-in循环</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">for-in循环用来迭代非数组的对象。使用for-in循环通常也成为枚举。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">从技术上来说，你也可以用for-in来循环数组，因为数组也是对象，但是不推荐。如果数组有一些自定义的扩展函数，那么就会出错。另外，对象属性的顺序在for-in循环中也是不确定的。所以最好还是用普通的循环来循环数组用for-in来循环对象。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">在循环对象的过程中，使用hasOwnProperty()方法来检验是对象本身的属性还是原型链上的属性很重要。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">看看下面的这个例子。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\n// the object\r\n\r\nvar man = {\r\n\r\n   hands: 2,\r\n\r\n   legs: 2,\r\n\r\n   heads: 1\r\n\r\n}; \r\n\r\n \r\n\r\n// somewhere else in the code\r\n\r\n// a method was added to all objects\r\n\r\nif (typeof Object.prototype.clone === &quot;undefined&quot;) {\r\n\r\n   Object.prototype.clone = function () {};\r\n\r\n}</pre>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">在这个例子中，我们有一个简单的称作man的对象字面量。在其他man定义之前或之后的地方，对象原型有一个很有用的clone()方法。因为原型链的原因，所有的对象都自动获得了这个方法。为了在枚举man对象的时候出现clone方法，你需要使用hasOwnProperty方法来区别。如果没有区别来自原型链的方法，那么就会有一些意想不到的事情发生：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\n// 1.\r\n\r\n// for-in loop\r\n\r\nfor (var i in man) {\r\n\r\n   if (man.hasOwnProperty(i)) { // filter\r\n\r\n      console.log(i, &quot;:&quot;, man[i]);\r\n\r\n   }\r\n\r\n}\r\n\r\n/* result in the console\r\n\r\nhands : 2\r\n\r\nlegs : 2\r\n\r\nheads : 1\r\n\r\n*/\r\n\r\n// 2.\r\n\r\n// antipattern:\r\n\r\n// for-in loop without checking hasOwnProperty()\r\n\r\nfor (var i in man) {\r\n\r\n   console.log(i, &quot;:&quot;, man[i]);\r\n\r\n}\r\n\r\n/*\r\n\r\nresult in the console\r\n\r\nhands : 2\r\n\r\nlegs : 2\r\n\r\nheads : 1\r\n\r\nclone: function()\r\n\r\n*/</pre>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">另外一种使用方法如下：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nfor (var i in man) {\r\n\r\n   if (Object.prototype.hasOwnProperty.call(man, i)) { // filter\r\n\r\n      console.log(i, &quot;:&quot;, man[i]);\r\n\r\n   }\r\n\r\n}</pre>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">这样写的好处是可以防止man重新定义了hasOwnProperty方法导致的冲突。如果不想写这么长的一串，你也可以这样：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nvar i, hasOwn = Object.prototype.hasOwnProperty;\r\n\r\nfor (i in man) {\r\n\r\n    if (hasOwn.call(man, i)) { // filter\r\n\r\n        console.log(i, &quot;:&quot;, man[i]);\r\n\r\n    }\r\n\r\n}</pre>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">严格意义上讲，不适用hasOwnProperty也不是什么错误。根据任务的难度和你对代码的自信程度，你也可以不用这个直接循环。但是当你不确定的时候，最好还是使用这个方法检测一下。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">另外一种格式上的改变（不会通过jsLint的检查），去掉for的大括号，然后把if放在同一行。这样做的好处可以让循环体更加突出，缩进也就少一些：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\n// Warning: doesn''t pass JSLint\r\n\r\nvar i, hasOwn = Object.prototype.hasOwnProperty;\r\n\r\nfor (i in man) if (hasOwn.call(man, i)) { // filter\r\n\r\n    console.log(i, &quot;:&quot;, man[i]);\r\n\r\n}</pre>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">不要扩展内建的原型</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">扩展原型的构造函数，可以提供一些很强大的功能，但是有时候他太强大了。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">有时候你会去扩展Object(),Array(),Fucntion()的原型方法，这样会导致可维护性的问题，因为这会让你的代码的移植性变差。其他的开发人员使用你的代码的时候，可能只需要原生的方法，并不需要额外的功能。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">另外，你添加进去的方法，如果在循环的时候没有使用hasOwnProperty方法就会被遍历出来，这会让人很迷惑。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">所以，最好还是不要扩展基本的对象。除非是下面的情况：</p>\r\n<ul>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">你确定在将来根据ECMAScript规范，浏览器会添加相应的原型方法，那么是可以的，你只不过是提前实现了这个功能。</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">你确定的你要实现的方法不存在&ndash;或许有时候在代码的其他的地方实现了，或者有的浏览器支持，这都是不行的。</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">有非常清晰的文档，并且与团队成员沟通过</li>\r\n</ul>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">如果在这些情况之下，那么你就可以添加，最好是下面这种形式：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nif (typeof Object.protoype.myMethod !== &quot;function&quot;) {\r\n\r\n   Object.protoype.myMethod = function () {\r\n\r\n      // implementation...\r\n\r\n   };\r\n\r\n}</pre>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">switch模式</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">按照下面的风格写switch的话，可以提高你的代码可读性和健壮性：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nvar inspect_me = 0,\r\n\r\n    result = '''';\r\n\r\nswitch (inspect_me) {\r\n\r\ncase 0:\r\n\r\n   result = &quot;zero&quot;;\r\n\r\n   break;\r\n\r\ncase 1:\r\n\r\n   result = &quot;one&quot;;\r\n\r\n   break;\r\n\r\ndefault:\r\n\r\n   result = &quot;unknown&quot;;\r\n\r\n}</pre>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">需要注意下面几个方面：</p>\r\n<ul>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">将case和switch对齐。</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">case的内容缩进</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">每一个case之后都有一个清晰的break</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">避免顺序往下执行case，非要如此的话，文档一定要写清楚</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">最后使用default，保证在没有命中case的情况下也有反馈</li>\r\n</ul>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">避免隐藏的类型转换</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">Javascript在你比较两个变量的时候会进行类型的转换，这就是为什么 false == 0或者&rdquo;&quot; == 0会返回true。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">为了避免这种隐藏的类型转换带来的迷惑，最好使用===或者!==操作符来比较：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nvar zero = 0;\r\n\r\nif (zero === false) {\r\n\r\n   // not executing because zero is 0, not false\r\n\r\n} \r\n\r\n \r\n\r\n// antipattern\r\n\r\nif (zero == false) {\r\n\r\n   // this block is executed...\r\n\r\n}</pre>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">还有另外一种流派持这样的观点：当==够用时使用===就是多余的。比如，当你使用typeof的时候你知道会返回string，所以没必要使用严格的检验。然而，JSLint要求严格检验；他最大程度使代码在阅读的时候减少歧义，(&ldquo;这个==是故意呢还是疏漏？&rdquo;)。</p>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">避免使用eval()</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">如果你在你的代码中使用eval()，那么要记住&rdquo;eval() is evil&rdquo;。这个方法会将传入的字符串当做js代码来执行。如果代码是在运行前就确定的，那么没有必要使用eval()。如果代码是在运行时动态确定的，那么也有其他更安全的办法。例如使用方括号形式访问元素的属性：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\n// antipattern\r\n\r\nvar property = &quot;name&quot;;\r\n\r\nalert(eval(&quot;obj.&quot; + property));  \r\n\r\n \r\n\r\n// preferred\r\n\r\nvar property = &quot;name&quot;;\r\n\r\nalert(obj[property]);</pre>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">使用eval()还有安全问题，比如你运行网络上的一段代码，而这段代码又被别人篡改了。在处理Ajax请求返回的JSON数据的时候，最好还是使用浏览器内建的处理方法，如果对于低端的浏览器不支持的，可以从JSON.org上下载对应的处理库。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">另外还要记住使用setTimeout、setInterval以及Function的构造函数的是，传入的字符串的参数，js的处理方法跟eval()类似，所以也要注意。因为，js会把你传入的字符串解析执行：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\n// antipatterns\r\n\r\nsetTimeout(&quot;myFunc()&quot;, 1000);\r\n\r\nsetTimeout(&quot;myFunc(1, 2, 3)&quot;, 1000);  \r\n\r\n \r\n\r\n// preferred\r\n\r\nsetTimeout(myFunc, 1000);\r\n\r\nsetTimeout(function () {\r\n\r\n   myFunc(1, 2, 3);\r\n\r\n}, 1000);</pre>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">使用Function的构造函数，跟eval()差不多，也要注意。这是个非常有用的功能，但是常常被错用。如果你必须使用eval()，那么可以考虑new一个Function来替代。另外的一个好处就是，使用Function的构造函数，函数的作用域在本方法内，这样你使用var声明的变量就不会变成全局的。另外一个防止eval()生成全局变量的办法就是使用匿名函数。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">看看下面这个例子，只有un变量最终是全局的：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nconsole.log(typeof un); // &quot;undefined&quot;\r\n\r\nconsole.log(typeof deux); // &quot;undefined&quot;\r\n\r\nconsole.log(typeof trois); // &quot;undefined&quot;  \r\n\r\n \r\n\r\nvar jsstring = &quot;var un = 1; console.log(un);&quot;;\r\n\r\neval(jsstring); // logs &quot;1&quot;  \r\n\r\n \r\n\r\njsstring = &quot;var deux = 2; console.log(deux);&quot;;\r\n\r\nnew Function(jsstring)(); // logs &quot;2&quot;  \r\n\r\n \r\n\r\n jsstring = &quot;var trois = 3; console.log(trois);&quot;;\r\n\r\n (function () {\r\n\r\n    eval(jsstring);\r\n\r\n }()); // logs &quot;3&quot;  \r\n\r\n \r\n\r\n console.log(typeof un); // number\r\n\r\n console.log(typeof deux); // undefined\r\n\r\n console.log(typeof trois); // undefined</pre>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">eval()和Function构造函数的另一个区别就是eval()会影响到作用域，而Function则相当于一个沙盒。例如：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\n(function () {\r\n\r\n   var local = 1;\r\n\r\n   eval(&quot;local = 3; console.log(local)&quot;); // logs 3\r\n\r\n   console.log(local); // logs 3\r\n\r\n}());  \r\n\r\n \r\n\r\n(function () {\r\n\r\n   var local = 1;\r\n\r\n   Function(&quot;console.log(typeof local);&quot;)(); // logs undefined\r\n\r\n }());</pre>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">使用parseInt()转换处理数字</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">使用parseInt()你可以将字符串转为数字。这个方法支持第二个表示进制的参数，常常被忽略。问题常常在处理一段以0开始的字符串的时候。在ECMAS3标准中，以0开始表示八进制，但是在ES5中又改了，所以为了避免麻烦，最好还是标明第二个参数。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nvar month = &quot;06&quot;,\r\n\r\n    year = &quot;09&quot;;\r\n\r\nmonth = parseInt(month, 10);\r\n\r\nyear = parseInt(year, 10);</pre>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">在这个例子中，如果你使用parseInt(year)，就会返回0，因为09被认为是8进制数字，然而9是非法的八进制字符，所以返回0。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">其他的可以把字符串转为数字的方法有：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\n +&quot;08&quot; // result is 8\r\n\r\nNumber(&quot;08&quot;) // 8</pre>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">这些通常都比parseInt()快一些，因为parseInt并不只是简单的转换。但是如果你的输入是&rdquo;08 hello&rdquo;这样的，那么parseInt()也会返回8，但是其他的方法就只能返回NaN。</p>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">编码规范</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">编码的时候遵循一定的规范，可以让你的代码增强可移植性，并且更加便于阅读和理解。加入团队的新人，在阅读了代码规范之后，可以更加快速的溶入团队，并理解其他人员开发的代码。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">在一些讨论会议上，规范往往都是争论的焦点（比如缩进的形式）。所以如果你打算为你团队的编码规范提一些建议，那就准备好一场激烈的辩论和反对意见。要记住，建立和实施规范是非常重要的。</p>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">缩进</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">代码如果没有缩进，那基本上没法阅读了。比这更糟的是不规范的缩进，看着好像缩进了，但是乱七八糟摸不着头脑。所以缩进的使用必须规范。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">有些开发人员喜欢使用tab键来缩进，因为在每一个编辑器里面都可以自己设置想要的tab值。有的人喜欢四个空格。如果团队遵循统一的规范，这也不是什么问题。比如本文就是四个空格，这也是JSLint推荐的。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">那么什么该缩进呢？很简单，大括号。这样就是说包括函数体，循环，ifs，switch，以及对象字面量的属性。看看这个例子：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nfunction outer(a, b) {\r\n\r\n    var c = 1,\r\n\r\n        d = 2,\r\n\r\n        inner;\r\n\r\n    if (a &gt; b) {\r\n\r\n        inner = function () {\r\n\r\n            return {\r\n\r\n                r: c - d\r\n\r\n            };\r\n\r\n         };\r\n\r\n     } else {\r\n\r\n         inner = function () {\r\n\r\n             return {\r\n\r\n                 r: c + d\r\n\r\n             };\r\n\r\n         };\r\n\r\n     }\r\n\r\n     return inner;\r\n\r\n }</pre>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">大括号</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">应该使用大括号，尤其在那些可用可不用的地方，如果你的if语句或者for循环只有一句话，那么大括号不是必须的，但是这种时候最好用大括号。这可以让代码保持一致，并且便于升级。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">假设你的for循环只有一句。你可以不用大括号，也不会有什么错误。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\n// bad practice\r\n\r\nfor (var i = 0; i &lt; 10; i += 1)\r\n\r\n   alert(i);</pre>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">但是假如你以后要在这个循环里面添加其他东西呢？</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\n // bad practice\r\n\r\n for (var i = 0; i &lt; 10; i += 1)\r\n\r\n    alert(i);\r\n\r\n    alert(i + &quot; is &quot; + (i % 2 ? &quot;odd&quot; : &quot;even&quot;));</pre>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">这时候，虽然第二个alert有缩进，但他还是在循环之外的。所以，无论何时，都应该是用大括号。if语句一样：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\n// bad\r\n\r\nif (true)\r\n\r\n   alert(1);\r\n\r\nelse\r\n\r\n   alert(2);  \r\n\r\n \r\n\r\n// better\r\n\r\nif (true) {\r\n\r\n   alert(1);\r\n\r\n } else {\r\n\r\n    alert(2);\r\n\r\n }</pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">大括号位置</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">开发人员也经常争论大括号的位置，放在同一行还是下一行呢？</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">在具体的例子中，这是个见仁见智的问题。但也有例外，假如程序根据不同的位置做不同的解析呢？这是因为插入分号机制，js对此并不挑剔，他会在你没有添加分号的行之后帮你添加。这在函数返回一个对象字面量然后大括号写在下一行的时候出问题：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\n// warning: unexpected return value\r\n\r\nfunction func() {\r\n\r\n   return\r\n\r\n  // 下面的读取不到\r\n\r\n   {\r\n\r\n      name : &quot;Batman&quot;\r\n\r\n   }\r\n\r\n}</pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">如果你想让这个函数返回一个有name属性的对象字面量，这个函数是做不到的，因为插入的分号，返回的应该是一个undefied值。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">所以，最后的结论是，必须使用大括号，并且写在同一行。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nfunction func() {\r\n\r\n   return {\r\n\r\n      name : &quot;Batman&quot;\r\n\r\n   };\r\n\r\n}</pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">关于分号：跟大括号一样，必须写。这不只是推行严格的写程序的规范，更是在必要的时候解决一些不清楚的地方，比如前面的例子。</p>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">空格</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">正确的使用空格也可以增加程序的可读性和连贯性。写句子的时候你会在逗号和句号之后有一些停顿。在js中可以模仿这样的逻辑。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">应该使用空格地方有：</p>\r\n<ul>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">循环中的分号之后</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">循环中的变量初始化for (var i = 0, max = 10; i &lt; max; i += 1) {&hellip;}</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">数组中的逗号分隔符之后var a = [1, 2, 3];</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">对象字面量中的逗号var o = {a: 1, b: 2}</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">函数参数间myFunc(a, b, c)</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">在函数声明时候的大括号前面function myFunc() {}</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">匿名函数var myFunc = function () {};</li>\r\n</ul>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">另外一些使用空格比较好的地方就是在那些操作符的两边，比如+, -, *, =, &lt;, &gt;, &lt;=, &gt;=, ===, !==, &amp;&amp;, ||, +=,等等。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\n// generous and consistent spacing\r\n\r\n// makes the code easier to read\r\n\r\n// allowing it to &quot;breathe&quot;\r\n\r\nvar d = 0,\r\n\r\n    a = b + 1;\r\n\r\nif (a &amp;&amp; b &amp;&amp; c) {\r\n\r\n    d = a % c;\r\n\r\n    a += d;\r\n\r\n}  \r\n\r\n \r\n\r\n // antipattern\r\n\r\n // missing or inconsistent spaces\r\n\r\n // make the code confusing\r\n\r\n var d = 0,\r\n\r\n     a = b + 1;\r\n\r\n if (a &amp;&amp; b &amp;&amp; c) {\r\n\r\n     d = a % c;\r\n\r\n     a += d;\r\n\r\n }</pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">最后一个关于空格要注意的，大括号前面的空格。最好使用空格：</p>\r\n<ul>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">在函数定义，id-else，case，循环以及对象字面量的大括号前面使用空格</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">在大括号}与else、while之间使用空格</li>\r\n</ul>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">反对增加空格的一个说法是增加文件体积，但是在压缩之后并不存在这个问题。提高代码可读性经常被忽视的一个方面就是垂直的空格，你可以使用空行来分开代码，就好像写文章时候的段落一样。</p>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">命名规范</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">可以提高代码移植性和可维护性的一个方面是命名规范。也就是说，在取变量名的时候总是采取一贯的做法。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">无论采用什么样的命名规范，其实都不是很重要，重要的是确定下来这个规范，然后遵守它。</p>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">构造函数首字母大写</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">javascript中没有类，但是可以使用new来达到同样的目的。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">因为构造函数也是函数，如果能从名字上就能区别它是构造函数还是普通函数，对于开发者是非常有用的。所以将构造函数的首字母大写，普通函数的首字母小写作为提示。这样一眼就能区别。</p>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">单词的分隔</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">当你的变量名或者函数名是由好几个单词构成的时候，如果能顺利区分变量名由那几个单词构成，也是非常不错的体验。这种命名规范成为驼峰式。所谓驼峰式就是以小写字母开始，后面的每个单词第一个字母大写。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">对于构造函数第一个字母大写，MyConstructor()，对于普通的函数，就采用驼峰式myFunction(), calculateArea()。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">那么变量怎么办呢，有的人使用驼峰式，但是更好的办法是使用下划线来区分。first_name,favorite_bands, 以及 old_company_name。这也可以让你一眼就能区分函数和变量。</p>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">其他命名规范</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">有时候，开发人员也会使用命名规范来替代和弥补一些语言的特性。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">例如，在javascript中，并没有提供定义常量的办法（虽然有Number.MAX_VALUE），所以开发人员使用全大写的名称来表示不可更改的常量。var PI = 3.14, MAX_WIDTH = 800。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">另外一种规范是使用全局变量名的首字母。这样做可以强化开发者使全局变量最少，并且容易辨认。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">另外一种规范是在函数中模拟私有成员。虽然可以在javascript中实现私有变量，但是开发人员为了更加容易区别，所以给他加一个下划线的前缀。例如：</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">&nbsp;</p>\r\n<pre class="JavaScript">\r\nvar person = {\r\n\r\n    getName: function () {\r\n\r\n        return this._getFirst() + '' '' + this._getLast();\r\n\r\n    },  \r\n\r\n \r\n\r\n    _getFirst: function () {\r\n\r\n        // ...\r\n\r\n    },\r\n\r\n    _getLast: function () {\r\n\r\n         // ...\r\n\r\n     }\r\n\r\n };</pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">在这个例子中，getName是一个公有函数，是API的一部分，_getFirst，_getLast本意是私有的。虽然仍然是公有函数，但hi加上了这个前缀，表示在以后的版本中不保证能运行，所以不应该被直接使用。注意在JSLint中不推荐这样做，除非你设置nomen选项为false。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">还有其他几种表示私有成员的规范：</p>\r\n<ul>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">在末尾使用下划线，比如name_以及getElements_</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">使用一个下划线表示保护成员_protected，两个下划线表示私有成员__private</li>\r\n    <li style="line-height: 18px; padding: 0px; margin: 0px;">在firefox中，有些不是语言原生的变量，以两个下划线开始，两个下划线结束__proto__以及__parent__</li>\r\n</ul>\r\n<h3 style="margin: 0px 0px 18px; font-family: Georgia,''Times New Roman'',Times,serif; font-weight: bold; font-size: 16px; line-height: 24px; color: rgb(85, 85, 85); padding: 0px;">写注释</h3>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">必须给你的代码写注释，就算它看起来不会被别人接手。有时候，你研究完一个问题，然后你看着代码觉得那是显而易见的，但是过一两周之后回头再看，你也会摸不着头脑的。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">当然，也不能过分的注释：每个变量每一行代码都注释。但是通常都需要对函数的功能，参数，返回值写文档，以及一些其他的复杂的逻辑和算法。想想，你的代码的阅读者，只需要读注释就能大体上了解你的代码在做什么需要什么，这比直接读代码理解要快的多。当你有五六行的代码是做一个具体的任务，那么阅读者就可以通过一行代码了解你的目的，然后跳过这些代码。关于注释，没有硬性的比例说是多少代码需要多少注释。有时候，有些代码（比如正则表达式）注释的内容肯定比代码本身多。</p>\r\n<p style="margin: 0px 0px 18px; line-height: 20px; padding: 0px;">写注释是必须遵守的规范，而且要保持注释的更新，一个过时的注释带给人的迷惑还不如不写注释。（<a href="http://net.tutsplus.com/tutorials/javascript-ajax/the-essentials-of-writing-high-quality-javascript/">译文</a>）</p>', '性能', '1', '2011-05-01 11:24:20');
INSERT INTO `list` (`id`, `title`, `content`, `cat`, `marrow`, `time`) VALUES
(569, '如何在事件代理中正确使用 focus 和 blur 事件', '<p><a target="_blank" href="http://www.planabc.net/2010/01/30/how_to_use_focus_and_blur_event_in_event_delegation/">http://www.planabc.net/2010/01/30/how_to_use_focus_and_blur_event_in_event_delegation/ </a></p>\r\n<p>什么是事件代理（Event Delegation）？</p>\r\n<p>如果不太了解的朋友，可详细阅读：<a target="_blank" title="Event delegation in JavaScript" href="http://www.nczonline.net/blog/2009/06/30/event-delegation-in-javascript/">《Event delegation in JavaScript》</a>，这里不再累述。</p>\r\n<p>首先让我们一起来回顾一些常识：</p>\r\n<ol>\r\n    <li>通常支持事件冒泡（Event Bubbling）的事件类型为鼠标事件和键盘事件，例如：<strong>mouseover, mouseout, click, keydown, keypress</strong>。</li>\r\n    <li>接口事件则通常不支持事件冒泡（Event Bubbling），例如：<strong>load, change, submit, focus, blur</strong>。</li>\r\n</ol>\r\n<p>很明显：focus 和 blur 都属于不支持冒泡的接口事件。既然都不支持冒泡，那又如何实现事件代理呢？</p>\r\n<p>可以换个角度，逆向思维，尝试事件捕获（Event Capturing，除了IE，现在流行的标准浏览器均支持）。</p>\r\n<p>测试后会发现，如果你捕获 focus 或 blur 事件，目标元素的祖先元素均执行事件函数。至于为什么？或许是实现的一个 BUG。</p>\r\n<pre><code>el.addEventListener(''focus'', focusHandler, true); el.addEventListener(''blur'', blurHandler, true);</code></pre>\r\n<p>那对于 IE ，我们如何实现呢？</p>\r\n<p>非常幸运，IE 下支持 focusin 和 focusout 事件，非常类似于 focus 和 blur 事件，唯一不同的是，这两种事件支持事件冒泡（Event Bubbling）。</p>\r\n<pre><code>el.onfocusin = focusHandler; el.onfocusout = blurHandler;</code></pre>\r\n<p>很完美的解决方案：</p>\r\n<pre><code>if (document.addEventListener) {     el.addEventListener(''focus'', focusHandler, true);     el.addEventListener(''blur'', blurHandler, true); } else {     el.onfocusin = focusHandler;     el.onfocusout = blurHandler; }</code></pre>\r\n<p>当你下次看到 <a title="YUI 2.8" target="_blank" href="http://developer.yahoo.com/yui/2/">YUI 2.8</a> 的 event/event-debug.js 源码中下面几段代码时，一定会清晰很多：</p>\r\n<pre><code>576    // String constants used by the addFocusListener and removeFocusListener methods 577 578     FOCUSIN = &quot;focusin&quot;, 579     FOCUSOUT = &quot;focusout&quot;;           ....   750     _specialTypes: { 751         focusin: (isIE ? &quot;focusin&quot; : &quot;focus&quot;), 752         focusout: (isIE ? &quot;focusout&quot; : &quot;blur&quot;) 753      },           ....   1053    addListener: function (el, sType, fn, obj, overrideContext) { 1054 1055	    var capture = ((sType == FOCUSIN || sType == FOCUSOUT) &amp;&amp; !YAHOO.env.ua.ie) ? true : false; 1056 1057        return this._addListener(el, this._getType(sType), fn, obj, overrideContext, capture); 1058 1059    },</code></pre>', 'JavaScript', '', '2011-05-03 20:36:19'),
(570, '全面理解JavaScript中的caller，callee，call，apply', '<p>在提到上述的概念之前，首先想说说<strong>javascript</strong>中函数的隐含参数：arguments<br />\r\n\r\n<br />\r\n\r\nArguments<br />\r\n\r\n<br />\r\n\r\n该对象代表正在执行的函数和调用它的函数的参数。<br />\r\n\r\n<br />\r\n\r\n[function.]arguments[n]<br />\r\n\r\n参数function ：选项。当前正在执行的 Function 对象的名字。 n ：选项。要传递给 Function 对象的从0开始的参数值索引。 <br />\r\n\r\n说明<br />\r\n\r\n<br />\r\n\r\nArguments是进行函数调用时，除了指定的参数外，还另外创建的一个隐藏对象。Arguments是一个类似数组但不是数组的对象，说它类似数组是\r\n\r\n因为其具有数组一样的访问性质及方式，可以由arguments[n]来访问对应的单个参数的值，并拥有数组长度属性length。还有就是\r\n\r\narguments对象存储的是实际传递给函数的参数，而不局限于函数声明所定义的参数列表，而且不能显式创建 arguments\r\n\r\n对象。arguments 对象只有函数开始时才可用。下边例子详细说明了这些性质:<br />\r\n\r\n<br />\r\n\r\n<br />\r\n\r\n//arguments 对象的用法。<br />\r\n\r\nfunction ArgTest(a, b){<br />\r\n\r\n   var i, s = "The ArgTest function expected ";<br />\r\n\r\n   var numargs = arguments.length;     // 获取被传递参数的数值。<br />\r\n\r\n   var expargs = ArgTest.length;       // 获取期望参数的数值。<br />\r\n\r\n   if (expargs &lt; 2)<br />\r\n\r\n      s += expargs + " argument. ";<br />\r\n\r\n   else<br />\r\n\r\n      s += expargs + " arguments. ";<br />\r\n\r\n   if (numargs &lt; 2)<br />\r\n\r\n      s += numargs + " was passed.";<br />\r\n\r\n   else<br />\r\n\r\n      s += numargs + " were passed.";<br />\r\n\r\n   s += "\\n\\n"<br />\r\n\r\n   for (i =0 ; i &lt; numargs; i++){      // 获取参数内容。<br />\r\n\r\n   s += "  Arg " + i + " = " + arguments[i] + "\\n";<br />\r\n\r\n   }<br />\r\n\r\n   return(s);                          // 返回参数列表。<br />\r\n\r\n}<br />\r\n\r\n<br />\r\n\r\n在此添加了一个说明arguments不是数组(Array类)的代码:<br />\r\n\r\n<br />\r\n\r\n<br />\r\n\r\nArray.prototype.selfvalue = 1;<br />\r\n\r\nalert(new Array().selfvalue);<br />\r\n\r\nfunction testAguments(){<br />\r\n\r\n    alert(arguments.selfvalue);<br />\r\n\r\n}<br />\r\n\r\n<br />\r\n\r\n运行代码你会发现第一个alert显示1，这表示数组对象拥有selfvalue属性，值为1，而当你调用函数testAguments时，你会发现显示的是&ldquo;undefined&rdquo;，说明了不是arguments的属性，即arguments并不是一个数组对象。<br />\r\n\r\n<br />\r\n\r\n <strong>caller</strong><br />\r\n\r\n  返回一个对函数的引用，该函数调用了当前函数。<br />\r\n\r\n  functionName.<strong>caller</strong> <br />\r\n\r\n  functionName 对象是所执行函数的名称。<br />\r\n\r\n说明<br />\r\n\r\n对于函数来说，<strong>caller</strong> 属性只有在函数执行时才有定义。如果函数是由顶层调用的，那么 <strong>caller</strong> 包含的就是 null 。如果在字符串上下文中使用 <strong>caller</strong> 属性，那么结果和 functionName.toString 一样，也就是说，显示的是函数的反编译文本。<br />\r\n\r\n下面的例子说明了 <strong>caller</strong> 属性的用法：<br />\r\n\r\n<br />\r\n\r\n// <strong>caller</strong> demo {<br />\r\n\r\nfunction callerDemo() {<br />\r\n\r\n    if (callerDemo.<strong>caller</strong>) {<br />\r\n\r\n        var a= callerDemo.<strong>caller</strong>.toString();<br />\r\n\r\n        alert(a);<br />\r\n\r\n    } else {<br />\r\n\r\n        alert("this is a top function");<br />\r\n\r\n    }<br />\r\n\r\n}<br />\r\n\r\nfunction handleCaller() {<br />\r\n\r\n    callerDemo();<br />\r\n\r\n}<br />\r\n\r\n<br />\r\n\r\ncallee<br />\r\n\r\n<br />\r\n\r\n    返回正被执行的 Function 对象，也就是所指定的 Function 对象的正文。<br />\r\n\r\n<br />\r\n\r\n[function.]arguments.callee<br />\r\n\r\n可选项 function 参数是当前正在执行的 Function 对象的名称。<br />\r\n\r\n<br />\r\n\r\n说明<br />\r\n\r\n<br />\r\n\r\ncallee 属性的初始值就是正被执行的 Function 对象。<br />\r\n\r\n<br />\r\n\r\ncallee 属性是 arguments 对象的一个成员，它表示对函数对象本身的引用，这有利于匿名<br />\r\n\r\n函数的递归或者保证函数的封装性，例如下边示例的递归计算1到n的自然数之和。而该属性<br />\r\n\r\n仅当相关函数正在执行时才可用。还有需要注意的是callee拥有length属性，这个属性有时候<br />\r\n\r\n用于验证还是比较好的。arguments.length是实参长度，arguments.callee.length是<br />\r\n\r\n形参长度，由此可以判断调用时形参长度是否和实参长度一致。<br />\r\n\r\n<br />\r\n\r\n示例<br />\r\n\r\n<br />\r\n\r\n<br />\r\n\r\n//callee可以打印其本身<br />\r\n\r\nfunction calleeDemo() {<br />\r\n\r\n    alert(arguments.callee);<br />\r\n\r\n}<br />\r\n\r\n//用于验证参数<br />\r\n\r\nfunction calleeLengthDemo(arg1, arg2) {<br />\r\n\r\n    if (arguments.length==arguments.callee.length) {<br />\r\n\r\n        window.alert("验证形参和实参长度正确！");<br />\r\n\r\n        return;<br />\r\n\r\n    } else {<br />\r\n\r\n        alert("实参长度：" +arguments.length);<br />\r\n\r\n        alert("形参长度： " +arguments.callee.length);<br />\r\n\r\n    }<br />\r\n\r\n}<br />\r\n\r\n//递归计算<br />\r\n\r\nvar sum = function(n){<br />\r\n\r\n  if (n &lt;= 0)                        <br />\r\n\r\n  return 1;<br />\r\n\r\n  else<br />\r\n\r\n    return n ＋arguments.callee(n - 1)<br />\r\n\r\n}<br />\r\n\r\n比较一般的递归函数：<br />\r\n\r\n<br />\r\n\r\nvar sum = function(n){<br />\r\n\r\n    if (1==n) return 1;<br />\r\n\r\nelse return n + sum (n-1);<br />\r\n\r\n<br />\r\n\r\n调用时：alert(sum(100));<br />\r\n\r\n其中函数内部包含了对sum自身的引用，函数名仅仅是一个变量名，在函数内部调用sum即相当于调用<br />\r\n\r\n一个全局变量，不能很好的体现出是调用自身，这时使用callee会是一个比较好的方法。<br />\r\n\r\n<br />\r\n\r\n<br />\r\n\r\napply and call<br />\r\n\r\n<br />\r\n\r\n   它们的作用都是将函数绑定到另外一个对象上去运行，两者仅在定义参数方式有所区别：<br />\r\n\r\n<br />\r\n\r\n    apply(thisArg,argArray);<br />\r\n\r\n<br />\r\n\r\n    call(thisArg[,arg1,arg2&hellip;] ]);<br />\r\n\r\n<br />\r\n\r\n即所有函数内部的this指针都会被赋值为thisArg，这可实现将函数作为另外一个对象的方法运行的目的<br />\r\n\r\n<br />\r\n\r\napply的说明<br />\r\n\r\n<br />\r\n\r\n如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。<br />\r\n\r\n如果没有提供 argArray 和 thisArg任何一个参数，那么 Global 对象将被用作 thisArg， <br />\r\n\r\n并且无法被传递任何参数。<br />\r\n\r\n<br />\r\n\r\ncall的说明<br />\r\n\r\n<br />\r\n\r\ncall 方法可将一个函数的对象上下文从初始的上下文改变为由 thisArg指定的新对象。<br />\r\n\r\n如果没有提供 thisArg参数，那么 Global 对象被用作 thisArg<br />\r\n\r\n<br />\r\n\r\n相关技巧：<br />\r\n\r\n<br />\r\n\r\n应用call和apply还有一个技巧在里面，就是用call和apply应用另一个函数（类）以后，当前的<br />\r\n\r\n函数（类）就具备了另一个函数（类）的方法或者是属性，这也可以称之为&ldquo;继承&rdquo;。看下面示例:<br />\r\n\r\n<br />\r\n\r\n// 继承的演示<br />\r\n\r\nfunction base() {<br />\r\n\r\n    this.member = " dnnsun_Member";<br />\r\n\r\n    this.method = function() {<br />\r\n\r\n        window.alert(this.member);<br />\r\n\r\n    }<br />\r\n\r\n}<br />\r\n\r\nfunction extend() {<br />\r\n\r\n    base.call(this);<br />\r\n\r\n    window.alert(member);<br />\r\n\r\n    window.alert(this.method);<br />\r\n\r\n}<br />\r\n\r\n<br />\r\n\r\n上面的例子可以看出，通过call之后，extend可以继承到base的方法和属性。<br />\r\n\r\n<br />\r\n\r\n <br />\r\n\r\n<br />\r\n\r\n顺便提一下，在<strong><span style="background-color: #ffff66; color: black;">javascript</span></strong>框架prototype里就使用apply来创建一个定义类的模式，<br />\r\n\r\n<br />\r\n\r\n其实现代码如下：<br />\r\n\r\n<br />\r\n\r\nvar Class = {<br />\r\n\r\n  create: function() {<br />\r\n\r\n    return function() {<br />\r\n\r\n      this.initialize.apply(this, arguments);<br />\r\n\r\n    }<br />\r\n\r\n  }<br />\r\n\r\n}<br />\r\n\r\n解析：从代码看,该对象仅包含一个方法：Create，其返回一个函数，即类。但这也同时是类的<br />\r\n\r\n构造函数，其中调用initialize，而这个方法是在类创建时定义的初始化函数。通过如此途径，<br />\r\n\r\n就可以实现prototype中的类创建模式<br />\r\n\r\n<br />\r\n\r\n示例：<br />\r\n\r\n<br />\r\n\r\nvar vehicle=Class.create();<br />\r\n\r\nvehicle.prototype={<br />\r\n\r\n    initialize:function(type){<br />\r\n\r\n        this.type=type;<br />\r\n\r\n    }<br />\r\n\r\n    showSelf:function(){<br />\r\n\r\n        alert("this vehicle is "+ this.type);<br />\r\n\r\n    }<br />\r\n\r\n}<br />\r\n\r\n<br />\r\n\r\nvar moto=new vehicle("Moto");<br />\r\n\r\nmoto.showSelf();<br />\r\n\r\n<br />\r\n\r\n<br />\r\n\r\n更详细的关于prototype信息请到其官方网站查看。</p>', 'JavaScript', '', '2011-05-06 22:32:04'),
(571, 'event对象和caller', '<p>(引：JavaScript高级程序设计P259)每个函数都有一个caller属性，它包含了指向调用它的方法的引用。例如，如果funcA()调用了funcB()，那么funcB.caller就等于funcA。假设某个事件处理函数调用了Event.getEvent()，那么Event.getEvent.caller就指向这个事件处理函数本身。</p>\r\n<p>因为caller属性是指向函数的，所以可访问事件处理函数的arguments属性。而event对象总是事件处理函数的第一个参数，也就是说可以访问事件处理函数的argument[0]来获取event对象：</p>\r\n<pre title="code" class="brush: jscript;">\r\n          QIE.event.getEvent = function() {\r\n              if (window.event) {\r\n                  return this.formatEvent(window.event);\r\n              } else {\r\n                  return this.getEvent.caller.arguments[0];\r\n              }\r\n          }\r\n          </pre>\r\n<p>这个方法可在事件处理函数中使用，如下：</p>\r\n<pre title="code" class="brush: jscript;">\r\n          oDiv.onclick=fucntion(){\r\n            var e=QIE.event.getEvent(); \r\n          }\r\n          </pre>\r\n<p><input type="button" value="EventUtil" id="EventUtil" style="padding:3px 10px" />           <a id="EventUtil-link" style="display:inline-block;padding:3px 10px" href="#">EventUtil-link</a>           <input type="button" value="handleCaller" id="handleCaller" style="padding:3px 10px" />           <input type="button" value="callerDemo" onclick="callerDemo()" style="padding:3px 10px" /></p>\r\n<pre title="code" class="brush: jscript;">\r\n          var QIE={}\r\n          QIE.event = {\r\n              addEventHandler : function (oTarget, sEventType, fnHandler) {\r\n                  if (oTarget.addEventListener) {\r\n                      oTarget.addEventListener(sEventType, fnHandler, false);\r\n                  } else if (oTarget.attachEvent) {\r\n                      oTarget.attachEvent(&quot;on&quot; + sEventType, fnHandler);\r\n                  } else {\r\n                      oTarget[&quot;on&quot; + sEventType] = fnHandler;\r\n                  }\r\n              },       \r\n              removeEventHandler : function (oTarget, sEventType, fnHandler) {\r\n                  if (oTarget.removeEventListener) {\r\n                      oTarget.removeEventListener(sEventType, fnHandler, false);\r\n                  } else if (oTarget.detachEvent) {\r\n                      oTarget.detachEvent(&quot;on&quot; + sEventType, fnHandler);\r\n                  } else { \r\n                      oTarget[&quot;on&quot; + sEventType] = null;\r\n                  }\r\n              },\r\n              formatEvent : function (oEvent) {\r\n                  if (!document.addEventListener) {\r\n                      oEvent.charCode = (oEvent.type == &quot;keypress&quot;) ? oEvent.keyCode : 0;\r\n                      oEvent.eventPhase = 2;\r\n                      oEvent.isChar = (oEvent.charCode &gt; 0);\r\n                      oEvent.pageX = oEvent.clientX + document.body.scrollLeft;\r\n                      oEvent.pageY = oEvent.clientY + document.body.scrollTop;\r\n                      oEvent.preventDefault = function () {\r\n                          this.returnValue = false;\r\n                      };\r\n              \r\n                      if (oEvent.type == &quot;mouseout&quot;) {\r\n                          oEvent.relatedTarget = oEvent.toElement;\r\n                      } else if (oEvent.type == &quot;mouseover&quot;) {\r\n                          oEvent.relatedTarget = oEvent.fromElement;\r\n                      }\r\n              \r\n                      oEvent.stopPropagation = function () {\r\n                          this.cancelBubble = true;\r\n                      };\r\n              \r\n                      oEvent.target = oEvent.srcElement;\r\n                      oEvent.time = (new Date).getTime();\r\n                  }\r\n                  return oEvent;\r\n              },\r\n              getEvent : function() {\r\n                  if (window.event) {\r\n                      return this.formatEvent(window.event);\r\n                  } else {\r\n                      return this.getEvent.caller.arguments[0];\r\n                  }\r\n              }\r\n          };\r\n          \r\n          function callerDemo() {\r\n              if (callerDemo.caller) {\r\n                  var a= callerDemo.caller.toString();\r\n                  alert(a);\r\n                  alert(callerDemo.caller.arguments[0]);\r\n              } else {\r\n                  alert(&quot;this is a top function&quot;);\r\n              }\r\n          }\r\n          /**\r\n           *handleCaller函数调用了callerDemo，所以callerDemo.caller等于handleCaller\r\n           */\r\n          function handleCaller() {\r\n              callerDemo();\r\n          };\r\n          \r\n          callerDemo();\r\n          \r\n          (function(S){\r\n              var evt=S.event;\r\n              handleCaller();\r\n              callerDemo();\r\n              evt.addEventHandler(document.getElementById(''handleCaller''),''click'',handleCaller)\r\n              evt.addEventHandler(document.getElementById(''EventUtil''),''click'',function(){\r\n                                          var e=evt.getEvent();\r\n                                          alert(''type:''+e.type+''\\n''+''pageX:''+e.pageX+''\\n''+''pageY:''+e.pageY+''\\n''+''tagName:''+e.target.tagName)\r\n                                        });\r\n              evt.addEventHandler(document.getElementById(''EventUtil-link''),''click'',function(){\r\n                                          var e=evt.getEvent();\r\n                                          e.preventDefault();\r\n                                          alert(''type:''+e.type+''\\n''+''pageX:''+e.pageX+''\\n''+''pageY:''+e.pageY+''\\n''+''tagName:''+e.target.tagName)\r\n                                        });		  \r\n          })(QIE);\r\n          </pre>\r\n<script>\r\nvar QIE={}\r\nQIE.event = {\r\n	addEventHandler : function (oTarget, sEventType, fnHandler) {\r\n		if (oTarget.addEventListener) {\r\n			oTarget.addEventListener(sEventType, fnHandler, false);\r\n		} else if (oTarget.attachEvent) {\r\n			oTarget.attachEvent("on" + sEventType, fnHandler);\r\n		} else {\r\n			oTarget["on" + sEventType] = fnHandler;\r\n		}\r\n	},       \r\n	removeEventHandler : function (oTarget, sEventType, fnHandler) {\r\n		if (oTarget.removeEventListener) {\r\n			oTarget.removeEventListener(sEventType, fnHandler, false);\r\n		} else if (oTarget.detachEvent) {\r\n			oTarget.detachEvent("on" + sEventType, fnHandler);\r\n		} else { \r\n			oTarget["on" + sEventType] = null;\r\n		}\r\n	},\r\n	formatEvent : function (oEvent) {\r\n		if (!document.addEventListener) {\r\n			oEvent.charCode = (oEvent.type == "keypress") ? oEvent.keyCode : 0;\r\n			oEvent.eventPhase = 2;\r\n			oEvent.isChar = (oEvent.charCode > 0);\r\n			oEvent.pageX = oEvent.clientX + document.body.scrollLeft;\r\n			oEvent.pageY = oEvent.clientY + document.body.scrollTop;\r\n			oEvent.preventDefault = function () {\r\n				this.returnValue = false;\r\n			};\r\n	\r\n			if (oEvent.type == "mouseout") {\r\n				oEvent.relatedTarget = oEvent.toElement;\r\n			} else if (oEvent.type == "mouseover") {\r\n				oEvent.relatedTarget = oEvent.fromElement;\r\n			}\r\n	\r\n			oEvent.stopPropagation = function () {\r\n				this.cancelBubble = true;\r\n			};\r\n	\r\n			oEvent.target = oEvent.srcElement;\r\n			oEvent.time = (new Date).getTime();\r\n		}\r\n		return oEvent;\r\n	},\r\n	getEvent : function() {\r\n		if (window.event) {\r\n			return this.formatEvent(window.event);\r\n		} else {\r\n			return this.getEvent.caller.arguments[0];\r\n		}\r\n	}\r\n};\r\n\r\nfunction callerDemo() {\r\n	if (callerDemo.caller) {\r\n		var a= callerDemo.caller.toString();\r\n		alert(a);\r\n		alert(callerDemo.caller.arguments[0]);\r\n	} else {\r\n		alert("this is a top function");\r\n	}\r\n}\r\n/**\r\n *handleCaller函数调用了callerDemo，所以callerDemo.caller等于handleCaller\r\n */\r\nfunction handleCaller() {\r\n	callerDemo();\r\n};\r\n\r\n//callerDemo();\r\n\r\n(function(S){\r\n	var evt=S.event;\r\n	//handleCaller();\r\n	//callerDemo();\r\n	evt.addEventHandler(document.getElementById(''handleCaller''),''click'',handleCaller)\r\n	evt.addEventHandler(document.getElementById(''EventUtil''),''click'',function(){\r\n								var e=evt.getEvent();\r\n								alert(''type:''+e.type+''\\n''+''pageX:''+e.pageX+''\\n''+''pageY:''+e.pageY+''\\n''+''tagName:''+e.target.tagName)\r\n							  });\r\n	evt.addEventHandler(document.getElementById(''EventUtil-link''),''click'',function(){\r\n								var e=evt.getEvent();\r\n								e.preventDefault();\r\n								alert(''type:''+e.type+''\\n''+''pageX:''+e.pageX+''\\n''+''pageY:''+e.pageY+''\\n''+''tagName:''+e.target.tagName)\r\n							  });		  \r\n})(QIE);\r\n</script>', 'JavaScript', '1', '2011-05-07 19:44:16'),
(573, '透明的小三角', '<pre title="code" class="brush: css;">\r\n.jt{width:0;height:0;overflow:hidden;border-bottom:5px dashed transparent;border-top:5px solid #909090;border-left:5px dashed transparent;border-right:5px dashed transparent}</pre>', 'CSS', '', '2011-05-09 8:41:27'),
(574, 'hasOwnProperty2', '<pre title="code" class="brush: jscript;">\r\nArray.prototype.count = function(){\r\n	return this.length;\r\n}\r\nvar arr = [1, 2];\r\nfor(var i in arr){\r\n        if(!arr.hasOwnProperty(i)) continue;\r\n	alert(i);\r\n}</pre>\r\n<pre title="code" class="brush: jscript; ">\r\nArray.prototype.count = function(){\r\n	return this.length;\r\n}\r\nvar arr = [1, 2];\r\nfor(var i in arr){\r\n	alert(i);\r\n}</pre>', 'JavaScript', '', '2011-05-09 9:36:34'),
(575, 'hasOwnProperty', '<h2>hasOwnProperty</h2>\r\n<p>为了判断一个对象是否包含自定义属性而不是原型链上的属性， 我们需要使用继承自 Object.prototype 的 hasOwnProperty 方法。  注意: 通过判断一个属性是否 undefined 是不够的。 因为一个属性可能确实存在，只不过它的值被设置为 undefined。  hasOwnProperty 是JavaScript中唯一一个处理属性但是不需要查找原型链的方法。</p>\r\n<pre title="code" class="brush: jscript;">\r\n// 修改Object.prototype\r\nObject.prototype.bar = 1; \r\nvar foo = {goo: undefined};\r\nfoo.bar; // 1\r\n''bar'' in foo; // true\r\nfoo.hasOwnProperty(''bar''); // false\r\nfoo.hasOwnProperty(''goo''); // true</pre>\r\n<p>只有 hasOwnProperty 可以给出正确和期望的结果，这在遍历对象的属性时会很有用。 没有其它方法可以用来排除原型链上的属性，而不是定义在对象自身上的属性。</p>\r\n<h2>hasOwnProperty 作为属性（hasOwnProperty as a property）</h2>\r\n<p>JavaScript 不会保护 hasOwnProperty 被非法占用，因此如果一个对象碰巧存在这个属性， 就需要使用外部的 hasOwnProperty 函数来获取正确的结果。</p>\r\n<pre title="code" class="brush: jscript;">\r\nvar foo = {\r\n	    hasOwnProperty: function() {\r\n	        return false;\r\n	    },\r\n	    bar: ''Here be dragons''\r\n	};\r\n	  \r\n	foo.hasOwnProperty(''bar''); // 总是返回 false\r\n	  \r\n	// 使用其它对象的 hasOwnProperty，并将其上下为设置为foo\r\n	{}.hasOwnProperty.call(foo, ''bar''); // true\r\n</pre>\r\n<h2>结论（In conclusion）</h2>\r\n<p>当检查对象上某个属性是否存在时，hasOwnProperty 是唯一可用的方法。 同时在使用 for in loop 遍历对象时，推荐总是使用 hasOwnProperty 方法， 这将会避免原型对象扩展带来的干扰。</p>', 'JavaScript', '1', '2011-05-09 8:42:29'),
(576, 'JS性能', '<p>说到性能，我们脑海中会即可浮现出一系列优化策略，如异步加载、延时渲染、减少http、请求等等。这些传统的优化策略我们依然适用，事实上模块化的开发模式可以让异步加载做的更彻底，当交互事件发生时，除了向服务器请求相应的html文档片段外，还可以在此之后，加载js模块，这无非进一步减少了页面加载时http请求的收发数据量，对提高页面性能是大有裨益的(http://ued.taobao.com/blog/2011/05/13/2011-taobao-lottery-index-dev/)</p>\r\n<ul>\r\n    <li style="padding-bottom:20px">1.[顶]关于JS的循环，循环是一种常用的流程控制。JS提供了三种循环：for(;;)、while()、for(in)。在这三种循环中 for(in)的效率最差，因为它需要查询Hash键，因此应尽量少用for(in)循环，for(;;)、while()循环的性能基本持平。当然，推 荐使用for循环，如果循环变量递增或递减，不要单独对循环变量赋值，而应该使用嵌套的++或－－运算符。</li>\r\n    <li style="padding-bottom:20px">2.如果需要遍历数组，应该先缓存数组长度，将数组长度放入局部变量中，避免多次查询数组长度。</li>\r\n    <li style="padding-bottom:20px">3.局部变量的访问速度要比全局变量的访问速度更快，因为全局变量其实是window对象的成员，而局部变量是放在函数的栈里的。</li>\r\n    <li style="padding-bottom:20px">4.尽量少使用eval，每次使用eval需要消耗大量时间，这时候使用JS所支持的闭包可以实现函数模板。</li>\r\n    <li style="padding-bottom:20px">5.尽量避免对象的嵌套查询，对于obj1.obj2.obj3.obj4这个语句，需要进行至少3次查询操作，先检查obj1中是否包含 obj2，再检查obj2中是否包含obj3，然后检查obj3中是否包含obj4...这不是一个好策略。应该尽量利用局部变量，将obj4以局部变量 保存，从而避免嵌套查询。</li>\r\n    <li style="padding-bottom:20px">6.使运算符时，尽量使用+＝，－＝、*＝、\\=等运算符号，而不是直接进行赋值运算。</li>\r\n    <li style="padding-bottom:20px">7.[顶]当需要将数字转换成字符时，采用如下方式：&quot;&quot; + 1。从性能上来看，将数字转换成字符时，有如下公式：(&quot;&quot; +) &gt;&nbsp;String() &gt; .toString() &gt; new String()。String()属于内部函数，所以速度很快。而.toString()要查询原型中的函数，所以速度逊色一些，new String()需要重新创建一个字符串对象，速度最慢。</li>\r\n    <li style="padding-bottom:20px">8.[顶]当需要将浮点数转换成整型时，应该使用Math.floor()或者Math.round()。而不是使用parseInt(),该方法用于将字符串转&nbsp;换成数字。而且Math是内部对象，所以Math.floor()其实并没有多少查询方法和调用时间，速度是最快的。</li>\r\n    <li style="padding-bottom:20px">9.尽量作用JSON格式来创建对象，而不是var obj=new Object()方法。因为前者是直接复制，而后者需要调用构造器，因而前者的性能更好。</li>\r\n    <li style="padding-bottom:20px">10.当需要使用数组时，也尽量使用JSON格式的语法，即直接使用如下语法定义数组：[parrm,param,param...],而不是采用 new&nbsp;Array(parrm,param,param...)这种语法。因为使用JSON格式的语法是引擎直接解释的。而后者则需要调用Array的构造器。</li>\r\n    <li style="padding-bottom:20px">11.[顶]对字符串进行循环操作，例如替换、查找，就使用正则表达式。因为JS的循环速度比较慢，而正则表达式的操作是用C写成的API，性能比较好。最后有一个基本原则，对于大的JS对象，因为创建时时间和空间的开销都比较大，因此应该尽量考虑采用缓存。</li>\r\n</ul>', 'JavaScript', '1', '2011-05-14 11:23:47'),
(577, '用doctype激活浏览器模式', '<p><a target="_blank" href="http://dancewithnet.com/2009/06/14/activating-browser-modes-with-doctype/">http://dancewithnet.com/2009/06/14/activating-browser-modes-with-doctype/</a></p>', 'HTML5', '', '2011-05-09 8:43:39'),
(578, 'autocomplete=off', '<p>有过表单设计经验的朋友肯定知道，当我们在浏览器中输入表单信息的时候，往往input文本输入框会记录下之前提交表单的信息，以后每次只要双击 input文本输入框就会出现之前输入的文本，这样有时会觉得比较方便，但有时也会暴露用户的隐藏数据，所以今天就教大家让input表单输入框不记录输 入过信息的方法。</p>\r\n<p style="margin-top: 0px; margin-right: 0px; margin-bottom: 1em; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; color: rgb(109, 109, 109); line-height: 26px; font-family: arial; font-size: 12px; ">&nbsp;&nbsp;&nbsp; 其实方法很简单，只需要在input文本输入框中加一条<span style="color: rgb(255, 0, 0); ">autocomplete=&quot;off&quot;</span>属性即可，相关代友如下所示：</p>\r\n<p style="margin-top: 0px; margin-right: 0px; margin-bottom: 1em; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; color: rgb(109, 109, 109); line-height: 26px; font-family: arial; font-size: 12px; ">&nbsp;&nbsp;&nbsp; &lt;input type=&quot;text&quot; name=&quot;htmer&quot;<span style="color: rgb(255, 0, 0); ">&nbsp;autocomplete=&quot;off&quot;</span>&nbsp;/&gt;</p>\r\n<p>&nbsp;</p>', 'HTML', '', '2011-09-18 18:04:46'),
(579, '罗马数字', '<p><span style=" font-size: 14px; line-height: 24px; "><a target="_blank" style="text-decoration: underline; color: rgb(19, 110, 194); " href="http://baike.baidu.com/view/2245.htm">罗马</a></span><span style=" font-size: 14px; line-height: 24px; ">数字是最早的数字表示方式，比阿拉伯数字早2000多年。起源于罗马。</span><span style=" font-size: 14px; line-height: 24px; ">　　</span></p>\r\n<p><span style=" font-size: 14px; line-height: 24px; ">如今我们最常见的罗马数字就是钟表的表盘符号：</span><span style=" font-size: 14px; line-height: 24px; "><b>Ⅰ， Ⅱ ， Ⅲ ，Ⅳ ，Ⅴ ，Ⅵ ，Ⅶ ，Ⅷ ，Ⅸ ，Ⅹ ，Ⅺ ，Ⅻ 。</b></span><span style=" font-size: 14px; line-height: 24px; ">　　</span></p>\r\n<p><span style=" font-size: 14px; line-height: 24px; ">对应阿拉伯数字（就是现在国际通用的数字），就是1，2，3，4，5，6，7，8，9，10，11，12。</span><span style=" font-size: 14px; line-height: 24px; "><b>阿拉伯数字其实是古代印度人发明的</b></span><span style=" font-size: 14px; line-height: 24px; ">，后来由阿拉伯人传入</span><span style=" font-size: 14px; line-height: 24px; "><a target="_blank" style="text-decoration: underline; color: rgb(19, 110, 194); " href="http://baike.baidu.com/view/3622.htm">欧洲</a></span><span style=" font-size: 14px; line-height: 24px; ">，被欧洲人误称为阿拉伯数字。</span></p>', '随笔', '', '2011-05-09 8:48:49');
INSERT INTO `list` (`id`, `title`, `content`, `cat`, `marrow`, `time`) VALUES
(580, 'JavaScript初学者应注意的七个细节', '<p><span style="font-size: 13px;">　　每种语言都有它特别的地方，对于JavaScript来说，使用var就可以声明任意类型的变量，这门脚本语言看起来很简单，然而想要写出优雅的代码却是需要不断积累经验的。本文利列举了JavaScript初学者应该注意的七个细节，与大家分享。 </span></p>\r\n<p class="MsoNormal"><span style="font-size: 14pt;" class="ctn_title"><strong><span style="font-family: 宋体;" face="宋体">（1）</span>简化代码</strong></span></p>\r\n<hr class="title_line" />\r\n<p><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">&nbsp;</span></p>\r\n<p><span style="font-size: 13px;"><span lang="EN-US"><span style="font-family: Times New Roman;" face="Times New Roman">JavaScript</span></span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">定义对象和数组非常简单，我们想要创建一个对象，一般是这样写的：</span><span lang="EN-US"><span style="font-family: Times New Roman;" face="Times New Roman">&nbsp;</span></span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';"> </span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">&nbsp;</span></span></p>\r\n<div class="cnblogs_Highlighter">\r\n<pre class="brush:javascript">var car = new Object();\r\ncar.colour = ''red'';\r\ncar.wheels = 4;\r\ncar.hubcaps = ''spinning'';\r\ncar.age = 4;</pre>\r\n</div>\r\n<p class="MsoNormal"><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">下面的写法可以达到同样的效果：</span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';"> </span></p>\r\n<p><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';"></span></p>\r\n<div class="cnblogs_Highlighter">\r\n<pre class="brush:javascript">var car = {\r\n	colour:''red'',\r\n	wheels:4,\r\n　　hubcaps:''spinning'',\r\n　　age:4\r\n}</pre>\r\n</div>\r\n<div></div>\r\n<p class="MsoNormal"><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">后面的写法要短得多，而且你不需要重复写对象名称。</span></p>\r\n<p class="MsoNormal"><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">另外对于数组同样有简洁的写法，过去我们声明数组是这样写的：</span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';"> </span></p>\r\n<p><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">\r\n</span></p>\r\n<div class="cnblogs_Highlighter">\r\n<pre class="brush:javascript">var moviesThatNeedBetterWriters = new Array(\r\n  ''Transformers'',''Transformers2'',''Avatar'',''Indiana Jones 4''\r\n);\r\n</pre>\r\n</div>\r\n<div></div>\r\n<p class="MsoNormal"><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">更简洁的写法是：</span><span lang="EN-US"><span style="font-family: Times New Roman;" face="Times New Roman">&nbsp;</span></span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';"> </span></p>\r\n<p><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">\r\n</span></p>\r\n<div class="cnblogs_Highlighter">\r\n<pre class="brush:javascript">var moviesThatNeedBetterWriters = [\r\n  ''Transformers'',''Transformers2'',''Avatar'',''Indiana Jones 4''\r\n];\r\n</pre>\r\n</div>\r\n<div></div>\r\n<p class="MsoNormal"><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">对于数组，还有关联数组这样一个特别的东西。</span><span lang="EN-US"><span style="font-family: Times New Roman;" face="Times New Roman">&nbsp;</span></span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">你会发现很多代码是这样定义对象的：</span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';"> </span></p>\r\n<p><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">\r\n</span></p>\r\n<div class="cnblogs_Highlighter">\r\n<pre class="brush:javascript">var car = new Array();\r\ncar[''colour''] = ''red'';\r\ncar[''wheels''] = 4;\r\ncar[''hubcaps''] = ''spinning'';\r\ncar[''age''] = 4;\r\n</pre>\r\n</div>\r\n<div></div>\r\n<p class="MsoNormal"><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">这太疯狂了，不要觉得困惑，&ldquo;</span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">关联数组&rdquo;只</span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">是对象的一个别名而已。</span></p>\r\n<p class="MsoNormal"><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">另外一个简化代码的方法是使用三元运算符，举个例子：</span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';"> </span></p>\r\n<p><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';"></span></p>\r\n<div class="cnblogs_Highlighter">\r\n<pre class="brush:javascript">var direction;\r\nif(x &lt; 200){\r\n  direction = 1;\r\n} else {\r\n  direction = -1;\r\n}\r\n</pre>\r\n</div>\r\n<div></div>\r\n<p class="MsoNormal"><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">我们可以使用如下的代码替换这种写法：</span><span lang="EN-US"><span style="font-family: Times New Roman;" face="Times New Roman"> </span></span></p>\r\n<p><span lang="EN-US"><span style="font-family: Times New Roman;" face="Times New Roman">\r\n</span></span></p>\r\n<div class="cnblogs_Highlighter">\r\n<pre class="brush:javascript">var direction = x &lt; 200 ? 1 : -1;\r\n</pre>\r\n</div>\r\n<p class="MsoNormal">&nbsp;</p>\r\n<p class="MsoNormal"><strong><span style="font-size: 14pt;"><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">&nbsp;</span></span></strong></p>\r\n<p class="MsoNormal"><strong><span style="font-size: 14pt;"><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">（2）使用</span><span lang="EN-US"><span style="font-family: Times New Roman;" face="Times New Roman">JSON</span></span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">作为数据格式</span></span></strong> <span lang="EN-US"><span style="font-family: Times New Roman;" face="Times New Roman">&nbsp;</span></span><span lang="EN-US"><span style="font-family: Times New Roman;" face="Times New Roman">&nbsp;</span></span></p>\r\n<p class="MsoNormal">&nbsp;</p>\r\n<hr class="title_line" />\r\n<p class="MsoNormal">&nbsp;</p>\r\n<div class="MsoNormal">\r\n<p class="MsoNormal"><span lang="EN-US"><span style="font-family: Times New Roman;" face="Times New Roman">伟大的Douglas Crockford</span></span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">发明了</span><span lang="EN-US"><span style="font-family: Times New Roman;" face="Times New Roman">JSON</span></span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">数据格式来存储数据，你可以使用原生的</span><span lang="EN-US"><span style="font-family: Times New Roman;" face="Times New Roman">javascript</span></span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">方法来存储复杂的数据而不需要进行任何额外的转换，例如：</span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';"> </span></p>\r\n<div class="cnblogs_Highlighter">\r\n<pre class="brush:javascript">var band = {\r\n  "name":"The Red Hot Chili Peppers",\r\n  "members":[\r\n    {\r\n      "name":"Anthony Kiedis",\r\n      "role":"lead vocals"\r\n    },\r\n    {\r\n      "name":"Michael ''Flea'' Balzary",\r\n      "role":"bass guitar, trumpet, backing vocals"\r\n    },\r\n    {\r\n      "name":"Chad Smith",\r\n      "role":"drums,percussion"\r\n    },\r\n    {\r\n      "name":"John Frusciante",\r\n      "role":"Lead Guitar"\r\n    }\r\n  ],\r\n  "year":"2009"\r\n}\r\n</pre>\r\n</div>\r\n<p class="MsoNormal"><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">你可以使用在</span><span lang="EN-US"><span style="font-family: Times New Roman;" face="Times New Roman">JavaScript</span></span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">中直接使用</span><span lang="EN-US"><span style="font-family: Times New Roman;" face="Times New Roman">JSON</span></span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">，甚至作为</span><span lang="EN-US"><span style="font-family: Times New Roman;" face="Times New Roman">API</span></span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">返回的一种格式，</span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">在许多的</span><span lang="EN-US"><span style="font-family: Times New Roman;" face="Times New Roman">API中被应用</span></span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">，例如：</span></p>\r\n<span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">\r\n<p class="MsoNormal">&nbsp;</p>\r\n<pre class="brush:html">&lt;div id="delicious"&gt;&lt;/div&gt;&lt;script&gt;\r\nfunction delicious(o){\r\n  var out = ''&lt;ul&gt;'';\r\n  for(var i=0;i&lt;o.length;i++){\r\n    out += ''&lt;li&gt;&lt;a href="'' + o[i].u + ''"&gt;'' +\r\n           o[i].d + ''&lt;/a&gt;&lt;/li&gt;'';\r\n  }\r\n  out += ''&lt;/ul&gt;'';\r\n  document.getElementById(''delicious'').innerHTML = out;\r\n}\r\n&lt;/script&gt;\r\n&lt;script src="http://feeds.delicious.com/v2/json/codepo8/javascript?count=15&amp;callback=delicious"&gt;&lt;/script&gt;</pre>\r\n</span></div>\r\n<p><span style="font-size: 13px;"><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">这里调用</span><span lang="EN-US"><span style="font-family: Times New Roman;" face="Times New Roman">delicious </span></span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">的</span><span lang="EN-US"><span style="font-family: Times New Roman;" face="Times New Roman">Web</span></span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">服务获取最新书签，以</span><span lang="EN-US"><span style="font-family: Times New Roman;" face="Times New Roman">JSON</span></span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">格式返回，然后将它们显示成无序列表的形式。</span></span></p>\r\n<p><span style="font-size: 13px;"><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">从本质上讲，</span><span lang="EN-US"><span style="font-family: Times New Roman;" face="Times New Roman">JSON</span></span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">是用于描述复杂的数据最轻量级的方式，而且直接它运行在浏览器中。</span><span lang="EN-US"><span style="font-family: Times New Roman;" face="Times New Roman">&nbsp;</span></span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">你甚至可以在</span><span lang="EN-US"><span style="font-family: Times New Roman;" face="Times New Roman">PHP</span></span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">中调用 </span><span lang="EN-US"><span style="font-family: Times New Roman;" face="Times New Roman">json_decode</span></span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">（）函数来使用它。</span></span></p>\r\n<p><strong><span style="font-size: 14pt;">（</span></strong><span style="font-size: 14pt;">3</span><strong><span style="font-size: 14pt;">）尽量使用JavaScript原生函数&nbsp;</span></strong></p>\r\n<hr class="title_line" />\r\n<p><span style="font-size: 13px;">&nbsp;</span></p>\r\n<p><span style="font-size: 13px;">要找一组数字中的最大数，我们可能会写一个循环，例如： </span></p>\r\n<p class="MsoNormal">&nbsp;</p>\r\n<pre class="brush:javascript">var numbers = [3,342,23,22,124];\r\nvar max = 0;\r\nfor(var i=0;i&lt;numbers.length;i++){\r\n  if(numbers[i] &gt; max){\r\n    max = numbers[i];\r\n  }\r\n}\r\nalert(max);\r\n</pre>\r\n<p class="MsoNormal"><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">其实，不用循环可以实现同样的功能：</span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';"> </span></p>\r\n<p><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">\r\n</span></p>\r\n<div class="cnblogs_Highlighter">\r\n<pre class="brush:javascript">var numbers = [3,342,23,22,124];\r\nnumbers.sort(function(a,b){return b - a});\r\nalert(numbers[0]);\r\n</pre>\r\n</div>\r\n\r\n<div></div>\r\n<p class="MsoNormal"><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">而最简洁的写法是：</span><span lang="EN-US"><span style="font-family: Times New Roman;" face="Times New Roman"> </span></span></p>\r\n\r\n<p><span lang="EN-US"><span style="font-family: Times New Roman;" face="Times New Roman">\r\n\r\n</span></span></p>\r\n\r\n<div class="cnblogs_Highlighter">\r\n\r\n<pre class="brush:javascript">Math.max(12,123,3,2,433,4); // returns 433\r\n\r\n</pre>\r\n\r\n</div>\r\n\r\n\r\n\r\n<p class="MsoNormal"><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">你甚至可以使用</span><span lang="EN-US"><span style="font-family: Times New Roman;" face="Times New Roman">Math.max</span></span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">来检测浏览器支持哪个属性：</span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';"> </span></p>\r\n\r\n<p><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">\r\n\r\n</span></p>\r\n\r\n<div class="cnblogs_Highlighter">\r\n\r\n<pre class="brush:javascript">var scrollTop= Math.max(\r\n doc.documentElement.scrollTop,\r\n doc.body.scrollTop\r\n);\r\n\r\n</pre>\r\n\r\n</div>\r\n\r\n\r\n\r\n<div></div>\r\n\r\n<p class="MsoNormal"><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">如果你想给一个元素增加</span><span lang="EN-US"><span style="font-family: Times New Roman;" face="Times New Roman">class</span></span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">样式，可能原始的写法是这样的：</span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';"> </span></p>\r\n\r\n<p><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">\r\n\r\n</span></p>\r\n\r\n<div class="cnblogs_Highlighter">\r\n\r\n<pre class="brush:javascript">function addclass(elm,newclass){\r\n  var c = elm.className;\r\n  elm.className = (c === '''') ? newclass : c+'' ''+newclass;</pre>\r\n</div>\r\n\r\n\r\n\r\n<div></div>\r\n\r\n<p class="MsoNormal"><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">而更优雅的写法是：</span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';"> </span></p>\r\n\r\n<p><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">\r\n\r\n</span></p>\r\n\r\n<div class="cnblogs_Highlighter">\r\n\r\n<pre class="brush:javascript">function addclass(elm,newclass){\r\n  var classes = elm.className.split('' '');\r\n  classes.push(newclass);\r\n  elm.className = classes.join('' '');\r\n}\r\n</pre>\r\n\r\n</div>\r\n\r\n\r\n\r\n<div></div>\r\n\r\n<p class="MsoNormal"><strong><span style="font-family: 宋体; font-size: 14pt; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">&nbsp; </span></strong></p>\r\n\r\n<p class="MsoNormal"><strong><span style="font-family: 宋体; font-size: 14pt; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">（4）事件委托</span></strong></p>\r\n\r\n<p><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">\r\n\r\n</span></p>\r\n\r\n<hr class="title_line" />\r\n\r\n<p class="MsoNormal">&nbsp;</p>\r\n\r\n<span style="font-size: 13px;"><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">事件是J</span><span lang="EN-US"><span style="font-family: Times New Roman;" face="Times New Roman">avaScript</span></span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">非常重要的一部分。我们想给一个列表中的链接绑定点击事件，一般的做法是写一个循环，给每个链接对象绑定事件，</span><span lang="EN-US"><span style="font-family: Times New Roman;" face="Times New Roman">HTML</span></span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">代码如下：</span></span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';"> </span>\r\n\r\n\r\n\r\n<p><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">\r\n\r\n</span></p>\r\n\r\n<div class="cnblogs_Highlighter">\r\n\r\n<pre class="brush:javascript">&lt;h2&gt;Great Web resources&lt;/h2&gt;\r\n&lt;ul id="resources"&gt;\r\n  &lt;li&gt;&lt;a href="http://opera.com/wsc"&gt;Opera Web Standards Curriculum&lt;/a&gt;&lt;/li&gt;\r\n  &lt;li&gt;&lt;a href="http://sitepoint.com"&gt;Sitepoint&lt;/a&gt;&lt;/li&gt;\r\n  &lt;li&gt;&lt;a href="http://alistapart.com"&gt;A List Apart&lt;/a&gt;&lt;/li&gt;\r\n  &lt;li&gt;&lt;a href="http://yuiblog.com"&gt;YUI Blog&lt;/a&gt;&lt;/li&gt;\r\n  &lt;li&gt;&lt;a href="http://blameitonthevoices.com"&gt;Blame it on the voices&lt;/a&gt;&lt;/li&gt;\r\n  &lt;li&gt;&lt;a href="http://oddlyspecific.com"&gt;Oddly specific&lt;/a&gt;&lt;/li&gt;\r\n&lt;/ul&gt;\r\n</pre>\r\n\r\n</div>\r\n\r\n\r\n\r\n<div></div>\r\n\r\n<p class="MsoNormal"><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">脚本如下：</span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';"> </span></p>\r\n\r\n<p><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">\r\n\r\n</span></p>\r\n\r\n<div class="cnblogs_Highlighter">\r\n\r\n<pre class="brush:javascript">// Classic event handling example\r\n(function(){\r\n  var resources = document.getElementById(''resources'');\r\n  var links = resources.getElementsByTagName(''a'');\r\n  var all = links.length;\r\n  for(var i=0;i&lt;all;i++){\r\n    // Attach a listener to each link\r\n    links[i].addEventListener(''click'',handler,false);\r\n  };\r\n  function handler(e){\r\n    var x = e.target; // Get the link that was clicked\r\n    alert(x);\r\n    e.preventDefault();\r\n  };\r\n})();\r\n\r\n</pre>\r\n\r\n</div>\r\n\r\n\r\n\r\n<div></div>\r\n\r\n<p class="MsoNormal"><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">更合理的写法是只给列表的父对象绑定事件，代码如下：</span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';"> </span></p>\r\n\r\n<p><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">\r\n\r\n</span></p>\r\n\r\n<div class="cnblogs_Highlighter">\r\n\r\n<pre class="brush:javascript">(function(){\r\n  var resources = document.getElementById(''resources'');\r\n  resources.addEventListener(''click'',handler,false);\r\n  function handler(e){\r\n    var x = e.target; // get the link tha\r\n    if(x.nodeName.toLowerCase() === ''a''){\r\n      alert(''Event delegation:'' + x);\r\n      e.preventDefault();\r\n    }\r\n  };\r\n})();\r\n\r\n</pre>\r\n\r\n</div>\r\n\r\n\r\n\r\n<div></div>\r\n\r\n<p class="MsoNormal"><strong><span style="font-family: 宋体; font-size: 14pt; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">&nbsp; </span></strong></p>\r\n\r\n<p class="MsoNormal"><strong><span style="font-family: 宋体; font-size: 14pt; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">（5）匿名函数</span></strong></p>\r\n\r\n<p><strong><span style="font-family: 宋体; font-size: 14pt; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">\r\n\r\n</span></strong></p>\r\n\r\n<hr class="title_line" />\r\n\r\n<strong>\r\n\r\n<p class="MsoNormal">&nbsp;</p>\r\n\r\n</strong><span style="font-size: 13px;"><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">关于</span><span lang="EN-US"><span style="font-family: Times New Roman;" face="Times New Roman">JavaScript</span></span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">的最头疼的事情之一是，它的变量没有特定的作用范围。</span><span lang="EN-US"><span style="font-family: Times New Roman;" face="Times New Roman">&nbsp;一般情况下，</span></span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">任何变量，函数，数组或对象都是全局性，这意味着在同一页上的其他脚本可以访问并覆盖它们。解决方法是把变量封装在一个匿名函数中。</span><span lang="EN-US"><span style="font-family: Times New Roman;" face="Times New Roman">&nbsp;</span></span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">例如，下面的定义将产生三个全局变量和和两个全局函数：</span></span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';"> </span>\r\n\r\n\r\n\r\n<p><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">\r\n\r\n</span></p>\r\n\r\n<div class="cnblogs_Highlighter">\r\n\r\n<pre class="brush:javascript">var name = ''Chris'';\r\nvar age = ''34'';\r\nvar status = ''single'';\r\nfunction createMember(){\r\n  // [...]\r\n}\r\nfunction getMemberDetails(){\r\n  // [...]\r\n}\r\n</pre>\r\n\r\n</div>\r\n\r\n\r\n\r\n<div></div>\r\n\r\n<p class="MsoNormal"><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">封装后如下：</span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';"> </span></p>\r\n\r\n<p><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">\r\n\r\n</span></p>\r\n\r\n<div class="cnblogs_Highlighter">\r\n\r\n<pre class="brush:javascript">var myApplication = function(){\r\n  var name = ''Chris'';\r\n  var age = ''34'';\r\n  var status = ''single'';\r\n  return{\r\n    createMember:function(){\r\n      // [...]\r\n    },\r\n    getMemberDetails:function(){\r\n      // [...]\r\n    }\r\n  }\r\n}();\r\n// myApplication.createMember() and\r\n// myApplication.getMemberDetails() now works.\r\n</pre>\r\n\r\n</div>\r\n\r\n\r\n\r\n<div></div>\r\n\r\n<p class="MsoNormal"><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">这被称为单体模式，是J</span><span lang="EN-US"><span style="font-family: Times New Roman;" face="Times New Roman">avaScript</span></span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">设计模式的一种，这种模式在</span><span lang="EN-US"><span style="font-family: Times New Roman;" face="Times New Roman">YUI</span></span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">中用得非常多，</span><span style="font-family: 宋体; mso-ascii-font-family: ''Times New Roman''; mso-hansi-font-family: ''Times New Roman'';">改进的写法是：</span><span lang="EN-US"> <o:p><span style="font-family: Times New Roman;" face="Times New Roman">&nbsp;</span></o:p></span></p>\r\n\r\n<p><span lang="EN-US"><o:p><span style="font-family: Times New Roman;" face="Times New Roman">\r\n\r\n</span></o:p></span></p>\r\n\r\n<div class="cnblogs_Highlighter">\r\n\r\n<pre class="brush:javascript">var myApplication = function(){\r\n  var name = ''Chris'';\r\n  var age = ''34'';\r\n  var status = ''single'';\r\n  function createMember(){\r\n    // [...]\r\n  }\r\n  function getMemberDetails(){\r\n    // [...]\r\n  }\r\n  return{\r\n    create:createMember,\r\n    get:getMemberDetails\r\n  }\r\n}();\r\n//myApplication.get() and myApplication.create() now work.\r\n</pre>\r\n\r\n</div>\r\n\r\n\r\n\r\n<p><span style="font-size: 12px;">&nbsp;&nbsp; </span></p>\r\n\r\n<p><strong><span style="font-size: 14pt;">（</span></strong><span style="font-size: 14pt;">6</span><strong><span style="font-size: 14pt;">）代码可配置</span></strong></p>\r\n\r\n<p><span style="font-size: 12px;">\r\n\r\n</span></p>\r\n\r\n<hr class="title_line" />\r\n\r\n\r\n\r\n<p><span>你写的代码如果想让别人更容易进行使用或者修改，则需要可配置，解决方案是在你写的脚本中增加一个配置对象。要点如下：&nbsp;<br />&nbsp;<br />1、在你的脚本中新增一个叫configuration的对象。</span></p>\r\n\r\n<p><span>2、在配置对象中存放所有其它人可能想要去改变的东西，例如CSS的ID、class名称、语言等等。</span></p>\r\n\r\n<p><span>3、返回这个对象，作为公共属性以便其它人可以进行重写。&nbsp;</span></p>\r\n\r\n\r\n\r\n<p><strong><span>（</span></strong><span style="font-size: 14pt;">7</span><strong><span style="font-size: 14pt;">）代码兼容性</span></strong></p>\r\n\r\n<hr class="title_line" />\r\n\r\n\r\n\r\n<p><span>　　兼容性是初学者容易忽略的部分，通常学习Javascript的时候都是在某个固定的浏览器中进行测试，而这个浏览器很有可能就是IE，这是非常致命的，因为目前几大主流浏览器中偏偏IE对标准的支持是最差的。最终用户看到的结果也许就是，你写的代码在某个浏览器无法正确运行。你应该把你的代码在主流的浏览器中都测试一下，这也许很费时间，但是应该这样做。&nbsp;</span><span style="font-size: 12px;">&nbsp;</span></p>\r\n\r\n\r\n<p>（编译来源：<a href="http://www.cnblogs.com/lhb25/"><span style="color: #6466b3;" color="#6466b3">梦想天空</span></a>&nbsp; 原文来自：<a href="http://www.smashingmagazine.com/2010/04/20/seven-javascript-things-i-wish-i-knew-much-earlier-in-my-career/" target="_blank">Seven JavaScript Things I Wish I Knew Much Earlier In My Career</a>）</p>\r\n', 'JavaScript', '', '2011-05-13 9:21:45'),
(581, '你可能不知道的10个JavaScript小技巧', '<p style="text-align: justify;">　　尽管我使用Javascript来做开发有很多年了，但它常有一些让我很惊讶的小特性。对于我来说，Javascript是需要持续不断的学习的。在这篇文章中，我将列出10个Javascript使用小技巧，主要面向Javascript新手和中级开发者。希望每个读者都能至少从中学到一个有用的技巧。</p>\r\n\r\n<h3 style="color: blue;">1.变量转换</h3>\r\n<p style="text-align: justify;">看起来很简单，但据我所看到的，使用构造函数，像Array()或者Number()来进行变量转换是常用的做法。始终使用原始数据类型（有时也称为字面量）来转换变量，这种没有任何额外的影响的做法反而效率更高。</p>\r\n<pre class="brush:js;ruler:true;">var myVar   = "3.14159",\r\nstr     = ""+ myVar,//  to string\r\nint     = ~~myVar,  //  to integer\r\nfloat   = 1*myVar,  //  to float\r\nbool    = !!myVar,  /*  to boolean - any string with length\r\nand any number except 0 are true */\r\narray   = [myVar];  //  to array\r\n</pre>\r\n\r\n<p style="text-align: justify;">转换日期(new Date(myVar))和正则表达式(new RegExp(myVar))必须使用构造函数，而且创建正则表达式的时候要使用/pattern/flags的形式。</p>\r\n\r\n<p><!--more--></p>\r\n\r\n<h3 style="color: blue;">2.十进制转换为十六进制或者八进制，或者反过来</h3>\r\n\r\n<p>你是不是写个单独的函数来转换十六进制（或者八进制）呢？马上停下吧！有更容易的现成的函数可以用：</p>\r\n\r\n<pre class="brush:js;ruler:true;">(int).toString(16); // converts int to hex, eg 12 =&gt; "C"\r\n(int).toString(8);  // converts int to octal, eg. 12 =&gt; "14"\r\nparseInt(string,16) // converts hex to int, eg. "FF" =&gt; 255\r\nparseInt(string,8) // converts octal to int, eg. "20" =&gt; 16\r\n</pre>\r\n\r\n<h3 style="color: blue;">3.玩转数字</h3>\r\n\r\n<p>除了上一节介绍的之外，这里有更多的处理数字的技巧</p>\r\n\r\n<pre class="brush:js;ruler:true;">0xFF; // Hex declaration, returns 255\r\n020; // Octal declaration, returns 16\r\n1e3; // Exponential, same as 1 * Math.pow(10,3), returns 1000\r\n(1000).toExponential(); // Opposite with previous, returns 1e3\r\n(3.1415).toFixed(3); // Rounding the number, returns "3.142"\r\n</pre>\r\n\r\n<h3 style="color: blue;">4.Javascript版本检测</h3>\r\n\r\n<p>你知道你的浏览器支持哪一个版本的Javascript吗？如果不知道的话，去维基百科查一下Javascript版本表吧。出于某种原因，Javascript 1.7版本的某些特性是没有得到广泛的支持。不过大部分浏览器都支持了1.8版和1.8.1版的特性。（注：所有的IE浏览器（IE8或者更老的版本）只支持1.5版的Javascript）这里有一个脚本，既能通过检测特征来检测JavaScript版本，它还能检查特定的Javascript版本所支持的特性。</p>\r\n\r\n<pre class="brush:js;ruler:true;">var JS_ver  = [];\r\n(Number.prototype.toFixed)?JS_ver.push("1.5"):false;\r\n([].indexOf &amp;&amp; [].forEach)?JS_ver.push("1.6"):false;\r\n((function(){try {[a,b] = [0,1];return true;}catch(ex) {return false;}})())?JS_ver.push("1.7"):false;\r\n([].reduce &amp;&amp; [].reduceRight &amp;&amp; JSON)?JS_ver.push("1.8"):false;\r\n("".trimLeft)?JS_ver.push("1.8.1"):false;\r\nJS_ver.supports = function()\r\n{\r\n　　if (arguments[0])\r\n　　　　return (!!~this.join().indexOf(arguments[0] +",") +",");\r\n　　else\r\n　　　　return (this[this.length-1]);\r\n}\r\nalert("Latest Javascript version supported: "+ JS_ver.supports());\r\nalert("Support for version 1.7 : "+ JS_ver.supports("1.7"));\r\n</pre>\r\n\r\n<h3 style="color: blue;">5.使用window.name进行简单会话处理</h3>\r\n\r\n<p>这个是我真的喜欢的东西。您可以为指定一个字符串作为window.name属性的值，直到您关闭该标签或窗口。虽然我没有提供任何脚本，但我强烈建议您如充分利用这个方法。举例来说，在建设一个网站或应用程序的时候，在调试和测试模式之间切换是非常有用的。</p>\r\n\r\n<h3 style="color: blue;">6.判断属性是否存在</h3>\r\n\r\n<p>这个问题包含两个方面，既有检查属性时候存在，还要获取属性的类型。但我们总是忽略了这些小事情:</p>\r\n\r\n<pre class="brush:js;ruler:true;">// BAD: This will cause an error in code when foo is undefined\r\nif (foo) {\r\n　　doSomething();\r\n}\r\n// GOOD: This doesn''t cause any errors. However, even when\r\n// foo is set to NULL or false, the condition validates as true\r\nif (typeof foo != "undefined") {\r\n　　doSomething();\r\n}\r\n// BETTER: This doesn''t cause any errors and in addition\r\n// values NULL or false won''t validate as true\r\nif (window.foo) {\r\n　　doSomething();\r\n}\r\n</pre>\r\n\r\n<p>但是，有的情况下，我们有更深的结构和需要更合适的检查的时候，可以这样：</p>\r\n\r\n<pre class="brush:js;ruler:true;">// UGLY: we have to proof existence of every\r\n// object before we can be sure property actually exists\r\nif (window.oFoo &amp;&amp; oFoo.oBar &amp;&amp; oFoo.oBar.baz) {\r\n　　doSomething();\r\n}\r\n</pre>\r\n\r\n<h3 style="color: blue;">7.给函数传递参数</h3>\r\n\r\n<p>当函数既有必选又有可选参数的时候，我们可能是这样做的：</p>\r\n\r\n<pre class="brush:js;ruler:true;">function doSomething(arg0, arg1, arg2, arg3, arg4) {\r\n　　...\r\n}\r\ndoSomething('''', ''foo'', 5, [], false);\r\n</pre>\r\n\r\n<p>而传递一个对象总是比传递一堆的参数更方便：</p>\r\n\r\n<pre class="brush:js;ruler:true;">function doSomething() {\r\n　　// Leaves the function if nothing is passed\r\n　　if (!arguments[0]) {\r\n　　return false;\r\n　　}\r\n　　var oArgs   = arguments[0]\r\n　　arg0    = oArgs.arg0 || "",\r\n　　arg1    = oArgs.arg1 || "",\r\n　　arg2    = oArgs.arg2 || 0,\r\n　　arg3    = oArgs.arg3 || [],\r\n　　arg4    = oArgs.arg4 || false;\r\n}\r\ndoSomething({\r\n　　arg1    : "foo",\r\n　　arg2    : 5,\r\n　　arg4    : false\r\n});\r\n</pre>\r\n\r\n<p>这只是一个把对象作为参数传递的一个很简单的例子，例如，我们还可以声明一个对象，变量名作为Key，默认值作为Value。</p>\r\n\r\n<h3 style="color: blue;">8.使用document.createDocumentFragment()</h3>\r\n\r\n<p>您可能需要动态地追加多个元素到文档中。然而，直接将它们插入到文档中会导致这个文档每次都需要重新布局一个，相反的，你应该使用文档碎片，建成后只追加一次：</p>\r\n\r\n<pre class="brush:js;ruler:true;">function createList() {\r\n　　var aLI = ["first item", "second item", "third item",\r\n　　"fourth item", "fith item"];\r\n　　// Creates the fragment\r\n　　var oFrag   = document.createDocumentFragment();\r\n　　while (aLI.length) {\r\n　　　　var oLI = document.createElement("li");\r\n　　　　// Removes the first item from array and appends it\r\n　　　　// as a text node to LI element\r\n　　　　oLI.appendChild(document.createTextNode(aLI.shift()));\r\n　　　　oFrag.appendChild(oLI);\r\n　　}\r\n　　document.getElementById(''myUL'').appendChild(oFrag);\r\n}\r\n\r\n</pre>\r\n\r\n<h3 style="color: blue;">9.为replace()方法传递一个函数</h3>\r\n\r\n<p>有的时候你想替换字符串的某个部分为其它的值，最好的方法就是给String.replace()传递一个独立的函数。下面是一个简单例子：</p>\r\n\r\n<pre class="brush:js;ruler:true;">var sFlop   = "Flop: [Ah] [Ks] [7c]";\r\nvar aValues = {"A":"Ace","K":"King",7:"Seven"};\r\nvar aSuits  = {"h":"Hearts","s":"Spades",\r\n"d":"Diamonds","c":"Clubs"};\r\nsFlop   = sFlop.replace(/\\[\\w+\\]/gi, function(match) {\r\n　　match   = match.replace(match[2], aSuits[match[2]]);\r\n　　match   = match.replace(match[1], aValues[match[1]] +" of ");\r\n　　return match;\r\n});\r\n// string sFlop now contains:\r\n// "Flop: [Ace of Hearts] [King of Spades] [Seven of Clubs]"\r\n</pre>\r\n\r\n<h3 style="color: blue;">10.循环中标签的使用</h3>\r\n\r\n<p>有的时候，循环中又嵌套了循环，你可能想在循环中退出，则可以用标签：</p>\r\n\r\n<pre class="brush:js;ruler:true;">outerloop:\r\nfor (var iI=0;iI&lt;5;iI++) {\r\n　　if (somethingIsTrue()) {\r\n　　// Breaks the outer loop iteration\r\n　　break outerloop;\r\n　　}\r\n　　innerloop:\r\n　　for (var iA=0;iA&lt;5;iA++) {\r\n　　　　if (somethingElseIsTrue()) {\r\n　　　　// Breaks the inner loop iteration\r\n　　　　break innerloop;\r\n　　}\r\n　　}\r\n}</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>英文来源：<a target="_blank" href="http://samuli.hakoniemi.net/10-small-things-you-may-not-know-about-javascript/"><span style="color: #285a86;">10 Small Things You May Not Know About Javascript</span></a> </p>', 'JavaScript', '', '2011-05-13 9:27:44'),
(582, 'javascript作用域链(Scope Chain)初探', '<p><a href="http://www.cnblogs.com/jeffwongishandsome/archive/2009/05/17/1457674.html">http://www.cnblogs.com/jeffwongishandsome/archive/2009/05/17/1457674.html</a></p>\r\n<h2>浅析JS运行机制</h2>\r\n<p><a href="http://www.jz123.cn/text/0811925.html">http://www.jz123.cn/text/0811925.html  </a></p>\r\n<p><a href="http://hi.baidu.com/lcgg110/blog/item/37534980d0c6bfc39023d925.html">http://hi.baidu.com/lcgg110/blog/item/37534980d0c6bfc39023d925.html  </a></p>\r\n<p><a href="http://www.huachu.com.cn/read/readbookinfo.asp?sectionid=1000000612">http://www.huachu.com.cn/read/readbookinfo.asp?sectionid=1000000612 </a></p>', 'JavaScript', '', '2011-05-14 11:43:08'),
(583, 'oncontextmenu(右键菜单)', '<pre title="code" class="brush: jscript;">\r\ndocument.oncontextmenu=function(evt){\r\n	if(document.all){\r\n		evt=window.event;\r\n		evt.returnValue=false;\r\n	}else{\r\n		evt.preventDefault();\r\n	}\r\n	alert(''右键没什么'')\r\n}</pre>', 'JavaScript', '', '2011-05-14 19:10:23'),
(584, '解析url地址参数', '<pre title="code" class="brush: jscript;">\r\nvar url=''http://www.pps.tv?cat_id=1232322&amp;pid=45678&amp;name=louxiaojian''\r\nfunction QueryString(val){\r\n	  //var svalue = url.search.match(new RegExp(&quot;[\\?\\&amp;]&quot; + val + &quot;=([^\\&amp;]*)(\\&amp;?)&quot;, &quot;i&quot;));//正则解析当前文件url\r\n	  var svalue = url.match(new RegExp(&quot;[\\?\\&amp;]&quot; + val + &quot;=([^\\&amp;]*)(\\&amp;?)&quot;, &quot;i&quot;));\r\n	  return svalue ? svalue[1] : &quot;&quot;;\r\n}\r\n var catid =(QueryString(&quot;cat_id&quot;));//获取cat_id的值\r\n var pid = (QueryString(&quot;pid&quot;));//获取pid的值\r\n var name = (QueryString(&quot;name&quot;));//获取pid的值\r\n alert(catid)\r\n alert(pid)\r\n alert(name)</pre>', 'JavaScript', '', '2011-05-15 10:38:27'),
(587, '如何将函数的实际参数转换成数组', '<p><a target="_blank" href="http://www.planabc.net/2010/01/06/arguments_to_array/">http://www.planabc.net/2010/01/06/arguments_to_array/ </a></p>\r\n<p>实际参数在函数中我们可以使用 <code>arguments</code> 对象获得 （注：形参可通过 <code>arguments.callee</code> 获得），虽然 <code>arguments</code> 对象与数组形似，但仍不是真正意义上的数组。</p>\r\n<p>值得庆幸的是，我们可以通过数组的 <code>slice</code> 方法将 <code>arguments</code> 对象转换成真正的数组：</p>\r\n<script>\r\n    var args = Array.prototype.slice.call(arguments, 0);\r\n</script>\r\n<p>对于<code>slice</code> 方法，<a title="ECMAScript" target="_blank" href="http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf">ECMAScript 262</a> 中 15.4.4.10 Array.prototype.slice (start, end) 章节有备注：</p>\r\n<p>The slice function is intentionally generic; it does not require that its this value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method. Whether the slice function can be applied successfully to a host object is implementation-dependent.</p>\r\n<p><a target="_blank" title="Pro JavaScript Design Patterns" href="http://jsdesignpatterns.com/">《Pro JavaScript Design Patterns》</a>（《JavaScript 设计模式》）的作者 <a title="Dustin Diaz: ./with Imagination" target="_blank" href="http://www.dustindiaz.com/">Dustin Diaz</a> 曾指出：</p>\r\n<p>instead of&hellip;<br />\r\nvar args = Array.prototype.slice.call(arguments, 0); // 怿飞注：下称方法一<br />\r\ndo this&hellip;<br />\r\nvar args = [].slice.call(arguments, 0); // 怿飞注：下称方法二</p>\r\n<p>但二者的性能差异真的存在吗？经过个人简单测试发现：</p>\r\n<p><del datetime="2010-01-30T07:44:07+00:00">在 <code>arguments.length</code> 较小的时候，方法二性能上稍有一点点优势，而在<code>arguments.length</code> 较大的时候，方法一却又稍有优势。</del></p>\r\n<p>2010年1月30日更新（<a target="_blank" href="http://www.planabc.net/demo/toarray/arguments.html">测试地址</a>）：几经验证，性能差异不大，反而第一张方法性能稍优势一点，或许由于第二种方法创建新数组产生开销。</p>\r\n<p>最后附上方法三，最老土的方式：</p>\r\n<pre class="brush:js;ruler:true;">\r\nvar args = [];\r\nfor (var i = 1; i &lt; arguments.length; i++) {\r\n    args.push(arguments[i]);\r\n}\r\n</pre>\r\n<p>不过对于平常来说，个人建议使用第一种方法，但任何解决方案，没有最好的，只有最合适：</p>\r\n<pre><code>var args = Array.prototype.slice.call(arguments, 0); </code></pre>\r\n<p>------------------------------------------------------------------</p>\r\n<p><strong>如何将 <a target="_blank" title="NodeList" href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-536297177">NodeList</a> （比如：document.getElementsByTagName(''div'')）转换成数组呢？</strong></p>\r\n<p>解决方案简单如下：</p>\r\n<pre class="brush:js;ruler:true;">\r\nfunction nodeListToArray(nodes){\r\n    var arr, length;\r\n\r\n    try {\r\n        // works in every browser except IE\r\n        arr = [].slice.call(nodes);\r\n        return arr;\r\n    } catch(err){\r\n        // slower, but works in IE\r\n        arr = [];\r\n        length = nodes.length;\r\n\r\n        for(var i = 0; i &lt; length; i++){\r\n            arr.push(nodes[i]);\r\n        }\r\n        return arr;\r\n    }\r\n}\r\n</pre>\r\n<p>为什么 IE 中 NodeList 不可以使用 [].slice.call(nodes) 方法转换呢？</p>\r\n<p><strong>In Internet Explorer it throws an error that it can''t run Array.prototype.slice.call(nodes) because a DOM NodeList is not a JavaScript object.</strong></p>', 'JavaScript', '1', '2011-05-21 11:51:59');
INSERT INTO `list` (`id`, `title`, `content`, `cat`, `marrow`, `time`) VALUES
(588, '所谓的javascript高级技巧', '<p>http://www.ilovejs.net/archives/1232</p>\r\n<p>Js学的也差不多了，该是来总结一下Js中一些比较高级的智慧结晶了。基于Js的动态性、对象都是易变的、函数是第一对象等等其他语言所不包含的特性，可以在使用Js的时候创造出更高效、组织性更好的代码。下面提到的一些概念，是不是很熟悉：</p>\r\n<p>分支、惰性实例化、惰性载入函数、单例的两种模式、享元类、函数绑定（纠正函数一个执行上下文）、函数curry化、高级定时器、保护上下文的构造函数、函数节流、自定义事件&hellip;&hellip;</p>\r\n<p>js中的继承、原型、构造函数这些都是老生常谈的了。但是对于构造函数式继承和原型式继承的优缺点，还是有必要了解一下的。原型式继承的主要优点就是共享方法和属性，使得从原型对象中继承出来的子对象都可以在内存中共享全部的方法和属性，这如果是在大型的继承链中将会大大的改善性能和减少内存的使用量。</p>\r\n<p>&nbsp;</p>\r\n<p>接下来看看上面所罗列的每一个所谓的&ldquo;高级&rdquo;技巧的具体细节咧：</p>\r\n<ol>\r\n    <li><b>惰性实例化</b><br />\r\n    惰性实例化所要解决的问题是这样的：避免了在页面中js初始化执行的时候就实例化了类，如果在页面中没有使用到这个实例化的对象，那么这就造成了一定的内存的浪费和性能的消耗，那么如果将一些类的实例化推迟到需要使用它的时候才开始去实例化，那么这就避免了刚才说的问题，做到了&ldquo;按需供应&rdquo;，简单代码示例如下：\r\n    <p>&nbsp;</p>\r\n    <pre class="brush: jscript;">\r\n \r\nvar myNamespace = function(){\r\n   var Configure = function(){\r\n     var privateName = &quot;someone''s name&quot;;\r\n	 var privateReturnName = function(){\r\n	   return privateName;\r\n	 }\r\n	 var privateSetName = function(name){\r\n	   privateName = name;\r\n	 }\r\n	 //返回单例对象\r\n	 return {\r\n	   setName:function(name){\r\n	     privateSetName(name);\r\n	   },\r\n	   getName:function(){\r\n	     return privateReturnName();\r\n	   }\r\n	 }\r\n   }\r\n   //储存configure的实例\r\n   var instance;\r\n \r\n   return {\r\n     getInstance:function(){\r\n	   if(!instance){\r\n	     instance = Configure();\r\n	   }\r\n	   return instance;\r\n	 }\r\n   }\r\n}();\r\n//使用方法上就需要getInstance这个函数作为中间量了：\r\nmyNamespace.getInstance().getName();\r\n</pre>\r\n    <p>上面的就是简单的惰性实例化的示例，但是有一点缺点就是需要使用中间量来调用内部的Configure函数所返回的对象的方法（当然也可以使用变量来储存myNamespace.getInstance()返回的实例对象）。将上面的代码稍微修改一下，就可以只用比较得体的方法来使用内部的方法和属性：</p>\r\n    <pre class="brush: jscript;">\r\n \r\n//惰性实例化的变体\r\nvar myNamespace2 = function(){\r\n   var Configure = function(){\r\n     var privateName = &quot;someone''s name&quot;;\r\n	 var privateReturnName = function(){\r\n	   return privateName;\r\n	 }\r\n	 var privateSetName = function(name){\r\n	   privateName = name;\r\n	 }\r\n	 //返回单例对象\r\n	 return {\r\n	   setName:function(name){\r\n	     privateSetName(name);\r\n	   },\r\n	   getName:function(){\r\n	     return privateReturnName();\r\n	   }\r\n	 }\r\n   }\r\n   //储存configure的实例\r\n   var instance;\r\n \r\n   return {\r\n     init:function(){\r\n	   //如果不存在实例，就创建单例实例\r\n	   if(!instance){\r\n	     instance = Configure();\r\n	   }\r\n	   //将Configure创建的单例\r\n	   for(var key in instance){\r\n	     if(instance.hasOwnProperty(key)){\r\n		   this[key]=instance[key];\r\n		 }\r\n	   }\r\n	   this.init = null;\r\n	   return this;\r\n	 }\r\n   }\r\n}();\r\n//使用方式：\r\nmyNamespace2.init();\r\nmyNamespace2.getName();\r\n</pre>\r\n    <p>上面修改了自执行函数返回的对象的代码，在获取Configure函数返回的对象的时候，将该对象的方法赋给myNamespace2，这样，调用方式就发生了一点改变了。</p>\r\n    </li>\r\n    <li><b>分支</b><br />\r\n    分支技术解决的一个问题是处理浏览器之间兼容性的重复判断的问题。普通解决浏览器之间的兼容性的方式是使用if逻辑来进行特性检测或者能力检测，来实现根据浏览器不同的实现来实现功能上的兼容，但问题是，没执行一次代码，可能都需要进行一次浏览器兼容性方面的检测，这个是没有必要的，能否在代码初始化执行的时候就检测浏览器的兼容性，在之后的代码执行过程中，就无需再进行检测了呢？答案是有的，分支技术就可以解决这个问题（同样，惰性载入函数也可以实现Lazy Definied，这个在后面将会讲到），下面以声明一个XMLHttpRequest实例对象为例子：\r\n    <p>&nbsp;</p>\r\n    <pre class="brush: jscript;">\r\n \r\n//分支\r\nvar XHR= function(){\r\n  var standard = {\r\n    createXHR : function(){\r\n	  return new XMLHttpRequest();\r\n	}\r\n  }\r\n  var newActionXObject = {\r\n    createXHR : function(){\r\n	  return new ActionXObject(&quot;Msxml2.XMLHTTP&quot;);\r\n	}\r\n  }\r\n  var oldActionXObject = {\r\n    createXHR : function(){\r\n	  return new ActionXObject(&quot;Microsoft.XMLHTTP&quot;);\r\n	}\r\n  }\r\n  if(standard.createXHR()){\r\n    return standard;\r\n  }else{\r\n    try{\r\n	  newActionXObject.createXHR();\r\n	  return newActionXObject;\r\n	}catch(o){\r\n	  oldActionXObject.createXHR();\r\n	  return oldActionXObject;\r\n	}\r\n  }\r\n}();\r\n</pre>\r\n    <p>从上面的例子可以看出，分支的原理就是：声明几个不同名称的对象，但是给这些对象都声明一个名称相同的方法（这个就是关键），并给这些来自于不同的对象但是拥有相同的方法进行浏览器之间各自的实现，接着就开始进行一次浏览器检测，并经过浏览器检测的结果来决定返回哪一个对象，这样不论返回的是哪一个对象，最后名称相同的方法都作为了对外一致的接口。</p>\r\n    <p>这个是在Javascript运行期期间进行动态检测，并将检测的结果返回赋值给其他的对象，并提供相同的接口，这样储存的对象就可以使用名称相同的接口了。其实，惰性载入函数跟分支在原理是非常相近的，只是在代码实现方面有差异而已。</p>\r\n    </li>\r\n    <li><b>惰性载入函数</b><br />\r\n    惰性载入函数就是英文中传说的&ldquo;Lazy Defined&rdquo;，它的主要解决的问题也是为了处理兼容性。原理跟分支类似，下面是简单的代码示例：\r\n    <p>&nbsp;</p>\r\n    <pre class="brush: jscript;">\r\n \r\nvar addEvent = function(el,type,handle){\r\n  addEvent = el.addEventListener ? function(el,type,handle){\r\n    el.addEventListener(type,handle,false);\r\n  }:function(el,type,handle){\r\n    el.attachEvent(&quot;on&quot;+type,handle);\r\n  };\r\n  //在第一次执行addEvent函数时，修改了addEvent函数之后，必须执行一次。\r\n  addEvent(el,type,handle);\r\n}\r\n</pre>\r\n    <p>从代码上看，惰性载入函数也是在函数内部改变自身的一种方式，这样之后，当重复执行的时候，就不会再进行兼容性方面的检测了。</p>\r\n    </li>\r\n    <li><b>单例的两种模式</b><br />\r\n    单例模式是家喻户晓的了，也是当前最流行的一种编写方式，注明的模块模式的编写方式也是从这个思想中衍生出来的。单例模式有两种方式：一种是所谓的&ldquo;门户大开型&rdquo;，另外一种就是使用闭包来创建私有属性和私有方法的方式。第一种方式跟构造函数的&ldquo;门户大开型&rdquo;是一个样的，声明的方法和属性对外都是开放的，可以通过实例来调用。但是使用闭包来实现的单例模式，可以在一个&ldquo;封闭&rdquo;的作用域内声明一些不为外部所调用的私有属性和私有方法，而且还有一个很主要的功能，就是私有属性可以作为一个&ldquo;数据存储器&rdquo;，在闭包内声明的方法都可以访问这些私有属性，但是外部不可访问。那么重复添加、修改、删除这些私有属性所储存的数据是安全的，不受外部其他程序的影响。</li>\r\n    <li><b>享元类</b><br />\r\n    顾名思义，&ldquo;享&rdquo;、&ldquo;元&rdquo;。就是共享通用的方法和属性，将差异比较大的类中相同功能的方法集中到一个类中声明，这样需要这些方法的类就可以直接从享元类中进行扩展，这样使得这样通用的方法只需要声明一遍就行了。这个从代码的大小、质量来说还是有一定的效益的。</li>\r\n    <li><b>函数绑定</b><br />\r\n    函数绑定就是为了纠正函数的执行上下文，特别是函数中带有this关键字的时候，这点尤其显得重要，稍微不小心，使得函数的执行上下文发生了跟预期的不同的改变，导致了代码执行上的错误（有时候也不会出现错误，这样调试起来，会很变态）。对于这个问题，bind函数是再熟悉不过的了，bind函数的功能就是提供一个可选的执行上下文传递给函数，并且在bind函数内部返回一个函数，来纠正在函数调用上出现的执行上下文发生的变化。最容易出现的错误就是回调函数和事件处理程序一起使用了，下面是摘自《Javascript高级程序设计第二版》的一个示例：\r\n    <p>&nbsp;</p>\r\n    <pre class="brush: jscript;">\r\n \r\nvar handler = {\r\n  message:&quot;Event handler&quot;,\r\n  handlerClick:function(e){\r\n    alert(this.message);\r\n  }\r\n}\r\nvar btn = document.getElementById(&quot;my-btn&quot;);\r\n//这句就造成了回调函数执行上下文的改变了\r\nEventUtil.addHandler(btn,&quot;click&quot;,handler.handlerClick);\r\n</pre>\r\n    <p>解决的办法之一，就是纠正一下handler.handlerClick执行的上下文环境，改为：</p>\r\n    <pre class="brush: jscript;">\r\n \r\n//这样运行的很好\r\nEventUtil.addHandler(btn,&quot;click&quot;,function(e){\r\n  handler.handlerClick(e);\r\n});\r\n</pre>\r\n    <p>上面就很好的纠正了回调函数的执行上下文了。而且，也可以使用传说中的bind函数来解决：</p>\r\n    <pre class="brush: jscript;">\r\n \r\nvar bind = function(fn,context){\r\n  return function(){\r\n     return fn.apply(context || this,arguments);\r\n  }\r\n}\r\nEventUtil.addHandler(btn,&quot;click&quot;,bind(handler.handlerClick));// So Good！\r\n</pre>\r\n    </li>\r\n    <li><b>函数curry化</b><br />\r\n    函数curry化的主要功能就是提供了强大的动态函数创建的功能。通过调用另一个函数并为它传入要curry的函数和必要的参数。说白点就是利用已有的函数，再创建一个动态的函数，该动态的函数内部还是通过该已有的函数来发生作用，只是传入更多的参数来简化函数的参数方面的调用。具体示例：\r\n    <p>&nbsp;</p>\r\n    <pre class="brush: jscript;">\r\n \r\n//curry function\r\nfunction curry(fn){\r\n  var args = [].slice.call(arguments,1); //这个就相当于一个存储器了。\r\n  return function(){\r\n    return fn.apply(null,args.concat([].slice.call(arguments,0)));\r\n  }\r\n}\r\n//Usage:\r\nfunction add(num1,num2){\r\n  return num1+num2;\r\n}\r\nvar newAdd = curry(add,5);\r\nalert(newAdd(6));\r\n</pre>\r\n    <p>在curry函数的内部，私有变量args就相当于一个存储器，来暂时的存储在curry函数调用的时候所传递的参数值，这样跟后面的动态创建的函数调用的时候的参数合并，并执行，就得到了一样的效果了。</p>\r\n    </li>\r\n    <li><b>高级定时器</b><br />\r\n    提到定时器，无非就是利用setTimeout/setInterval了。但问题是定时器并不是相当于新开一个线程来执行js程序，也不会说是在指定的时间间隔内就会一定执行。指定的时间间隔表示何时将定时器的代码添加到浏览器的执行队列，而不是合适实际执行代码。对此，就有这样的一个问题了：如果代码执行时间超过了定时器指定的时间间隔，那么在指定的时间里代码还是加入的执行队列，但是并没有执行，这样就会造成了无意义的代码执行，这也是使用setInterval的弊端。为此，使用setTimeout才能更好的避免这个问题，在代码本身中执行完毕了，再通过setTimeout来重新设定定时器，把代码加入到执行队列。比如：\r\n    <p>&nbsp;</p>\r\n    <pre class="brush: jscript;">\r\n \r\nsetTimeout(function(){\r\n  //many code here...\r\n  setTimeout(arguments.callee,100); //Key\r\n},100);\r\n</pre>\r\n    <p>当然了，定时器还有很多其他的技巧和实际作用，看需求而定，更详细的解释可以查看《Javascript高级程序设计第二版》（第467页）。</p>\r\n    </li>\r\n    <li><b>保护上下文的构造函数</b><br />\r\n    这个主要是避免构造函数在没有使用new来实例化的时候，内部的this指向错误问题。通常没有使用new的话，this一般执行window去了，因此造成了执行错误，给代码带来了灾难。使用下面的方式就可以避免这个问题：\r\n    <p>&nbsp;</p>\r\n    <pre class="brush: jscript;">\r\n \r\nfunction myClass(name,size){\r\n  if(this instanceof myClass){  //Key,使用instanceof来检测当前实例是否是myClass的实例化对象\r\n    this.name = name;\r\n    this.size = size;\r\n }else{\r\n    return new myClass(name,size);\r\n  }\r\n}\r\n</pre>\r\n    <p>但是上面通过instanceof的方式，给继承造成了一定的困扰，因为子类并不是myClass的实例对象，所以会出现属性和方法无法被继承的方式。在说解决办法之前，先来了解一下instanceof操作符的原理：它首先会检测对象当前的原型是否指向右边的构造函数，如果找不到，就会往上一级的原型去查找，直到找到为止，并返回true，否则就返回false。</p>\r\n    <p>基于上面的instanceof的原理，在继承的时候，就可以给子类的prototype原型赋于一个父类的实例化对象就行了，这样就可以在子类继承的时候绕过instanceof的检测。</p>\r\n    </li>\r\n    <li><b>函数节流</b>\r\n    <p>函数节流函数节流解决的问题是一些代码（特别是事件）在无间断的执行，这严重的影响了浏览器的性能，再没有给它设定间断来执行的话，可能造成浏览器反应速度变慢或者直接就崩溃了。比如：resize事件、mousemove、mouseover、mouseout等等事件。</p>\r\n    <p>这个时候，就可以加入定时器的功能了，将事件进行&ldquo;节流&rdquo;，即是：在事件触发的时候，设定一个定时器来执行事件处理程序，这样可以很大的程度上缓解浏览器的负担，又缓冲的余地去更新页面。具体的实例可以查看支付宝中部&ldquo;导购场景&rdquo;的导航：<a href="http://life.alipay.com/?src=life_alipay_index_big">http://life.alipay.com/?src=life_alipay_index_big</a>，以及当当网首页左边的导航栏：<a href="http://www.dangdang.com/">http://www.dangdang.com/</a>等等，这些都是为了解决mouseover和mouseout移动过快的时候加大浏览器处理的负担，特别是在涉及到有Ajax调用，而且Ajax调用是么有缓存的情况下，给服务器也造成了很大的负担。为此，函数节流就派上用场了。比如简单的示例如下（出自本人写的：<a href="http://www.ilovejs.net/lab/tween/tweener_tab_modify.html">http://www.ilovejs.net/lab/tween/tweener_tab_modify.html</a>）：</p>\r\n    <pre class="brush: jscript;">\r\n \r\noTrigger.onmouseover=function(e){\r\n  //如果上一个定时器还没有执行，则先清除掉定时器\r\n  oContainer.autoTimeoutId &amp;&amp; clearTimeout(oContainer.autoTimeoutId);\r\n  e = e || window.event;\r\n  var target = e.target || e.srcElement;\r\n  if((/li$/i).test(target.nodeName)){\r\n    oContainer.timeoutId = setTimeout(function(){\r\n      addTweenForContainer(oContainer,oTrigger,target);\r\n    },300);\r\n   }\r\n}\r\n</pre>\r\n    <p>&nbsp;</p>\r\n    </li>\r\n    <li><b>自定义事件</b>\r\n    <p>首先要说的是，这里并不是说自定义事件可以真的自定义跟mouseout、click等一样性质的&ldquo;事件&rdquo;。这里的自定义事件在执行的时候还是需要依赖已有的键盘、鼠标、HTML等事件来执行，或者又其他函数&ldquo;触发&rdquo;执行，这里的&ldquo;触发&rdquo;是指直接调用自定义事件中声明的某个接口方法，来轮询的执行全部相关的添加到自定义事件中的函数。</p>\r\n    <p>自定义事件内部有一个&ldquo;事件&rdquo;存储器，根据添加的事件的类型的不同，来储存各类的事件执行函数，这样再出发这类事件的时候，就轮询执行添加到该类型下的函数。&ldquo;自定义事件背后的概念是创建一个管理事件的对象，让其他对象监听那些事件&rdquo;来自《Javascript高级程序设计第二版》的解释。基于自定义事件的原理，可以想象自定义事件很多时候是用于&ldquo;订阅&mdash;发布&mdash;接收&rdquo;性质的功能。</p>\r\n    </li>\r\n</ol>\r\n<p>文章写的有点多了，但是上面介绍的Javascript高级技巧还远不止这些，特别是在Ajax方面的一些模式和技巧都还没有介绍，何况是客户端和服务端结合的一些技巧（比如压缩、Minify、服务器&ldquo;推技术&rdquo;等等）。更多的有待以后了解了介绍一二。</p>\r\n<p>在前端基本技术方面，Javascript、HTML、CSS等大家都是已经掌握的差不多了，但是利用这些已有的基本技术，能否创造出不一般的应用和模式呢？这个才是在掌握了基本的能力之后接下来需要掌握的，比如下面是本人在每天晚上睡觉之前所总结的几点：</p>\r\n<ol>\r\n    <li>学会重构代码的技术，有计划性的重构下自己之前所编写过的一些代码，加强自己掌控代码的能力。</li>\r\n    <li>Code review。这里说的review，并不是指个人，而是对团队来说的，一个人编写的代码的想象空间有限，如果在自己编写代码完成之后，邀请其他团队内的伙伴来查看你的代码，及时发现问题以及提出更好的解决方案，这也不失为一种即时重构的方式，提高代码的质量。</li>\r\n    <li>编写具体的功能代码之前，首先设计代码、规划代码、组织代码的模式。</li>\r\n    <li>在代码的质量、性能、大小之间能作出合理的权衡。</li>\r\n    <li>编写阅读性良好、一目了然、扩展性、可维护性良好、重复利用的代码，也是一门艺术。</li>\r\n    <li>关注web前端的性能优化，包括Javascript、HTML、CSS、客户端、服务端、前端、后端等整体性的优化。</li>\r\n    <li>最后一点或许也是最重要的：善于总结。这点比上面的任何一点都来的重要，因为上面的每一点都是出自这点的积累。</li>\r\n</ol>\r\n<p>上面我总结的几点，也是后期自己要着重提高的能力，当然了，在实际的编码方面，还有很多的东西还需要去挖掘和了解。继续革命吧，将互联网革命进行到底&hellip;&hellip;</p>', 'JavaScript', '', '2011-05-21 11:52:23'),
(589, '[翻译] 十条js代码优化原则', '<p>http://www.ilovejs.net/archives/1336</p>\r\n<p>网上看到的一篇文章，说的是js脚本优化的十条细则，看了下文章，优化的知识都很普通，搞前端的人都知道，罗列一下，增强记忆吧：</p>\r\n<ol>\r\n    <li>定义局部变量。对于当前函数作用域内，如果需要使用这个作用域外部的一些变量，那么就尽量使用局部变量储存外部的变量吧，特别是对于嵌套多级的作用域查询，这个耗时也是比较严重的。还有就是获取DOM节点、NodeList、HTMLCollection等等，可以将NodeList、HTMLCollection转化为数组的形式进行操作，减少DOM即时更新所造成的性能消耗。</li>\r\n    <li>不要使用with语句。with语句会在当前作用域下面增加作用域链，造成当前作用域下面变量的遍历性能消耗更大。</li>\r\n    <li>对于闭包的使用，节省点，不要太过多了。闭包就是提供一个所谓的&ldquo;封闭式&rdquo;的作用域，只允许向包含它向别人访问，而不允许别人访问它。但是声明一个闭包的代价比声明普通的函数的代价是要更高的，况且还有IE下内存泄漏的危险。</li>\r\n    <li>获取字面量对象的属性和数组的项比获取变量更慢。如果你要获取一些数据的时候，使用变量比用数组、字面量对象的索引来访问来的更快。在循环中经常会需要访问数据，使用变量存储一下，来的更快。</li>\r\n    <li>在数组中不要嵌套的过深。js中没有二维数组的概念，但是可以自己编写一个二维数组，并且可以无限的嵌套下去，json很经常就是这么干的。但是嵌套的越深，访问数组中的项就更难了，级数和性能消耗成正比的。</li>\r\n    <li>少用for-in循环。众所周知，for-in用于遍历对象的属性和方法，它所要消耗比for、while、do-while更多的性能。在for-in循环中，对于每一个循环，javasript需要创建一个函数来处理每一个循环，这就带来这么两个性能问题：函数创建、销毁的过程；这个函数在创建之后，又会储存它直接上级的作用域的活动对象。</li>\r\n    <li>对于循环，合并控制循环的语句，以及控制变量变化方式。在一个控制循环的语句中，比如循环结束条件、索引的递增等等，如果可以优化这些操作，那么对于整个循环的性能是有帮助的。比如对于结束循环条件：for(var i =0;i&lt;10;i++)，每次循环的时候，都要执行：#1 i是否存在；#2 i是否 &lt; 10；#3 i++。优化一下，使用while或者do-while：var i = 9;do { ...} while(i--)，那么这样之后，每一个循环需要执行的操作：#1 i--；#2 i是否为true。这样就对循环条件的执行步骤进行了简化。</li>\r\n    <li>对于HTMLCollection，尽量定义一个数组来储存它。这样可以避免DOM即时更新所造成的影响。</li>\r\n    <li>在操作DOM节点的时候，尽量让它飘了吧。让DOM元素脱离document之后再对它进行操作，最后再重新插回document中，最小化reflow（改变了DOM元素布局性的相关的属性之后就会触发，比如：height、width等）、repaint（改变了DOM元素显示上的变化就会触发，比如：background、color等）所造成的影响。</li>\r\n    <li>改变DOM节点样式的时候，尽量改变DOM元素的class而不是style属性。原因你懂的&hellip;&hellip;</li>\r\n</ol>\r\n<p>规则是死的，不能泛用；规则又是活的，看你是否活学活用，用到思维里去，在你编写代码的时候就可以随手写出符合这些规则的代码。</p>\r\n<p>英文原文：<a href="http://jonraasch.com/blog/10-javascript-performance-boosting-tips-from-nicholas-zakas">http://jonraasch.com/blog/10-javascript-performance-boosting-tips-from-nicholas-zakas</a></p>', '性能', '', '2011-09-18 18:11:16'),
(590, 'WEB性能优化', '<p> \r\n<strong>2010-6-12 Updates:</strong>既然我们通常说道Gzip压缩的效果如何的好（确实很好），那我们就来说一下Gzip压缩的原理吧：当服务器开启了Gzip压缩后，当从服务器加载一个文件的时候，就会将这个文件里相似的字符串临时地替换为规定形式的标记，之后在支持Gzip压缩的浏览器中替换回来并显示到页面上。如果文件里相似或者相同的字符串越多，压缩效果就越好。所以这个对HTML、JS、CSS文件压缩效果非常明显，因为它们的代码中有非常多相似的字符串可以压缩。为了证实这个说法，写了两个测试页面：《<a  href="http://www.ilovejs.net/lab/gzip/gzip1-include.php">Gzip file1</a>》，《<a  href="http://www.ilovejs.net/lab/gzip/gzip2-include.php">Gzip file2</a>》，第一个文件的原始大小为4K左右，第二个为10K左右，而压缩效果明显是第二个压缩的更尽致。<br /> \r\n因此，利用Gzip的压缩原理，可以对文件的内容适当的做些手脚来使得压缩效果更加的尽致。\r\n</p> \r\n<p> \r\n<strong>Updates:外联js文件的时候，给script标签带上async和defer属性</strong><br /> \r\n浏览器正常加载js文件的方式在性能上是比较糟糕的，阻塞了后续资源的加载和渲染，直到js文件加载并执行完毕。而async属性就顾名思义了，它使得js文件的加载和执行是异步的，不会阻塞后续资源的加载：《<a  href="http://www.ilovejs.net/lab/async/">async加载Javascript测试</a>》。当然了，要支持async的浏览器才行。<br /> \r\ndefer首先在IE下支持，最新版的FF等浏览器也相继支持了。它的主要作用是让js延迟加载，而不阻塞后续资源的加载和页面的渲染。这对于支持它的浏览器得到了一定程度的优化，而不支持的会忽略掉这个属性。<br /> \r\n因此，建议同时加上async和defer属性，对大部分的浏览器都得到了优化，而不支持的浏览器也会按照默认的方式加载，何乐而不为呢。\r\n</p> \r\n<p> \r\n昨天分享了些关于Web性能优化的几个方面《<a  href="http://www.ilovejs.net/archives/810">WEB性能优化系列一</a>》，接下来分享下另外的一些优化方面的心得体会，算是续上一篇博文，欢迎指正~\r\n</p> \r\n<p> \r\n因为本文的篇幅较小，就不提供链接目录了，提供PDF格式的文档下载：《<a  href="http://www.ilovejs.net/download/performance/Web Performance series 2.pdf">WEB性能优化系列二</a>》\r\n</p> \r\n<p> \r\n<strong>1. Use efficient CSS selectors：使用高效的CSS选择符</strong><br /> \r\n关于高效的CSS选择符的叙述，很多书籍和网站很多博客都有相关的说明，尤其《<a  href="http://developer.mozilla.org/en/Writing_Efficient_CSS">Writing Efficient CSS for Use in the Mozilla UI</a>》提出了很多的建议以及讲解了CSS引擎解析样式规则的原理。在那本《高性能网站建设进阶指南》中也独立出一章节来讲解高效的CSS选择符。<br /> \r\n当浏览器开始下载HTML内容并解析HTML文档的时候，就会生成一个DOM节点树。而CSS选择符的匹配就是在这个节点树中查询符合条件的元素，并添加样式。当浏览器在解析CSS样式表的时候，它会解析样式表中的每一条样式规则，而不管最后样式规则是否会匹配到元素。<br /> \r\n并且，CSS引擎是从右往左进行解析规则的，所以这里就有几点建议可以用来优化CSS选择符了：</p> \r\n<ol> \r\n<li>避免最右端的选择符选择过多的DOM元素。比如全局选择符“*”，标记符（.hide-scrollbars * {&#8230;}），这些在CSS引擎解析该规则的时候最开始会匹配DOM节点树中太多的节点，这样再往左匹配的时候，造成匹配所用的时间就更长了。所以，右边的选择符匹配的元素越少越好。</li> \r\n<li>对于子选择符或者说是邻近选择符（child-selector:ul > li > a）为什么低效，Google Page Speed做了如下解释：因为浏览器在解析一个选择符其中一步的时候，比如上面的a，首先它要确认它的父元素中存在li元素，同时还要判断li元素是否是a的直接父元素，这就需要两个判断操作，相比于后代选择符（ul li a）来说，它就多花费了一倍的性能消耗来执行每一步的匹配。</li> \r\n<li>避免一些累赘的选择符。比如在class类中增加了标签（div.sidebar），ID也同样。当然了，如果你想要通过这种方式来增加选择符的权重，这个就另当别论了。</li> \r\n<li>对于:hover选择符的选择。:hover选择符在IE7以上的版本的标准模式中都是良好的，但是一旦回退到怪癖模式，就跟IE6一个样了，只认超链接元素。所以总是声明标准的DOCTYPE，可以避免很多不必要的问题发生（推荐使用HTML5的声明方式）。</li> \r\n<li>从CSS引擎的解析原理出发，选择符越简短越好，越明确越好，确保右边的规则不会选择过多的DOM元素。同时，可以的话选择class来代替后代选择符。</li> \r\n</ol> \r\n<p> \r\n<strong>2. Specify a character set early：尽早的声明character</strong><br /> \r\n这点在《<a  href="http://www.ilovejs.net/archives/788">页面中charset的meta声明将如何影响页面加载性能</a>》这篇文章中有详细的介绍，这里就不多说了。\r\n</p> \r\n<p> \r\n<strong>3. Specify image dimensions：声明图片的尺寸</strong><br /> \r\n很多网站页面中对图片都没有明确的声明图片img的尺寸（即：设置img标签的height和width属性为图片的原始大小，或者在CSS中声明，不过最好还是在img标签中直接声明）。明确的在img标签中声明图片的尺寸可以加快浏览器对图片的渲染和布局，从而避免不必要的回流（reflow）和重新渲染（repaint）。<br /> \r\n当浏览器布局页面的时候，它需要循环检查那些元素是可以置换的，比如图片。如果浏览器预先知道了一个可以置换的元素（比如图片）的尺寸，那么就可以使得一些不可置换的元素跟这个可置换元素正常的布局，即使图片还没有加载下来，浏览器就可以开始正常的渲染、布局整个页面。<br /> \r\n但是，如果没有预先声明的尺寸，或者声明的尺寸跟元素的实际尺寸不符，那么一旦这些元素下载下来的时候，浏览器就需要一次回流（reflow）和重新渲染（repaint）的过程。<br /> \r\n因此，为了避免不必要的回流和重新渲染的操作，预先声明图片的宽高，并且这个宽高需要跟图片的实际大小相符，其他可置换元素也一样的原理。\r\n</p> \r\n<p> \r\n<strong>4. Put CSS in the document head：将CSS文件放到head里声明</strong><br /> \r\n将行内样式和CSS文件都放到head部位来声明，可以使得页面能及时的渲染，也能避免不必要的“白屏”和“无样式内容的闪烁”的问题的产生。<br /> \r\n同时还有一点需要说明的是：当使用@import来加载外部样式表的时候，也可能会出现上面提到的“白屏”和“无样式内容的闪烁”的问题，因为采用@import加载样式表的时候，加载顺序是不定的，它有可能使得样式表在最后才加载进来。还有避免样式表后面紧跟script标签所声明的行内脚本。\r\n</p> \r\n<p> \r\n<strong>5. Put Javascript in the document bottom：将脚本文件放到文档的末尾</strong><br /> \r\n这个主要是考虑到正常通过script标签加载Javascript文件的时候，会阻塞后面一切资源的加载。所以尽可能的将Javascript文件都放到文档的末尾来加载，就不会影响页面的渲染进程，但是它仍然对onload事件造成延迟，直到文件下载并执行完毕。《<a  href="http://www.ilovejs.net/lab/loadjs/">http://www.ilovejs.net/lab/loadjs/</a>》这个页面展示了动态加载Javascript文件的方式，可以有效的解决这个延迟问题。<br /> \r\n同时，Javascript文件和样式表文件要按照合理的顺序来加载，避免阻塞样式表加载的问题。\r\n</p> \r\n<p> \r\n<strong>6. Avoid CSS expressions：避免使用CSS expression</strong><br /> \r\n关于css的expression，应用的是比较少的，但是不能说它没有被使用。Css的expression会明显的降低页面渲染的性能，避免使用它会改善IE用户的体验。<br /> \r\nCSS expression是在IE5的时候加进IE中的，使用它可以使得Javascript可以通过一些事件动态的操作CSS中的某些属性，从而来改变document的某些属性。它在IE5到IE7版本之间受支持，IE8声称不再受支持，同时其他浏览器都不支持。<br /> \r\n但是使用CSS expression会造成非常糟糕的性能问题。因为在一些普通细小的操作都可能使得expression重复执行，比如：窗口缩放、鼠标移动等等，反正是触发了reflow的因素都会触发expression，这对IE用户来说，是很恶心的性能问题，严重的阻碍用户跟页面的交互操作，恐怖的就是使得IE崩溃了。\r\n</p> \r\n<p> \r\n<strong>7. Combine external Javascript and CSS：合并外部的Javascript和CSS文件</strong><br /> \r\n这个主要是从最小化HTTP请求这个优化准则来说的，将几个Javascript文件或者几个CSS文件合并成一个文件，再结合Gzip压缩，来优化资源的加载时间。可以浏览这篇文章的说明：《<a  href="http://www.ilovejs.net/archives/449">Javascript,CSS Minify</a>》。\r\n</p> \r\n<p> \r\n<strong>8. Avoid bad requests：避免请求无效的链接</strong><br /> \r\n当我们点击了一个超链接，而这里链接的目的地却是无效的，这个不仅造成了恶心的404状态吗，而且还严重影响了用户体验。通过返回404状态的时候都是比较消耗时间的，因为服务器需要查询整个站点是否有这个链接所执行的资源，到最终重定向到一个404页面。而用户等待了些时间最后得来的，却是一个404 Not Found页面，很恶心的事情。<br /> \r\n因此，当一个站点越来越大，更新快的时候，适时的检查页面的链接是否失效并及时的修正这些无效的链接，这对提高用户体验以及避免页面加载一些无用的字节都是有用的。\r\n</p> \r\n<p> \r\n<strong>9. Minimize redirects：最少化重定向的数量</strong><br /> \r\n重定向在某些情况下是必须的，将用户从一个页面重定向到另外一个页面。但是重定向会触发额外的HTTP请求和响应的操作，并且增加了往返时间的延迟，而这个额外的HTTP请求和响应就是301和302状态码了。从重定向的时候服务器会返回一个301或者302状态码来确定此次请求是重定向，之后再发送请求到服务器请求另外一个页面来加载页面内容和资源。<br /> \r\n这里我需要说明一点的是我们平时都可能不太在意的细节&#8212;URL，我们知道有些URL中有斜杠“/”，而有些URL中不包含，比如：http://www.example.com/sport和http://www.example.com/sport/ ，这两个URL中的区别仅仅是最末尾的一个斜杠，但是请求这两个URL时，第一个链接会产生一个重定向，因为服务器不知道请求的这个是文件还是目录，当判断是目录的时候，就会在URL的末尾加上一个斜杠（这就造成重定向），之后就会查询该目录下的index文件名的文件来响应请求；而第二个链接就会使得服务器直接省略重定向的操作，请求该目录下的index类型的文件。<br /> \r\n通过，还可以几点说明：如果需要重定向几个页面的话，比如A―B―C，但是如果能直接A―C重定向就能实现功能的话，就尽量减少重定向的次数。<br /> \r\n通常我们从跟一个页面重定向到另外一个页面的方式是采用Javascript的localtion或者在head里通过meta的方式来实现，但是这样都会因重定向造成的性能问题。对于上面提到的URL方面不注意造成的重定向，有时候可以通过在服务器端rewrite的方式来解决。这就可以使得从一个URL映射到另外一个URL，这个操作是服务器自动完成的，不会出发重定向的问题。\r\n</p> \r\n<p> \r\n<strong>2010-6-8 Updates:</strong>在其他牛人的PPT中收集的一些优化技巧\r\n</p> \r\n<ol> \r\n<li>预加载资源。如果能预知用户下一步将会浏览哪个页面，就可以利用浏览器在当前页面的onload事件之后一点“空暇”时间来预加载一些资源（比如：图片、样式表、脚本等等），以期在下一个页面中会使用到。但是有一点必须要谨慎：预加载的资源不能影响当前页面的功能和效果，或者至少不能让用户察觉到。</li> \r\n<li>避免把样式表的加载放置到body中。例如：如果head部分已经加载了一个样式表，这个样式表会解析并且渲染页面样式，如果body中又加载了样式表，这个样式表又重新渲染了页面的一些模块的样式，或者重定义了一些样式规则，就显得累赘了。如果把页面中所有的样式表都放到body中加载，则延迟了页面的加载时间。</li> \r\n<li>加载外部脚本会阻塞页面的后续资源的加载，即使是不同域下的脚本也都是。</li> \r\n<li>避免将cookie设置到最高级域下。比如将cookie设置到example.com下，这样子域也会在HTTP请求头中带有主域的cookie。</li> \r\n<li>给永久的静态资源（图片、flash、样式、脚本）等添加Expires、Etag、Control-cache头来使得浏览器长久的缓存资源。使得重复浏览页面的时候从浏览器缓存读取资源。</li> \r\n<li>优化DOM的一系列操作。DOM、HTMLCollection对象的操作在Javascript中是非常低效的。优化DOM中循环操作对性能提高最甚，比如使用利用局部变量、转HTMLCollection为数组、定时器、事件委托、文档碎片（document fragment）等等方式。</li> \r\n<li>使用data:URL来链接base64编码的文件。这个方法尤其是在sprites图片背景或者其他一些下载文件的时候用到，但是由于IE6、7不支持data:URL，所以需对它们做特殊处理。本博客的sprites背景也使用了这种方式，具体的用法可以浏览《<a  href="http://www.ilovejs.net/archives/469">优化试试玩</a>》一文。<br /> \r\n通过这样的方式，可以减少HTTP请求，但是又得保证它的可缓存性。\r\n</li> \r\n<li>在HTML中始终闭合标签，而不要依赖浏览器多出一个步骤来自动渲染闭合标签，况且IE下在缺失的闭合标签可能会导致布局错乱。</li> \r\n</ol> ', '性能', '1', '2011-05-21 11:53:18'),
(591, '外文资源', '<ul>\r\n    <li><a target="_blank" href="https://developer.mozilla.org/en/Writing_Efficient_CSS">火狐下使用高效的css选择符</a></li>\r\n    <li><a target="_blank" href="http://www.lesliesommer.com/wdw07/html/">CSS Mojo圆角布局</a></li>\r\n</ul>', '随笔', '', '2011-05-21 11:53:42'),
(592, '耦合度', '<h3 class="headline-2 bk-sidecatalog-title" style="margin-top: 15px; margin-right: 0px; margin-bottom: 5px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; font-size: 16px; font-family: Arial; line-height: 22px; clear: both; "><span class="headline-content">基本概念</span></h3>\r\n<p>　　<a target="_blank" style="text-decoration: underline; color: rgb(19, 110, 194); " href="http://baike.baidu.com/view/575391.htm">软件设计</a>中通常用耦合度和内聚度作为衡量模块独立程度的标准。划分摸块的一个准则就是<a target="_blank" style="text-decoration: underline; color: rgb(19, 110, 194); " href="http://baike.baidu.com/view/3082578.htm">高内聚低耦合</a>。</p>\r\n<div class="spctrl" style="height: 14px; line-height: 14px; font-size: 12px; overflow-x: hidden; overflow-y: hidden; font-family: arial, 宋体, sans-serif; ">&nbsp;</div>\r\n<p>　　耦合度(Coupling)是对模块间关联程度的度量。耦合的强弱取决与模块间接口的复杂性、调用模块的方式以及通过界面传送数据的多少。</p>\r\n<div class="spctrl" style="height: 14px; line-height: 14px; font-size: 12px; overflow-x: hidden; overflow-y: hidden; font-family: arial, 宋体, sans-serif; ">&nbsp;</div>\r\n<p>　　模块间的耦合度是指模块之间的依赖关系，包括控制关系、调用关系、数据传递关系。模块间联系越多，其<a target="_blank" style="text-decoration: underline; color: rgb(19, 110, 194); " href="http://baike.baidu.com/view/1731634.htm">耦合性</a>越强，同时表明其独立性越差。</p>\r\n<div class="spctrl" style="height: 14px; line-height: 14px; font-size: 12px; overflow-x: hidden; overflow-y: hidden; font-family: arial, 宋体, sans-serif; ">&nbsp;</div>\r\n<p>　　降低模块间的耦合度能减少模块间的影响，防止对某一模块修改所引起的&ldquo;牵一发动全身&rdquo;的水波效应，保证系统设计顺利进行。</p>\r\n<div class="spctrl" style="height: 14px; line-height: 14px; font-size: 12px; overflow-x: hidden; overflow-y: hidden; font-family: arial, 宋体, sans-serif; ">&nbsp;</div>\r\n<p>　　内聚和耦合密切相关，同其它模块存在强耦合关系的模块常意味这弱内聚，强内聚常意味着弱耦合。</p>\r\n<h3 class="headline-2 bk-sidecatalog-title" style="margin-top: 15px; margin-right: 0px; margin-bottom: 5px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; font-size: 16px; font-family: Arial; line-height: 22px; clear: both; "><a name="2_2" style="text-decoration: underline; color: rgb(19, 110, 194); "></a><span class="headline-content">等级划分</span></h3>\r\n<p>　　耦合度可分为七级。</p>\r\n<div class="spctrl" style="height: 14px; line-height: 14px; font-size: 12px; overflow-x: hidden; overflow-y: hidden; font-family: arial, 宋体, sans-serif; ">&nbsp;</div>\r\n<p>　　a)非直接耦合：</p>\r\n<div class="spctrl" style="height: 14px; line-height: 14px; font-size: 12px; overflow-x: hidden; overflow-y: hidden; font-family: arial, 宋体, sans-serif; ">&nbsp;</div>\r\n<p>　　两模块间没有直接关系，之间的联系完全是通过主模块的控制和调用来实现的</p>\r\n<div class="spctrl" style="height: 14px; line-height: 14px; font-size: 12px; overflow-x: hidden; overflow-y: hidden; font-family: arial, 宋体, sans-serif; ">&nbsp;</div>\r\n<p>　　b)数据耦合：</p>\r\n<div class="spctrl" style="height: 14px; line-height: 14px; font-size: 12px; overflow-x: hidden; overflow-y: hidden; font-family: arial, 宋体, sans-serif; ">&nbsp;</div>\r\n<p>　　一个模块访问另一模块，彼此间通过简单数据参数来交换输入、输出信息。这里的简单数据参数不同于控制参数、公共<a target="_blank" style="text-decoration: underline; color: rgb(19, 110, 194); " href="http://baike.baidu.com/view/9900.htm">数据结构</a>或外部变量。</p>\r\n<div class="spctrl" style="height: 14px; line-height: 14px; font-size: 12px; overflow-x: hidden; overflow-y: hidden; font-family: arial, 宋体, sans-serif; ">&nbsp;</div>\r\n<p>　　c)标记耦合：</p>\r\n<div class="spctrl" style="height: 14px; line-height: 14px; font-size: 12px; overflow-x: hidden; overflow-y: hidden; font-family: arial, 宋体, sans-serif; ">&nbsp;</div>\r\n<p>　　如一组模块通过参数表传递记录信息，就是标记耦合。这个记录是某一数据结构的子结构，不是简单变量。</p>\r\n<div class="spctrl" style="height: 14px; line-height: 14px; font-size: 12px; overflow-x: hidden; overflow-y: hidden; font-family: arial, 宋体, sans-serif; ">&nbsp;</div>\r\n<p>　　d)控制耦合：</p>\r\n<div class="spctrl" style="height: 14px; line-height: 14px; font-size: 12px; overflow-x: hidden; overflow-y: hidden; font-family: arial, 宋体, sans-serif; ">&nbsp;</div>\r\n<p>　　一个模块通过传递开关、标志、名字等控制信息，明显的控制选择另一模块的功能</p>\r\n<div class="spctrl" style="height: 14px; line-height: 14px; font-size: 12px; overflow-x: hidden; overflow-y: hidden; font-family: arial, 宋体, sans-serif; ">&nbsp;</div>\r\n<p>　　e)外部耦合：</p>\r\n<div class="spctrl" style="height: 14px; line-height: 14px; font-size: 12px; overflow-x: hidden; overflow-y: hidden; font-family: arial, 宋体, sans-serif; ">&nbsp;</div>\r\n<p>　　一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数传递该全局变量的信息</p>\r\n<div class="spctrl" style="height: 14px; line-height: 14px; font-size: 12px; overflow-x: hidden; overflow-y: hidden; font-family: arial, 宋体, sans-serif; ">&nbsp;</div>\r\n<p>　　f)公共耦合：</p>\r\n<div class="spctrl" style="height: 14px; line-height: 14px; font-size: 12px; overflow-x: hidden; overflow-y: hidden; font-family: arial, 宋体, sans-serif; ">&nbsp;</div>\r\n<p>　　一组模块都访问同一个公共数据环境。该公共数据环境可以是全局数据结构、共享的通信区、内存的公共覆盖区等。</p>\r\n<div class="spctrl" style="height: 14px; line-height: 14px; font-size: 12px; overflow-x: hidden; overflow-y: hidden; font-family: arial, 宋体, sans-serif; ">&nbsp;</div>\r\n<p>　　g)内容耦合：</p>\r\n<div class="spctrl" style="height: 14px; line-height: 14px; font-size: 12px; overflow-x: hidden; overflow-y: hidden; font-family: arial, 宋体, sans-serif; ">&nbsp;</div>\r\n<p>　　一个模块直接修改另一个模块的数据，或直接转入另一个模块</p>\r\n<div class="spctrl" style="height: 14px; line-height: 14px; font-size: 12px; overflow-x: hidden; overflow-y: hidden; font-family: arial, 宋体, sans-serif; ">&nbsp;</div>\r\n<p>　　内聚度是指内部各元素之间联系的紧密程度，模块的内聚种类通常可分为7种，按其内聚度从低到高的次序依此为：偶然内聚、逻辑内聚、瞬时内聚、过程内聚、通信内聚、顺序内聚、功能内聚。</p>', '前端', '', '2011-09-18 18:08:09'),
(593, '匿名函数', '<p><strong>一个匿名函数就是一个没有名字的函数。</strong></p>\r\n<p><a href="http://shiningray.cn/functional_javascript_programming.html">函数式JavaScript编程指南</a></p>\r\n<p><a href="http://www.ibm.com/developerworks/cn/web/wa-javascript.html">用函数式编程技术编写优美的 JavaScript</a></p>', 'JavaScript', '', '2011-06-12 22:00:25'),
(594, 'CSS颜色透明', '<p>在css3里，颜色透明可以定义为rgba，rgb表示的是颜色值，a是alpha的第一个字母，顾名思义就是透明度的设置，其值是0-1之间的数值。例如：</p>\r\n<pre title="code" class="brush: css;">\r\n-webkit-box-shadow: 0 1px 3px rgba(0,0,0,0.3); -moz-box-shadow:0 1px 3px rgba(0,0,0,0.3); box-shadow:0 1px 3px rgba(0,0,0,0.3);/*30%的黑色透明*/\r\nbackground:rgba(255,255,255,0.97);/*97%的白色透明*/\r\n</pre>', 'CSS3', '', '2011-06-15 8:24:39'),
(595, 'select默认样式', '<p>webkit浏览器下select默认有左右边距</p>', 'CSS', '', '2011-06-15 8:25:05'),
(596, '动画组件之：跳帧与延时', '<p>&nbsp;动画提供两种选择：要么&ldquo;<span style="color: rgb(0, 0, 255); ">保时丢帧</span>&rdquo;，要么&ldquo;<span style="color: rgb(0, 0, 255); ">保帧延时</span>&rdquo;。<br />\r\n<br />\r\n&ldquo;<span style="color: rgb(0, 0, 255); ">保时丢帧</span>&rdquo;，默认选择这种策略，它的好处是：能够保证到时间后，动画即刻播完。例如，在第1秒时，弹出了alert阻塞了一秒，那就会丢掉应该在这一秒内播放的10帧，alert关闭时已经到了第二秒，则跳到第二秒对应的帧继续揪放。<br />\r\n&ldquo;<span style="color: rgb(0, 0, 255); ">保帧延时</span>&rdquo;，它的好处是：保证每一帧都能播到。例如，在第1秒时，弹出了alert阻塞了一秒，alert关闭时已经到了第二秒，则还是接着阻塞前的帧继续播放，而不是跳帧。</p>', 'JavaScript', '', '2011-06-15 8:25:31');
INSERT INTO `list` (`id`, `title`, `content`, `cat`, `marrow`, `time`) VALUES
(597, '招聘 JavaScript 程序员时应该问什么问题', '<p>通用：</p>\r\n<p>使用过类库吗?  <br />\r\n最喜欢哪个?  <br />\r\n为什么? <br />\r\n自己有写过类库吗? 比如 DOM 的扩展。 <br />\r\n有使用过服务端 JavaScript 框架吗? <br />\r\nECMAScript 和 JavaScript 的区别是什么? <br />\r\n有用过 JavaScript 代码校验工具吗? <br />\r\n有读过或推荐的 JavaScirpt 书籍吗? <br />\r\n会为你的 JavaScript 代码写单元测试吗?</p>\r\n<h2>初/中级：</h2>\r\n<p>为什么基本上所有对象都有 toString 方法? <br />\r\n知道 Mozilla Firefox 用的是哪个解析器吗? 其他浏览器呢? <br />\r\nJavaScript 支持 lambda 函数吗? <br />\r\n你用过或写过的最有用的 JavaScript 函数是什么? <br />\r\nJavaScript 有块级作用域吗? <br />\r\n能解释下 Ajax/XMLHttpRequest 是如何工作的吗? <br />\r\nJavaScript 支持类继承吗? <br />\r\n能写一个用了 with 表达式的代码片段吗? <br />\r\n知道什么是 Greasemonkey 吗? 有用过吗? <br />\r\n你认为 innerHTML 是魔鬼吗? <br />\r\n什么是 JSON?</p>\r\n<h2>高级：</h2>\r\n<p>Can you give me an example of a generator? <br />\r\nJSONP 是如何工作的?请举个单例模式的例子。 <br />\r\n未定义和未声明之间有什么区别? <br />\r\n有用 Rapha&euml;l 或 Canvas 元素做过动画吗? <br />\r\n熟悉 Web Worker 吗? <br />\r\n做过 profiling 吗?  <br />\r\n都有用过哪些工具? <br />\r\n有读过新的 ECMAScript 规范吗? 都有哪些新特性?</p>\r\n<h2>关于人：</h2>\r\n<p>谁最初写了 ECMAScript? 知道他在哪工作，以及他的 title 是什么吗? <br />\r\n写 jQuery 的那男孩叫什么? <br />\r\n谁写了 JSLint?</p>\r\n<h2>兼容性：</h2>\r\n<p>哪些浏览器支持标准的 addEventListener ?  <br />\r\n哪些浏览器对于 getElementById 的实现有问题? 比如它会返回 name 属性一致的元素。</p>\r\n<p>==</p>\r\n<h2>补充：</h2>\r\n<p>如何在没有定义 toString 方法的对象上调用 toString() ? <br />\r\n在调用函数时使用 new 会发生什么? <br />\r\n什么是作用域链? <br />\r\n如何在函数里创建静态变量? <br />\r\n如果给你一个类名的字符串，你如何实例化他? <br />\r\n什么是 currying? 如何在 JavaScript 里用他? <br />\r\n什么是匿名函数?  <br />\r\n什么是 lambda 函数? <br />\r\n什么是 &lsquo;live&rsquo; 容器?  (应该是指 getElementsByTagName 等方法返回的元素) <br />\r\nvar 为什么重要? <br />\r\n如何调试 JavaScript?</p>\r\n<p>摘自：http://stackoverflow.com/questions/1684917/what-questions-should-a-javascript-programmer-be-able-to-answer/1684945</p>\r\n<p>Code snippet questions:</p>\r\n\r\n<p><strong><a href="http://en.wikipedia.org/wiki/ECMAScript" rel="nofollow">1</a>:</strong></p>\r\n\r\n<pre title="code" class="brush: jscript;">\r\n&lt;a href="#"&gt;text&lt;/a&gt;&lt;br&gt;&lt;a href="#"&gt;link&lt;/a&gt;\r\n&lt;script&gt;\r\n    var as = document.getElementsByTagName(''a'');\r\n    for ( var i = as.length; i--; ) {\r\n        as[i].onclick = function() {\r\n            alert(i);\r\n            return false;\r\n        }\r\n    }\r\n&lt;/script&gt;\r\n</pre>\r\n\r\n<p>Why do the anchors, when clicked on, alert <code>-1</code> instead of their respective counter inside of the loop? How can you fix the code so that it does alert the right number? (Hint: closures)</p>\r\n\r\n<p><strong><a href="http://XMLHttpRequest" rel="nofollow">2</a></strong></p>\r\n\r\n<pre title="code" class="brush: jscript;">\r\nfunction User(name) {\r\n    this.name = name;\r\n};\r\n\r\nvar j = User(''Jack'');\r\nalert(j.name)\r\n</pre> \r\n\r\n<p>Why would this code not work as expected? Is anything missing?</p>\r\n\r\n<p><strong><a href="http://en.wikipedia.org/wiki/JSONP" rel="nofollow">3</a>:</strong></p>\r\n\r\n<pre title="code" class="brush: jscript;">\r\nObject.prototype.jack = {};\r\n\r\nvar a = [1,2,3];\r\n\r\nfor ( var number in a ) {\r\n    alert( number )\r\n}\r\n</pre>\r\n\r\n<p>I''m iterating through this array I defined, it has 3 elements in it.. the numbers 1 2 and 3.. Why on earth is jack showing up?</p>\r\n\r\n<p><strong><a href="http://en.wikipedia.org/wiki/Rapha%C3%ABl_%28JavaScript_library%29" rel="nofollow">4</a>:</strong></p>\r\n\r\n<pre title="code" class="brush: jscript;">\r\npeople = {\r\n    1:''Jack'',\r\n    2:''Chloe'',\r\n    3:''Bruce'',\r\n}\r\n\r\nfor ( var person in people ) {\r\n    alert( person )\r\n}\r\n</pre>\r\n\r\n<p>Why is this not working in Internet Explorer?</p>\r\n\r\n<p><strong><a href="http://en.wikipedia.org/wiki/JSLint" rel="nofollow">5</a></strong></p>\r\n\r\n<pre title="code" class="brush: jscript;">\r\n&lt;script&gt;\r\n    (function() {\r\n        var jack = ''Jack'';\r\n    })();\r\n    alert(typeof jack)\r\n&lt;/script&gt;\r\n</pre>\r\n\r\n<p>Why does it alert undefined when I declared the jack variable to be ''Jack''?</p>\r\n\r\n<p><strong><a href="http://en.wikipedia.org/wiki/XMLHttpRequest" rel="nofollow">6</a>:</strong></p>\r\n\r\n<pre title="code" class="brush: jscript;">\r\n&lt;script src="file.js"&gt;alert(2);&lt;/script&gt;\r\n</pre>\r\n\r\n<p>Why isn''t it alerting 2?</p>\r\n\r\n<p><strong>[7]:</strong></p>\r\n\r\n<pre title="code" class="brush: jscript;">\r\narray = [1,2]; alert( typeof array )\r\n</pre>\r\n\r\n<p>Why does it say <code>object</code> and not array? How would I detect if its an array?</p>\r\n\r\n<p><strong>[8]:</strong></p>\r\n\r\n<pre title="code" class="brush: jscript;">\r\n&lt;a id="clickme"&gt;click me!&lt;/a&gt;\r\n&lt;script&gt;\r\n    var a = document.getElementById(''clickme'');\r\n    a.onclick = function() {\r\n        alert(this.innerHTML)\r\n        setTimeout( function() {\r\n            alert( this.innerHTML );\r\n        }, 1000);\r\n    };\r\n&lt;/script&gt;\r\n</pre>\r\n\r\n<p>Why does the second alert say <code>undefined</code>?</p>\r\n\r\n<p><strong>[9]:</strong></p>\r\n\r\n<pre title="code" class="brush: jscript;">\r\n&lt;p id="test"&gt;original&lt;/p&gt;\r\n&lt;script&gt;\r\n    var test = document.getElementById(''test'');\r\n    test.innerHTML.replace(''original'', ''FOOBAR'');\r\n&lt;/script&gt;\r\n</pre>\r\n\r\n<p>How come it doesn''t replace the text with FOOBAR??</p>\r\n\r\n<p><strong>[10]:</strong></p>\r\n\r\n<pre title="code" class="brush: jscript;">\r\nfunction identity() {\r\n    var name = ''Jack'';\r\n    alert(name);\r\n    return\r\n    name\r\n};\r\nvar who = identity();\r\nalert(who)\r\n</pre>\r\n\r\n<p>Why does it first alert Jack, then undefined?</p>\r\n\r\n<p><strong>[11]:</strong></p>\r\n\r\n<pre title="code" class="brush: jscript;">\r\nvar number = ''08'',\r\nparsed = parseInt(number);\r\n\r\nalert(parsed)\r\n</pre>\r\n\r\n<p>The alert should give me 8.. why doesn''t it give me 8?</p>\r\n\r\n<p><strong>[12]:</strong></p>\r\n\r\n<pre title="code" class="brush: jscript;">\r\n&lt;script&gt;\r\n    var xhr = new XMLHttpRequest();\r\n    xhr.open("GET", "http://www.google.com", true);\r\n    xhr.onreadystatechange = function(){\r\n        if ( xhr.readyState == 4 ) {\r\n            if ( xhr.status == 200 ) {\r\n                alert( xhr.responseText )\r\n            } else {\r\n                document.body.innerHTML = "ERROR";\r\n            }\r\n        }\r\n    };\r\n    xhr.send(null);\r\n&lt;/script&gt;\r\n</pre>\r\n\r\n<p>How come I can''t retrieve Google''s homepage text with <a href="http://en.wikipedia.org/wiki/XMLHttpRequest" rel="nofollow">XHR</a> from my localhost?</p>\r\n\r\n<p><strong>[13]:</strong></p>\r\n\r\n<pre title="code" class="brush: jscript;">\r\n&lt;script&gt;\r\n    var ticket = true;\r\n\r\n    if (!ticket)\r\n        alert(''you need a ticket'');\r\n        alert(''please purchase a ticket.'')\r\n&lt;/script&gt;\r\n</pre>\r\n\r\n<p><code>ticket</code> is set to true. Why is it alerting that I need to purchase one?</p>\r\n\r\n<p><strong>[14]:</strong></p>\r\n\r\n<pre title="code" class="brush: jscript;">\r\n&lt;script&gt;\r\n    var blogEntry = ''Today I woke up\r\n        to the smell of fresh coffee'';\r\n\r\n    alert(blogEntry)\r\n&lt;/script&gt;\r\n</pre>\r\n\r\n<p>How come it doesn''t alert with the blog entry? Everything seems right.</p>\r\n\r\n<p><strong>[15]:</strong></p>\r\n\r\n<pre title="code" class="brush: jscript;">\r\nalert( [typeof ''hi'' === ''string'', typeof new String(''hi'') === ''string'' ]  )\r\n</pre>\r\n\r\n<p>I have two strings, but the second evaluation doesn''t become true. Is this a potential bug? How come it''s not true?</p>\r\n\r\n<p>Best practices:</p>\r\n\r\n<pre title="code" class="brush: jscript;">\r\n&lt;a href="#" onclick="javascript:window.open(''about.html'');"&gt;about&lt;/a&gt;\r\n</pre>\r\n\r\n<p>Would you change anything in the prior code example? Why?</p>\r\n\r\n<pre title="code" class="brush: jscript;">\r\n    &lt;a href="site.html" onmouseover="changeImages(''button1'', ''images/button1over.png''); return true;" onmouseout="changeImages(''button1'', ''images/button1.png''); return true;"&gt;site&lt;/a&gt;\r\n</pre>', 'JavaScript', '1', '2011-06-15 8:25:54'),
(598, 'JS兼容性总结', '<p>&nbsp;<a href="http://www.blueidea.com/tech/web/2008/5422.asp">http://www.blueidea.com/tech/web/2008/5422.asp</a></p>\r\n<p><a href="http://www.cnblogs.com/wiky/archive/2010/01/09/IE-and-Firefox-Javascript-compatibility.html">http://www.cnblogs.com/wiky/archive/2010/01/09/IE-and-Firefox-Javascript-compatibility.html</a></p>', 'JavaScript', '1', '2011-06-15 8:26:31'),
(599, '为非IE浏览器添加mouseenter，mouseleave事件', '<p><a href="http://www.cnblogs.com/snandy/archive/2011/03/28/1997414.html">http://www.cnblogs.com/snandy/archive/2011/03/28/1997414.html</a></p>\r\n<p>先了解几个事件对象属性<br />\r\n<br />\r\ntarget: 指事件源对象，点击嵌套元素最里层的某元素，该元素就是target。IE6/7/8对应的是srcElement。<br />\r\ncurrentTarget: 指添加事件handler的元素本身，如el.addEventListener中el就是currentTarget。IE6/7/8没有对应属性，可在handler内使用this来替代如evt.currentTarget = this。<br />\r\nrelativeTarget: 指事件相关的元素，一般用在mouseover，mouseout事件中。IE6/7/8中对应的是fromElement，toElement。<br />\r\n<br />\r\n<a target="_blank" href="http://msdn.microsoft.com/en-us/library/ms536945(VS.85).aspx">mouseenter</a> ，<a target="_blank" href="http://msdn.microsoft.com/en-us/library/ms536946(VS.85).aspx">mouseleave</a> IE9中仍然支持，mouseenter与mouseover区别在于：在元素内部移动时mouseenter不会触发。如下</p>\r\n<div class="cnblogs_Highlighter">\r\n<pre class="brush:html;gutter:true;">\r\n&lt;!DOCTYPE HTML&gt;\r\n&lt;html&gt;\r\n&lt;head&gt;\r\n	&lt;meta charset=&quot;utf-8&quot;&gt;\r\n	&lt;title&gt;mouseerter与mouseover区别(IE下测试)&lt;/title&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n&lt;div id=&quot;result&quot; style=&quot;position:absolute;right:100px;top:5px;width:250px;height:400px;border:2px solid gray;overflow:auto;&quot;&gt;\r\n&lt;/div&gt;\r\n&lt;h3&gt;1，鼠标在div[id=parent1]内部移动时也会触发mouseover事件&lt;/h3&gt;\r\n&lt;div id=&quot;parent1&quot; style=&quot;width:400px;border:1px solid gray;padding:5px;&quot;&gt;\r\n	&lt;div id=&quot;child11&quot; style=&quot;width:100px;height:100px;background:gold;float:left;&quot;&gt;Child11&lt;/div&gt;\r\n	&lt;div id=&quot;child12&quot; style=&quot;width:100px;height:100px;background:gold;float:right;&quot;&gt;Child12&lt;/div&gt;\r\n	&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;\r\n&lt;/div&gt;\r\n&lt;br/&gt;\r\n&lt;h3&gt;2，鼠标在div[id=parent2]内部移动时也不会触发mouseenter事件&lt;/h3&gt;\r\n&lt;div id=&quot;parent2&quot; style=&quot;width:400px;border:1px solid gray;padding:5px;&quot;&gt;\r\n	&lt;div id=&quot;child21&quot; style=&quot;width:100px;height:100px;background:gold;float:left;&quot;&gt;Child21&lt;/div&gt;\r\n	&lt;div id=&quot;child22&quot; style=&quot;width:100px;height:100px;background:gold;float:right;&quot;&gt;Child22&lt;/div&gt;\r\n	&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;\r\n&lt;/div&gt;\r\n\r\n&lt;script type=&quot;text/javascript&quot;&gt;\r\n	function on(el,type,fn){\r\n		el.addEventListener ? el.addEventListener(type, fn, false) : el.attachEvent(''on'' + type, fn);\r\n	}\r\n	function $(id){\r\n		return document.getElementById(id);\r\n	}\r\n	var p1 = $(''parent1''),\r\n		p2 = $(''parent2'');\r\n	function fn(e){\r\n		var d = document.createElement(''div'');\r\n		d.innerHTML = e.type;\r\n		$(''result'').appendChild(d);\r\n	}\r\n\r\n	on(p1,''mouseover'',fn);\r\n	on(p2,''mouseenter'',fn);\r\n&lt;/script&gt;\r\n&lt;body&gt;\r\n&lt;/html&gt;\r\n</pre>\r\n</div>\r\n<p>了解了这三个属性的意义后，实现起来就很简单</p>\r\n<div class="cnblogs_Highlighter">\r\n<pre class="brush:javascript;gutter:true;">\r\n    E = function(){\r\n        function elContains(a, b){\r\n            try{\r\n                return a.contains ? a != b && a.contains(b) : !!(a.compareDocumentPosition(b) & 16);\r\n            }catch(e){}\r\n        }\r\n\r\n        function addEvt(el, type, fn){\r\n            function fun(e){\r\n                var a = e.currentTarget, b = e.relatedTarget;\r\n                if(!elContains(a, b) && a!=b){\r\n                    fn.call(e.currentTarget,e);\r\n                }\r\n            }\r\n\r\n            if(el.addEventListener){\r\n                if(type==''mouseenter''){\r\n                    el.addEventListener(''mouseover'', fun, false);\r\n                }else if(type==''mouseleave''){\r\n                    el.addEventListener(''mouseout'', fun, false);\r\n                }else{\r\n                    el.addEventListener(type, fn, false);\r\n                }\r\n            }else{\r\n                el.attachEvent(''on'' + type, fn);\r\n            }\r\n        }\r\n        return {addEvt:addEvt};\r\n    }();\r\n</pre>\r\n</div>\r\n<p>&nbsp;</p>\r\n<p>相关：</p>\r\n<p><a target="_blank" href="http://blogs.sun.com/greimer/">Greg Reimer</a> 的博文 <a target="_blank" href="http://blogs.sun.com/greimer/entry/mouse_over_out_versus_mouse">Goodbye mouseover, hello mouseenter</a></p>\r\n<script>\r\n    E = function(){\r\n        function elContains(a, b){\r\n            try{\r\n                return a.contains ? a != b && a.contains(b) : !!(a.compareDocumentPosition(b) & 16);\r\n            }catch(e){}\r\n        }\r\n\r\n        function addEvt(el, type, fn){\r\n            function fun(e){\r\n                var a = e.currentTarget, b = e.relatedTarget;\r\n                if(!elContains(a, b) && a!=b){\r\n                    fn.call(e.currentTarget,e);\r\n                }\r\n            }\r\n\r\n            if(el.addEventListener){\r\n                if(type==''mouseenter''){\r\n                    el.addEventListener(''mouseover'', fun, false);\r\n                }else if(type==''mouseleave''){\r\n                    el.addEventListener(''mouseout'', fun, false);\r\n                }else{\r\n                    el.addEventListener(type, fn, false);\r\n                }\r\n            }else{\r\n                el.attachEvent(''on'' + type, fn);\r\n            }\r\n        }\r\n        return {addEvt:addEvt};\r\n    }();\r\n</script>', 'JavaScript', '', '2011-06-15 8:26:51'),
(600, 'contains和compareDocumentPosition', '<p>在很多任务中，他们被证明是非常有用的（特别关于结构的抽象DOM选择器）。</p>\r\n<h2>1.DOMElement.contains(DOM Node)</h2>\r\n<p>这个方法起先用在IE,用来确定DOM Node是否包含在另一个DOM Element中。             当尝试优化CSS选择器（像&ldquo;#id1 #id2&rdquo;），这个方法很有用。你可以通过getElementById得到元素，然后使用.contains()确定#id1实际上是否包含#id2。</p>\r\n<p>注意：如果DOM Node和DOM Element相一致，.contains()将返回true，虽然，一个元素不能包含自己。</p>\r\n<p>这里有一个简单的执行包装，可以运行在：Internet Explorer,Firefox,Opera,and Safari。</p>\r\n<pre class="brush:javascript;">\r\n            function contains(a, b) {\r\n                return a.contains ? a != b &amp;&amp; a.contains(b) : !!(a.compareDocumentPosition(b) &amp; 16);\r\n            }\r\n        </pre>\r\n<h2>2、NodeA.compareDocumentPosition(NodeB)</h2>\r\n<p>这个方法是 DOM Level 3 specification 的一部分，允许你确定 2 个 DOM Node 之间的相互位置。这个方法比 .contains() 强大。这个方法的一个可能应用是排序 DOM Node 成一个详细精确的顺序。             使用这个方法你可以确定关于一个元素位置的一连串的信息。所有的这些信息将返回一个比特码（Bit，比特，亦称二进制位）。</p>\r\n<p>对于那些，人们知之甚少。比特码是将多重数据存储为一个简单的数字（译者注：0 或 1）。你最终打开 / 关闭个别数目（译者注：打开/关闭对应 0 /1），将给你一个最终的结果。</p>\r\n<p>这里是从 NodeA.compareDocumentPosition(NodeB) 返回的结果，包含你可以得到的信息。</p>\r\n<p>Bits Number Meaning</p>\r\n<p>000 0 元素一致</p>\r\n<p>001 1 节点在不同的文档（或者一个在文档之外）</p>\r\n<p>010 2 节点 B 在节点 A 之前</p>\r\n<p>100 4 节点 A 在节点 B 之前</p>\r\n<p>000 8 节点 B 包含节点 A</p>\r\n<p>000 16 节点 A 包含节点 B</p>\r\n<p>000 32 浏览器的私有使用</p>\r\n<p>现在，这意味着一个可能的结果类似于：</p>\r\n<pre title="code" class="brush: xhtml;">\r\n        &lt;div id=&quot;a&quot;&gt;\r\n            &lt;div id=&quot;b&quot;&gt;&lt;/div&gt;\r\n        &lt;/div&gt;\r\n        &lt;script type=&quot;text/javascript&quot;&gt;\r\n            alert( document.getElementById(&quot;a&quot;).compareDocumentPosition(document.getElementById(&quot;b&quot;)) == 20);\r\n        &lt;/script&gt;\r\n        </pre>\r\n<p>一旦一个节点 A 包含另一个节点 B，包含 B（+16） 且在 B 之前（+4），则最后的结果是数字 20 。如果你查看比特发生的变化，将增加你的理解。</p>\r\n<p>100 (4) + 010000 (16) = 010100 (20)             这个，毫无疑问，有助于理解单个最混乱的 DOM API 方法。当然，他的价值当之无愧的。             现在，DOMNode.compareDocumentPosition 在 Firefox 和 Opera 中是可用的。然而，有一些技巧，我们可以用来在 IE 中执行他。</p>\r\n<pre class="brush:javascript;">\r\n            // Compare Position - MIT Licensed, John Resig\r\n            function comparePosition(a, b){\r\n                return a.compareDocumentPosition ? a.compareDocumentPosition(b) : a.contains ?  ( a != b &amp;&amp; a.contains(b) &amp;&amp; 16 ) +\r\n                        ( a != b &amp;&amp; b.contains(a) &amp;&amp; 8 ) + ( a.sourceIndex &gt;= 0 &amp;&amp; b.sourceIndex &gt;= 0 ?\r\n                        (a.sourceIndex &lt; b.sourceIndex &amp;&amp; 4 ) +\r\n                                (a.sourceIndex &gt; b.sourceIndex &amp;&amp; 2 ) :\r\n                        1 ) : 0;\r\n            }\r\n        </pre>\r\n<p>IE 提供给我们一些可以使用的方法和属性。开始，使用 .contains() 方法（如我们前面所讨论的），以便给我们包含（+16）或者被包含（+8）的结果。IE 还有一个 .sourceIndex 属性在所有的 DOM Element 对应着元素在文档中的位置，例如：document.documentElement.sourceIndex == 0。因为我们有这个信息，我们可以完成两个 compareDocumentPosition 难题：在前面（+2）和在后面（+4）。另外，如果一个元素不在当前的文档，.sourceIndex 将等于 -1，这个给我们另外一个回答（+1）。最后，通过这个过程的推断，我们可以确定如果一个元素等于他本身，返回一个空的比特码（+0）。</p>\r\n<p>这个函数可以在 Internet Explorer、Firefox 和 Opera 中运行。但在 Safari 中却有残缺功能（因为他只有 contains() 方法，而没有 .sourceIndex 属性。我们只能得到 包含（+16），被包含（+8），其他的所有结果都将返回（+1）代表一个断开）。</p>\r\n<p>PPK 提供了一个关于通过创建一个 getElementsByTagNames 方法使新功能可以被使用的很棒的例子。让我们改编他到我们的新方法中：</p>\r\n<pre class="brush:javascript;">\r\n            // Original by PPK quirksmode.org\r\n            function getElementsByTagNames(list, elem) {\r\n                elem = elem || document;\r\n                var tagNames = list.split('',''), results = [];\r\n                for ( var i = 0; i &lt; tagNames.length; i++ ) {\r\n                    var tags = elem.getElementsByTagName( tagNames[i] );\r\n                    for ( var j = 0; j &lt; tags.length; j++ )\r\n                        results.push( tags[j] );\r\n                }\r\n                return results.sort(function(a, b){\r\n                    return 3 - (comparePosition(a, b) &amp; 6);\r\n                });\r\n            }\r\n            //]]&gt;\r\n        </pre>\r\n<p>我们现在可以使用他来按次序构建一个站点的目录：             getElementsByTagNames(&quot;h1, h2, h3&quot;);             虽然 Firefox 和 Opera 都采取了一些主动落实这一方法。我依然期待看到更多的浏览器进入，以帮助向前推动</p>', 'JavaScript', '', '2011-06-15 8:56:19'),
(601, '前端MVC设计模式', '<p>&nbsp;MVC模式的基本理念，是通过把一个application封装成model, view和controller三个部分达到降低耦合，简化开发的目的。</p>\r\n<p>前端开发就是一个大大的MVC架构：<br />\r\nModel: HTML/XHTML中的信息&nbsp;<br />\r\nView: Style sheet&nbsp;<br />\r\nController: EMAScripts等等脚本&nbsp;</p>\r\n<ul>\r\n    <li><a target="_blank" href="http://cloudera.iteye.com/blog/546183">javascript 开发中的 MVC 模式</a></li>\r\n    <li><a target="_blank" href="http://heiniuhaha.wordpress.com/2010/12/10/mvc%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">MVC设计模式</a></li>\r\n</ul>', '前端', '', '2011-09-18 18:07:20'),
(602, 'MVC设计模式', '<p>前言：MVC是一种目前广泛流行的软件设计模式，随着网络应用的快速增加,MVC模式对于Web应用的开发无疑是一种非常先进的设计思想，无论你选择哪种语言，无论应用多复杂,它都能为你理解分析应用模型时提供最基本的分析方法，为你构造产品提供清晰的设计框架，为你的软件工程提供规范的依据。</p>\r\n<h3>一、MVC设计思想</h3>\r\n<p>MVC英文即Model-View-Controller，即把一个应用的输入、处理、输出流程按照Model、View、Controller的方式进行分离，这样一个应用被分成三个层&mdash;&mdash;模型层、视图层、控制层。</p>\r\n<ul>\r\n    <li>视图(View)代表用户交互界面，对于Web应用来说，可以概括为HTML界面，但有可能为XHTML、XML和Applet。随着应用的复杂性和规模性，界面的处理也变得具有挑战性。一个应用可能有很多不同的视图，MVC设计模式对于视图的处理仅限于视图上数据的采集和处理，以及用户的请求，而不包括在视图上的业务流程的处理。业务流程的处理交予模型(Model)处理。比如一个订单的视图只接受来自模型的数据并显示给用户，以及将用户界面的输入数据和请求传递给控制和模型。</li>\r\n    <li>模型(Model)：就是业务流程/状态的处理以及业务规则的制定。业务流程的处理过程对其它层来说是黑箱操作，模型接受视图请求的数据，并返回最终的处理结果。业务模型的设计可以说是MVC最主要的核心。目前流行的EJB模型就是一个典型的应用例子，它从应用技术实现的角度对模型做了进一步的划分，以便充分利用现有的组件，但它不能作为应用设计模型的框架。它仅仅告诉你按这种模型设计就可以利用某些技术组件，从而减少了技术上的困难。对一个开发者来说，就可以专注于业务模型的设计。MVC设计模式告诉我们，把应用的模型按一定的规则抽取出来，抽取的层次很重要，这也是判断开发人员是否优秀的设计依据。抽象与具体不能隔得太远，也不能太近。MVC并没有提供模型的设计方法，而只告诉你应该组织管理这些模型，以便于模型的重构和提高重用性。我们可以用对象编程来做比喻，MVC定义了一个顶级类，告诉它的子类你只能做这些，但没法限制你能做这些。这点对编程的开发人员非常重要。\r\n    <p>业务模型还有一个很重要的模型那就是数据模型。数据模型主要指实体对象的数据保存（持续化）。比如将一张订单保存到数据库，从数据库获取订单。我们可以将这个模型单独列出，所有有关数据库的操作只限制在该模型中。</p>\r\n    </li>\r\n    <li>控制(Controller)可以理解为从用户接收请求, 将模型与视图匹配在一起，共同完成用户的请求。划分控制层的作用也很明显，它清楚地告诉你，它就是一个分发器，选择什么样的模型，选择什么样的视图，可以完成什么样的用户请求。控制层并不做任何的数据处理。例如，用户点击一个连接，控制层接受请求后, 并不处理业务信息，它只把用户的信息传递给模型，告诉模型做什么，选择符合要求的视图返回给用户。因此，一个模型可能对应多个视图，一个视图可能对应多个模型。</li>\r\n</ul>\r\n<h3>MVC的优点</h3>\r\n<p>大部分用过程语言比如ASP、PHP开发出来的Web应用，初始的开发模板就是混合层的数据编程。例如，直接向数据库发送请求并用HTML显示,开发速度往往比较快,但由于数据页面的分离不是很直接,因而很难体现出业务模型的样子或者模型的重用性。产品设计弹性力度很小，很难满足用户的变化性需求。MVC要求对应用分层，虽然要花费额外的工作，但产品的结构清晰，产品的应用通过模型可以得到更好地体现。</p>\r\n<ul>\r\n    <li>首先，最重要的是应该有多个视图对应一个模型的能力。在目前用户需求的快速变化下，可能有多种方式访问应用的要求。例如，订单模型可能有本系统的订单，也有网上订单，或者其他系统的订单，但对于订单的处理都是一样，也就是说订单的处理是一致的。按MVC设计模式，一个订单模型以及多个视图即可解决问题。这样减少了代码的复制，即减少了代码的维护量，一旦模型发生改变，也易于维护。\r\n    <p>&nbsp;</p>\r\n    <div id="attachment_1353" class="wp-caption alignnone" style="width: 462px"><a href="http://heiniuhaha.files.wordpress.com/2010/12/mvc.gif"><img class="size-full wp-image-1353" title="MVC设计模型图" alt="MVC设计模型图" width="452" height="300" src="http://heiniuhaha.files.wordpress.com/2010/12/mvc.gif?w=452&amp;h=300" /></a>\r\n    <p class="wp-caption-text">MVC设计模型图</p>\r\n    </div>\r\n    </li>\r\n    <li>其次，由于模型返回的数据不带任何显示格式，因而这些模型也可直接应用于接口的使用。</li>\r\n    <li>再次，由于一个应用被分离为三层，因此有时改变其中的一层就能满足应用的改变。一个应用的业务流程或者业务规则的改变只需改动MVC的模型层。\r\n    <p>控制层的概念也很有效，由于它把不同的模型和不同的视图组合在一起完成不同的请求，因此，控制层可以说是包含了用户请求权限的概念。</p>\r\n    </li>\r\n    <li>最后，它还有利于软件工程化管理。由于不同的层各司其职，每一层不同的应用具有某些相同的特征，有利于通过工程化、工具化产生管理程序代码。</li>\r\n</ul>\r\n<h3>MVC的缺点</h3>\r\n<p>MVC的设计实现并不十分容易, 理解起来比较容易，但对开发人员的要求比较高。MVC只是一种基本的设计思想，还需要详细的设计规划。<br />\r\n模型和视图的严格分离可能使得调试困难一些，但比较容易发现错误。</p>\r\n<h3>总结：</h3>\r\n<p>经验表明，MVC由于将应用分为三层，意味着代码文件增多，因此，对于文件的管理需要费点心思。<br />\r\n综合上述，MVC是构筑软件非常好的基本模式，至少将业务处理与显示分离，强迫将应用分为模型、视图以及控制层, 使得你会认真考虑应用的额外复杂性，把这些想法融进到架构中，增加了应用的可拓展性。如果能把握到这一点，MVC模式会使得你的应用更加强壮，更加有弹性，更加个性化。</p>', '前端', '', '2011-09-18 18:07:32'),
(603, '什么是可置换、非可置换元素？', '<p>&nbsp;什么是可置换、非可置换元素？</p>\r\n<p><a href="http://www.w3.org/TR/CSS21/visudet.html">http://www.w3.org/TR/CSS21/visudet.html</a></p>\r\n<p><a href="http://www.w3.org/TR/CSS2/conform.html#replaced-element Detailed Description">http://www.w3.org/TR/CSS2/conform.html#replaced-element Detailed Description</a></p>', 'HTML', '', '2011-09-18 18:07:50'),
(604, '常见的 XSS 注入攻击方式', '<p><a href="http://www.gracecode.com/archives/2491/">http://www.gracecode.com/archives/2491/</a></p>\r\n<div><a href="http://www.gracecode.com/archives/2517/">http://www.gracecode.com/archives/2517/</a></div>\r\n<p>前端开发常见的安全问题就是会遭受 <a title="http://en.wikipedia.org/wiki/Cross-site_scripting" href="http://en.wikipedia.org/wiki/Cross-site_scripting">XSS 注入攻击</a>，这里列举常见的代码注入方式。</p>\r\n<h3>Javascript 代码注入</h3>\r\n<p>Javascript 代码注入主要表现为直接引用未经校验的字符串、解析不安全的 JSON 数据（<a title="http://bob.pythonmac.org/archives/2005/12/05/remote-json-jsonp/" href="http://bob.pythonmac.org/archives/2005/12/05/remote-json-jsonp/">包括 JSONP</a>）等。</p>\r\n<p>很多时候会写这样的代码</p>\r\n<pre>\r\ndocument.write(''u name is'' + name);</pre>\r\n<p>这就会形成一定的安全性问题（如果服务器端没有过滤的话），比如 name 为下面的数据，在没有经过过滤时</p>\r\n<pre>\r\n'';alert(''xss'');//</pre>\r\n<pre>\r\n&quot;;alert(''xss'');//</pre>\r\n<pre>\r\n'''';!--&quot;&lt;xss&gt;=&amp;{()}</pre>\r\n<p>就会破坏原有代码结构，插入不期望的代码。</p>\r\n<h3>HTML 标签注入</h3>\r\n<p>HTML 注入是较为常见的一种方式，主要的注入入口为不周全的正则过滤、内联样式（针对 Exploer），下面是常见的注入代码</p>\r\n<p>逃过不周全的正则过滤，解决方案为使用 PHP 的 htmlspecialchars 以及 htmlentities 等类似函数转义。</p>\r\n<pre>\r\n&lt;sCrIpT src=xss.js&gt;&lt;/sCrIpT&gt;</pre>\r\n<pre>\r\n&lt;script src=xss.js&gt;\r\n&lt;/script&gt;</pre>\r\n<pre>\r\n&lt;script/xss src=&quot;xss.js&quot;&gt;&lt;/script&gt;</pre>\r\n<pre>\r\n&lt;script/SRC=&quot;xss.js&quot;&gt;&lt;/script&gt;</pre>\r\n<pre>\r\n&lt;&lt;script&gt;alert(&quot;xss&quot;);//&lt;&lt;/script&gt;</pre>\r\n<pre>\r\n&lt;script&gt;a=/xss/\r\nalert(a.source)&lt;/script&gt;</pre>\r\n<p>从图片标签中注入，在些论坛上比较常见</p>\r\n<pre>\r\n&lt;img src=&quot;javascript:alert(''xss'');&quot;&gt;</pre>\r\n<pre>\r\n&lt;img &quot;&quot;&quot;&gt;&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;&quot;&gt;</pre>\r\n<pre>\r\n&lt;img src=&quot;xss.php?param&quot;&gt;</pre>\r\n<p>从连接标签上注入（虽然本人没有发现过案例，不过也不能轻视）</p>\r\n<pre>\r\n&lt;script a=&quot;&gt;&quot; SRC=&quot;xss.js&quot;&gt;&lt;/script&gt;</pre>\r\n<pre>\r\n&lt;script =&quot;&gt;&quot; SRC=&quot;xss.js&quot;&gt;&lt;/script&gt;</pre>\r\n<pre>\r\n&lt;script a=&quot;&gt;&quot; '''' SRC=&quot;xss.js&quot;&gt;&lt;/script&gt;</pre>\r\n<p>其他容易注入的地方</p>\r\n<pre>\r\n&lt;body onload=alert(''xss'')&gt;</pre>\r\n<pre>\r\n&lt;iframe src=&quot;javascript:alert(''xss'');&quot;&gt;&lt;/iframe&gt;</pre>\r\n<pre>\r\n&lt;embed src=&quot;xss.swf&quot; AllowScriptAccess=&quot;always&quot;&gt;&lt;/embed&gt;</pre>\r\n<pre>\r\n&lt;meta http-equiv=&quot;Set-Cookie&quot; content=&quot;USERID=&lt;script&gt;alert(''xss'')&lt;/script&gt;&quot;&gt;</pre>\r\n<p>先摘记举例那么多，下期的内容包括&ldquo;CSS 注入&rdquo;、&ldquo;其他注入方法&rdquo;以及一般性解决方案，欢迎探讨和纠正。</p>\r\n<p><a title="http://www.gracecode.com/archives/2491/" href="http://www.gracecode.com/archives/2491/">接上一期</a>，这里主要考虑 CSS 注入的方式。CSS 注入主要为背景图注入和针对 Exploer 的 CSS Expression 注入。</p>\r\n<p>考虑没有完全将样式过滤的情况，下面的代码即有可能成为攻击代码</p>\r\n<pre>\r\n&lt;xss style=&quot;behavior: url(xss.htc);&quot;&gt;</pre>\r\n<p>上面的是针对 Exploer 的 htc 注入，htc 可以认为是个脚本。</p>\r\n<pre>\r\n&lt;div style=&quot;background-image: xss.jpg&quot;&gt;</pre>\r\n<p>谁会知道 xss.jpg 是什么内容呢？不过很多站点统计代码也是使用了这一原理。</p>\r\n<pre>\r\n&lt;div style=&quot;width: expression(alert(''xss''));&quot;&gt;</pre>\r\n<pre>\r\n&lt;img style=&quot;xss:expr/*xss*/ession(alert(''xss''))&quot;&gt;</pre>\r\n<pre>\r\nexp/*&lt;A style=''noxss:noxss(&quot;*//*&quot;);xss:ex/*xss*//*/*/pression(alert(&quot;xss&quot;))''&gt;</pre>\r\n<p>针对 Exploer 的 Expression 要保持&ldquo;淡定&rdquo;，最好的做法就是过滤 style 属性。</p>\r\n<p>如果没有将注释完全过滤充分，则又会在 Exploer 出现典型的注入漏洞</p>\r\n<pre>\r\n&lt;!--[if gte IE 4]&gt;\r\n    &lt;script&gt;alert(''xss'');&lt;/script&gt;\r\n&lt;![endif]--&gt;</pre>\r\n<p>安全性问题，这个时候我反而感谢 Exploer 提供那么多的&ldquo;机会&rdquo;。</p>\r\n<p><tt>-- Split --</tt></p>\r\n<p>那么如何预防 XSS 注入？主要还是需要在用户数据过滤方面得考虑周全，在这里不完全总结下几个 Tips</p>\r\n<ol>\r\n    <li>假定所有的用户输入数据都是&ldquo;邪恶&rdquo;的</li>\r\n    <li>弱类型的脚本语言必须保证类型和期望的一致</li>\r\n    <li>考虑周全的正则表达式</li>\r\n    <li>strip_tags、htmlspecialchars 这类函数很好用</li>\r\n    <li>外部的 Javascript 不一定就是可靠的</li>\r\n    <li>引号过滤必须要重点注意</li>\r\n    <li>除去不必要的 HTML 注释</li>\r\n    <li>Exploer 求你放过我吧&hellip;&hellip;</li>\r\n</ol>', '随笔', '', '2011-06-29 9:27:33'),
(605, '为什么使用&lt;!DOCTYPE HTML&gt;', '<p><a href="http://blog.wanz.im/2010/05/28/why_doctype_html/">http://blog.wanz.im/2010/05/28/why_doctype_html/</a></p>\r\n<p>不管是刚接触前端，还是你已经&ldquo;精通&rdquo;web前端开发的内容，你应该知道在你写html的时候需要定义文档类型；你知道如果没有它，浏览器在渲染页面的时候会使用怪异模式；你知道各个浏览器在怪异模式下对各个元素渲染是有差异的。所以你会写像这样的doctype：</p>\r\n<div class="wp_codebox_msgheader"><span class="right"><sup><a target="_blank" title="WP-CodeBox HowTo?" href="http://www.ericbess.com/ericblog/2008/03/03/wp-codebox/#examples"><span style="color: #99cc00">?</span></a></sup></span><span class="left"><a onclick="javascript:showCodeTxt(''p639code1''); return false;" href="javascript:;">View Code</a> HTML</span>\r\n<div class="codebox_clear">&nbsp;</div>\r\n</div>\r\n<div class="wp_codebox">\r\n<table>\r\n    <tbody>\r\n        <tr id="p6391">\r\n            <td class="line_numbers">\r\n            <pre>\r\n1\r\n</pre>\r\n            </td>\r\n            <td class="code" id="p639code1">\r\n            <pre class="html" style="font-family:monospace;">\r\n&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</pre>\r\n            </td>\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n</div>\r\n<p>好在现在的各种web开发工具都足够强大，支持插入模板代码，因此你并不需要把这又长又臭的doctype一个个字母的敲出来。但是如果你受够了它，你也许可以尝试下面这个写法：</p>\r\n<div class="wp_codebox_msgheader"><span class="right"><sup><a target="_blank" title="WP-CodeBox HowTo?" href="http://www.ericbess.com/ericblog/2008/03/03/wp-codebox/#examples"><span style="color: #99cc00">?</span></a></sup></span><span class="left"><a onclick="javascript:showCodeTxt(''p639code2''); return false;" href="javascript:;">View Code</a> HTML</span>\r\n<div class="codebox_clear">&nbsp;</div>\r\n</div>\r\n<div class="wp_codebox">\r\n<table>\r\n    <tbody>\r\n        <tr id="p6392">\r\n            <td class="line_numbers">\r\n            <pre>\r\n1\r\n</pre>\r\n            </td>\r\n            <td class="code" id="p639code2">\r\n            <pre class="html" style="font-family:monospace;">\r\n&lt;!DOCTYPE html&gt;</pre>\r\n            </td>\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n</div>\r\n<p>哇哦，很简洁哦！好处显而易见：一、你可以轻松的写下这个doctype，而不用担心会写错；二、它是向后兼容的，是的，html5的doctype就是这样写的，并且现代浏览器都认识它。</p>\r\n<p>如果你跟我一样一直以为：<strong><del datetime="2010-05-29T01:36:14+00:00">没有指定dtd将会开启浏览器的怪异模式</del>，这种说法是错的！</strong>正确的说法应该是没有定义doctype才会开启怪异模式，也就是说你只需要定义&lt;!doctype html&gt;就可以让浏览器在严格模式（标准模式）下渲染页面，而不需要指定某个类型dtd。让我们来回顾一下，所有的浏览器都需要两种模式：怪异模式和严格模式（也有人叫标准模式）。IE 6 for Windows/mac, Mozilla, Safari和Opera 都实现了这两种模式，但是IE 6以下版本永远定在了怪异模式。关于两种模式，你需要知道以下几点：</p>\r\n<blockquote style="line-height:1.5em;font-weight:bold">\r\n<ol>\r\n    <li>在标准化之前写的页面是没有doctype的，因此没有doctype的页面是在怪异模式下渲染的。</li>\r\n    <li>反过来说，如果web开发人员加入的doctype，说明他知道他所要做的事情，大部分的doctype会开启严格模式（标准模式），页面也会按照标准来渲染。</li>\r\n    <li>任何新的或者未知的doctype都会开启严格模式（标准模式）。</li>\r\n    <li>每个浏览器都有自己的方式来激活怪异模式。你可以看看这个清单：<a href="http://hsivonen.iki.fi/doctype/">http://hsivonen.iki.fi/doctype/</a></li>\r\n</ol>\r\n</blockquote>\r\n<p>注意：你可以根本不需要根据你选择的doctype来验证你的页面，只要doctype标签存在就足以开启严格模式（标准模式）了。如果你对我说的这些还是感到怀疑，那么请前往<a href="http://www.quirksmode.org/css/quirksmode.html#link2">http://www.quirksmode.org/css/quirksmode.html#link2</a>了解你想知道的内容。我们只需要一小段JavaScript代码就可以得到答案，它就是：</p>\r\n<div class="wp_codebox_msgheader"><span class="right"><sup><a target="_blank" title="WP-CodeBox HowTo?" href="http://www.ericbess.com/ericblog/2008/03/03/wp-codebox/#examples"><span style="color: #99cc00">?</span></a></sup></span><span class="left"><a onclick="javascript:showCodeTxt(''p639code3''); return false;" href="javascript:;">View Code</a> JAVASCRIPT</span>\r\n<div class="codebox_clear">&nbsp;</div>\r\n</div>\r\n<div class="wp_codebox">\r\n<table>\r\n    <tbody>\r\n        <tr id="p6393">\r\n            <td class="line_numbers">\r\n            <pre>\r\n1\r\n</pre>\r\n            </td>\r\n            <td class="code" id="p639code3">\r\n            <pre class="javascript" style="font-family:monospace;">\r\nmode<span style="color: #339933;">=</span>document.<span style="color: #660066;">compatMode</span><span style="color: #339933;">;</span></pre>\r\n            </td>\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n</div>\r\n<p>这个代码可以用来判断，当前浏览器是处于怪异模式还是标准模式，该属性的兼容性毋庸置疑，如果你表示怀疑，可以查看<a href="http://www.quirksmode.org/dom/w3c_html.html#t11">http://www.quirksmode.org/dom/w3c_html.html#t11</a>。你可以在你想测试的浏览器里访问：<a href="http://wanz.im/demo/doctype-test.html">http://wanz.im/demo/doctype-test.html</a>，便可看到结果了，据我所知，这样并没有激活怪异模式，即使是ie6下，如果你有什么新发现，欢迎给我留言。</p>', 'HTML5', '', '2011-09-18 18:07:42'),
(606, '利用Ant组织前端开发流程', '<p>&nbsp;<a href="http://hikejun.com/blog/?p=34">http://hikejun.com/blog/?p=34</a></p>\r\n<p><strong>什么是Ant?</strong></p>\r\n<p style="margin-top: 10px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; font-family: ''Lucida Grande'', ''Lucida Sans Unicode'', verdana, sans-serif; font-size: 12px; line-height: 22px; ">搞Java开发的人不应该陌生。我没搞过Java开发所以之前没接触过，最近听过一堂Zakas的课后，觉得这东西超好用。关于Ant的解释：&nbsp;<br />\r\n&ldquo;Ant是一种基于Java的build工具。理论上来说，它有些类似于（Unix）C中的make ，但没有make的缺陷。&rdquo;(出自http://www.kuqin.com/beginner/ant.html)。</p>\r\n<p style="margin-top: 10px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; font-family: ''Lucida Grande'', ''Lucida Sans Unicode'', verdana, sans-serif; font-size: 12px; line-height: 22px; ">&nbsp;</p>\r\n<p style="margin-top: 10px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; font-family: ''Lucida Grande'', ''Lucida Sans Unicode'', verdana, sans-serif; font-size: 12px; line-height: 22px; "><strong>需要一个什么样的前端开发流程?</strong></p>\r\n<p style="margin-top: 10px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; font-family: ''Lucida Grande'', ''Lucida Sans Unicode'', verdana, sans-serif; font-size: 12px; line-height: 22px; ">想想我们是怎么进行前端开发。&nbsp;<br />\r\n写代码 &mdash;-&gt; 执行代码 &mdash;-&gt; 发布</p>\r\n<p style="margin-top: 10px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; font-family: ''Lucida Grande'', ''Lucida Sans Unicode'', verdana, sans-serif; font-size: 12px; line-height: 22px; ">因为Javascript无法提前编译，所以代码有没有错只能在&ldquo;执行代码&rdquo;这个阶段才能发现。前端开发的一个特点是很多潜在的错误或设计缺陷不好预前发现，只有等到发布后不断的使用才能发现，但已给用户造成不好的使用体验。</p>\r\n<p style="margin-top: 10px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; font-family: ''Lucida Grande'', ''Lucida Sans Unicode'', verdana, sans-serif; font-size: 12px; line-height: 22px; ">所以如何保证高质量的代码和规避风险一直是讨论的话题。 雅虎美国的前端工程师Zakas建议建立一个完善的前端开发流程，让我们的前端开发更加井井有条。</p>\r\n<p style="margin-top: 10px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; font-family: ''Lucida Grande'', ''Lucida Sans Unicode'', verdana, sans-serif; font-size: 12px; line-height: 22px; ">一个比较合理前端开发流程：&nbsp;<br />\r\n写代码 &mdash;-&gt; 检验语法 &mdash;-&gt; 整合代码 &mdash;-&gt; 生成文档 &mdash;-&gt; 压缩代码 &mdash;-&gt; 布署测试环境 &mdash;-&gt; 单元测试 &mdash;-&gt; 发布</p>\r\n<p style="margin-top: 10px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; font-family: ''Lucida Grande'', ''Lucida Sans Unicode'', verdana, sans-serif; font-size: 12px; line-height: 22px; ">Ant可以轻松的使其中大部分环节自动化，如果再写的复杂点，可以实现全部自动化。</p>\r\n<p style="margin-top: 10px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; font-family: ''Lucida Grande'', ''Lucida Sans Unicode'', verdana, sans-serif; font-size: 12px; line-height: 22px; "><strong>如何创建一个前端开发流程?</strong></p>\r\n<p style="margin-top: 10px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; font-family: ''Lucida Grande'', ''Lucida Sans Unicode'', verdana, sans-serif; font-size: 12px; line-height: 22px; "><strong>用JSLint进行Javascript语法校验</strong>。这里要用到JSLint和Rhino。&nbsp;<br />\r\n首先到http://www.jslint.com/lint.html下载fulljslint.js, 再把rhino扩展贴在jslint后面，并修改一下：&nbsp;<br />\r\nif (!JSLINT(input, {rhino: true, passfail: false})) {&nbsp;<br />\r\nprint(&ldquo;jslint: 发现问题 &rdquo; + a[0]);&nbsp;<br />\r\n&hellip;&hellip;.&nbsp;<br />\r\nquit(1);&nbsp;<br />\r\n} else {&nbsp;<br />\r\n&hellip;&hellip;</p>\r\n<p style="margin-top: 10px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; font-family: ''Lucida Grande'', ''Lucida Sans Unicode'', verdana, sans-serif; font-size: 12px; line-height: 22px; ">校验的target：</p>\r\n<p style="margin-top: 10px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; font-family: ''Lucida Grande'', ''Lucida Sans Unicode'', verdana, sans-serif; font-size: 12px; line-height: 22px; "><strong>使用Ant内置的Concat任务合并文件</strong></p>\r\n<p style="margin-top: 10px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; font-family: ''Lucida Grande'', ''Lucida Sans Unicode'', verdana, sans-serif; font-size: 12px; line-height: 22px; ">开发时可以按照功能分成若干个独立的模块开发，在Build时再合并成一个文件。这样更容易维护，而且可以根据不同需求灵活的组合这些模块很方便。</p>\r\n<p style="margin-top: 10px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; font-family: ''Lucida Grande'', ''Lucida Sans Unicode'', verdana, sans-serif; font-size: 12px; line-height: 22px; "><strong>使用yuicompressor压缩文件</strong></p>\r\n<p style="margin-top: 10px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; font-family: ''Lucida Grande'', ''Lucida Sans Unicode'', verdana, sans-serif; font-size: 12px; line-height: 22px; ">压缩CSS同理，</p>\r\n<p style="margin-top: 10px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; font-family: ''Lucida Grande'', ''Lucida Sans Unicode'', verdana, sans-serif; font-size: 12px; line-height: 22px; "><strong>代码布署</strong></p>\r\n<p style="margin-top: 10px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; font-family: ''Lucida Grande'', ''Lucida Sans Unicode'', verdana, sans-serif; font-size: 12px; line-height: 22px; ">使用copy任务进行本地/局域网内布署</p>\r\n<p style="margin-top: 10px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; font-family: ''Lucida Grande'', ''Lucida Sans Unicode'', verdana, sans-serif; font-size: 12px; line-height: 22px; ">布署到远程服务器</p>\r\n<p style="margin-top: 10px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; font-family: ''Lucida Grande'', ''Lucida Sans Unicode'', verdana, sans-serif; font-size: 12px; line-height: 22px; ">&lt;ftp server=&quot;ftp.yourserver.com&quot;&nbsp;<br />\r\nremotedir=&rdquo;/_demo&rdquo;&nbsp;<br />\r\nuserid=&rdquo;your_username&rdquo;&nbsp;<br />\r\npassword=&rdquo;your_password&rdquo;&nbsp;<br />\r\ndepends=&rdquo;yes&rdquo;&nbsp;<br />\r\nverbose=&rdquo;yes&rdquo;&nbsp;<br />\r\nbinary=&rdquo;no&rdquo;&gt;</p>\r\n<p style="margin-top: 10px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; font-family: ''Lucida Grande'', ''Lucida Sans Unicode'', verdana, sans-serif; font-size: 12px; line-height: 22px; ">或使用SCP，但需要额外安装Ant插件 &ndash; jsch (http://www.jcraft.com/jsch/)。</p>\r\n<p style="margin-top: 10px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; font-family: ''Lucida Grande'', ''Lucida Sans Unicode'', verdana, sans-serif; font-size: 12px; line-height: 22px; ">Ant手册中(http://ant.apache.org/manual/index.html)可以看到，Ant有很丰富的内置组件，并且可以很方便引入外部扩展组件。Ant几乎没有不可能完成的任务!</p>\r\n<p style="margin-top: 10px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; font-family: ''Lucida Grande'', ''Lucida Sans Unicode'', verdana, sans-serif; font-size: 12px; line-height: 22px; ">UTF-8的文件有中文一定要指定编码：</p>\r\n<p style="margin-top: 10px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; font-family: ''Lucida Grande'', ''Lucida Sans Unicode'', verdana, sans-serif; font-size: 12px; line-height: 22px; ">&lt;concat destfile=&quot;${js.build.dir}/${js.build.file}&quot;&nbsp;<strong>encoding=&rdquo;UTF-8&Prime;</strong>&gt;</p>\r\n<p>&nbsp;</p>', '前端', '', '2011-09-18 18:09:00');
INSERT INTO `list` (`id`, `title`, `content`, `cat`, `marrow`, `time`) VALUES
(607, '用JSLint+Ant检验HTML代码', '<p><a href="http://hikejun.com/blog/?p=31">http://hikejun.com/blog/?p=31</a></p>\r\n<p>&nbsp;<a style="outline-style: none; outline-width: initial; outline-color: initial; text-decoration: none; color: rgb(0, 0, 0); font-weight: bold; " href="http://www.jslint.com/lint.html">JSLint</a>真是一个强大的工具。之前只是关注它对Javascript的作用方面，其实它同样可以检验HTML代码以及内联的Javascript代码。</p>\r\n<p style="margin-top: 10px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; font-family: ''Lucida Grande'', ''Lucida Sans Unicode'', verdana, sans-serif; font-size: 12px; line-height: 22px; ">JSlint应该说跟WDG HTML Validator(http://htmlhelp.com/tools/validator/)的作用不完全一样。JSLint不仅作语法检查，还做写法上的检查。JSLint的出发点是为了保证代码的品质。</p>\r\n<p style="margin-top: 10px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; font-family: ''Lucida Grande'', ''Lucida Sans Unicode'', verdana, sans-serif; font-size: 12px; line-height: 22px; ">比如在链接里写脚本会报错，如下：<br />\r\n[apply] Lint 在行 23 字符 14: Script URL.<br />\r\n[apply]</p>\r\n<h2 style="margin-top: 10px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; font-weight: normal; font-family: ''Hoefler Text'', Cambria, Georgia, ''Times New Roman'', Times, serif; font-size: 24px; line-height: 22px; "><a style="outline-style: none; outline-width: initial; outline-color: initial; text-decoration: none; color: rgb(0, 0, 0); font-weight: bold; " href="http://hikejun.com/blog/;">????????</a></h2>\r\n<p style="margin-top: 10px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; font-family: ''Lucida Grande'', ''Lucida Sans Unicode'', verdana, sans-serif; font-size: 12px; line-height: 22px; ">JSlint在语法检查上不会那么严格，但都是最重要的，比如标签是否对称嵌套，标签是否闭合。（详情见<a style="outline-style: none; outline-width: initial; outline-color: initial; text-decoration: none; color: rgb(0, 0, 0); font-weight: bold; " href="http://www.jslint.com/lint.html">http://www.jslint.com/lint.html</a>）</p>\r\n<p style="margin-top: 10px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; font-family: ''Lucida Grande'', ''Lucida Sans Unicode'', verdana, sans-serif; font-size: 12px; line-height: 22px; ">将检验HTML代码这个任务加入到前端开发Build环节中。但在实践中，我遇到了编码问题，如果源文件是UTF-8的就会有麻烦。迫不得以采取一个笨方法，通过ant的copy任务先将源文件备分为ISO-8859-1编码（ant不支持GBK的转换）的文件，再对它进行校验。之后再统一删除备分文件。</p>', '前端', '', '2011-09-18 18:08:47'),
(608, 'Ant+Svn管理项目代码', '<p><a href="http://hikejun.com/blog/?p=28">http://hikejun.com/blog/?p=28</a></p>\r\n<p>&nbsp;把频繁的SVN操作用Ant完成是非常合适的。首选使用SvnAnt(<a title="http://subclipse.tigris.org/svnant.html" style="outline-style: none; outline-width: initial; outline-color: initial; text-decoration: none; color: rgb(0, 0, 0); font-weight: bold; " href="http://subclipse.tigris.org/svnant.html">http://subclipse.tigris.org/svnant.html</a>)。</p>\r\n<div style="font-family: Verdana; font-size: 13px; line-height: 22px; ">从SvnAnt文档(<a title="http://subclipse.tigris.org/svnant/svn.html" style="outline-style: none; outline-width: initial; outline-color: initial; text-decoration: none; color: rgb(0, 0, 0); font-weight: bold; " href="http://subclipse.tigris.org/svnant/svn.html">http://subclipse.tigris.org/svnant/svn.html</a>)看它可以完成所有SVN操作。</div>\r\n<div style="font-family: Verdana; font-size: 13px; line-height: 22px; ">&nbsp;</div>\r\n<div style="font-family: Verdana; font-size: 13px; line-height: 22px; ">用SvnAnt好处：</div>\r\n<div style="font-family: Verdana; font-size: 13px; line-height: 22px; ">1. 简化使用</div>\r\n<div style="font-family: Verdana; font-size: 13px; line-height: 22px; ">2. 批量执行SVN命令</div>\r\n<div style="font-family: Verdana; font-size: 13px; line-height: 22px; ">3. 规范SVN的操作</div>\r\n<div style="font-family: Verdana; font-size: 13px; line-height: 22px; ">4. 其他开发者维护方便</div>\r\n<div style="font-family: Verdana; font-size: 13px; line-height: 22px; ">&nbsp;</div>\r\n<div style="font-family: Verdana; font-size: 13px; line-height: 22px; ">下载和安装：</div>\r\n<div style="font-family: Verdana; font-size: 13px; line-height: 22px; ">我安装的是SvnAnt 1.2.x（对应于subversion 1.5.0）到这里下载<a title="http://subclipse.tigris.org/svnant.html" style="outline-style: none; outline-width: initial; outline-color: initial; text-decoration: none; color: rgb(0, 0, 0); font-weight: bold; " href="http://subclipse.tigris.org/svnant.html">http://subclipse.tigris.org/svnant.html</a>Zip包文件，或从<a title="http://subclipse.tigris.org/svn/subclipse/trunk/svnant/" style="outline-style: none; outline-width: initial; outline-color: initial; text-decoration: none; color: rgb(0, 0, 0); font-weight: bold; " href="http://subclipse.tigris.org/svn/subclipse/trunk/svnant/">http://subclipse.tigris.org/svn/subclipse/trunk/svnant/</a><span>&nbsp;</span>(用户名guest, 密码为空)签出最新的代码再编译。前者更省事。解开Zip包后，将lib目录的所有.jar文件拷到ANT_HOMElib下。准备工作就完了。</div>\r\n<div style="font-family: Verdana; font-size: 13px; line-height: 22px; ">&nbsp;</div>\r\n<div style="font-family: Verdana; font-size: 13px; line-height: 22px; ">编写build.xml文件</div>\r\n<div style="font-family: Verdana; font-size: 13px; line-height: 22px; ">\r\n<div>这句是必须的，加载svn任务。</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;</div>\r\n<div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;</div>\r\n</div>\r\n</div>\r\n<div style="font-family: Verdana; font-size: 13px; line-height: 22px; ">&nbsp;</div>\r\n<div style="font-family: Verdana; font-size: 13px; line-height: 22px; ">\r\n<div>&nbsp;</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;</div>\r\n</div>\r\n<div style="font-family: Verdana; font-size: 13px; line-height: 22px; ">&nbsp;</div>\r\n<p style="margin-top: 10px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; font-family: Verdana; font-size: 13px; line-height: 22px; ">&nbsp;</p>\r\n<div style="font-family: Verdana; font-size: 13px; line-height: 22px; ">自动加时间戳：</div>\r\n<div style="font-family: Verdana; font-size: 13px; line-height: 22px; ">\r\n<div>&nbsp;</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;</div>\r\n</div>\r\n<p style="margin-top: 10px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; font-family: Verdana; font-size: 13px; line-height: 22px; ">&nbsp;</p>\r\n<div style="font-family: Verdana; font-size: 13px; line-height: 22px; ">\r\n<div>&nbsp;</div>\r\n<div>&nbsp;</div>\r\n<div>&lt;property name=&quot;dir.copy.dest&quot; value=&quot;${svn.url}/imageuploader/tags/imageuploader_${project.version}_<strong>${build.time}</strong>&rdquo; /&gt;</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;</div>\r\n</div>\r\n<p style="margin-top: 10px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; font-family: Verdana; font-size: 13px; line-height: 22px; ">&nbsp;</p>\r\n<div style="font-family: Verdana; font-size: 13px; line-height: 22px; ">完整：<a title="http://hikejun.com/sharing/ant/build_svn.xml" style="outline-style: none; outline-width: initial; outline-color: initial; text-decoration: none; color: rgb(0, 0, 0); font-weight: bold; " href="http://hikejun.com/sharing/ant/build_svn.xml">http://hikejun.com/sharing/ant/build_svn.xml</a></div>', '前端', '', '2011-09-18 18:08:35'),
(609, '黄易山-------Facebook卓越研发文化中的宝贵经验', '<p>&nbsp;<strong style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; outline-width: 0px; outline-style: initial; outline-color: initial; font-size: 14px; ">Facebook前工程总监黄易山撰写了一系列文章，很好地总结了Facebook卓越研发文化中的宝贵经验。</strong></p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>招聘是第一位的 &nbsp;<a target="_blank" href="http://www.programmer.com.cn/5323/">http://www.programmer.com.cn/5323/</a></p>\r\n<p>让亲身实践者执行工作流程 <a target="_blank" href="http://www.programmer.com.cn/5660/">http://www.programmer.com.cn/5660/</a></p>\r\n<p>内部晋升 <a target="_blank" href="http://www.programmer.com.cn/6305/">http://www.programmer.com.cn/6305/</a></p>\r\n<p>工欲善其事，必先利其器 <a target="_blank" href="http://www.programmer.com.cn/6790/">http://www.programmer.com.cn/6790/</a></p>\r\n<p>技术型领导 <a target="_blank" href="http://www.programmer.com.cn/7020/">http://www.programmer.com.cn/7020/</a></p>\r\n<p>&nbsp;</p>', '随笔', '', '2011-07-06 8:31:51'),
(610, 'fieldset在非IE浏览下盒模型解析不正确', '<p><a href="http://stackoverflow.com/questions/1673346/fieldset-firefox-overflow-css-fix">http://stackoverflow.com/questions/1673346/fieldset-firefox-overflow-css-fix</a></p>\r\n<p>解决办法：</p>\r\n<pre title="code" class="brush: css;">\r\nfieldset {\r\n    display: table-column;\r\n}\r\n&lt;!&ndash;[if IE]&gt;\r\nfieldset {\r\n    display: block;\r\n}\r\n&lt;![endif]&ndash;&gt;</pre>\r\n<p>&nbsp;</p>', 'CSS', '', '2011-09-18 18:11:00'),
(611, '一些JavaScript Quiz', '<p>&nbsp;<a href="http://www.cnblogs.com/rainman/archive/2010/10/16/1853222.html">http://www.cnblogs.com/rainman/archive/2010/10/16/1853222.html</a></p>\r\n<h3 style="margin-top: 10px; margin-right: 0px; margin-bottom: 10px; margin-left: 5px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; font-weight: bold; color: rgb(0, 0, 0); line-height: 1.8; font-size: 14px; background-image: url(http://docs.kissyui.com/kissy/docs/assets/dotted_line.gif); background-attachment: initial; background-origin: initial; background-clip: initial; background-color: initial; font-family: Tahoma, Arial, 宋体, sans-serif; background-position: 0px 100%; background-repeat: repeat no-repeat; ">a.x = a = { }, 深入理解赋值表达式</h3>\r\n<pre title="code" class="brush: jscript;">\r\nvar o = {x : 1};\r\nvar a = o;\r\n\r\na.x = a = {name:100};\r\n\r\nconsole.log(a.x);    // undefined\r\nconsole.log(o.x);    // {name:100}\r\n\r\n// a.x = a = {name:100};\r\n// 等价于 a.x = (a = {name:100});\r\n// 首先计算a.x的引用，然后计算(a = {name:100})的返回值</pre>\r\n<p>&nbsp;</p>\r\n<h3 style="margin-top: 10px; margin-right: 0px; margin-bottom: 10px; margin-left: 5px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; font-weight: bold; color: rgb(0, 0, 0); line-height: 1.8; font-size: 14px; background-image: url(http://docs.kissyui.com/kissy/docs/assets/dotted_line.gif); background-attachment: initial; background-origin: initial; background-clip: initial; background-color: initial; font-family: Tahoma, Arial, 宋体, sans-serif; background-position: 0px 100%; background-repeat: repeat no-repeat; ">if 语句的简写</h3>\r\n<pre title="code" class="brush: jscript;">\r\nvar condition = true, numb = 0;\r\nif(condition) {\r\n    alert(''rain-man'')\r\n}\r\nif(condition) {\r\n    numb = 1 + 2;\r\n}</pre>\r\n<p>等同于</p>\r\n<pre title="code" class="brush: jscript;">\r\nvar condition = true, numb = 0;\r\ncondition &amp;&amp; alert(''rain-man'');\r\ncondition &amp;&amp; (numb = 1 + 2);</pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<h3 style="margin-top: 10px; margin-right: 0px; margin-bottom: 10px; margin-left: 5px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; font-weight: bold; color: rgb(0, 0, 0); line-height: 1.8; font-size: 14px; background-image: url(http://docs.kissyui.com/kissy/docs/assets/dotted_line.gif); background-attachment: initial; background-origin: initial; background-clip: initial; background-color: initial; background-position: 0px 100%; background-repeat: repeat no-repeat; ">&amp;&amp; 和 || 的计算取值</h3>\r\n<pre title="code" class="brush: jscript;">\r\n(true &amp;&amp; 222);	    // 222\r\n!!(true &amp;&amp; 222);    // true\r\n(false &amp;&amp; 222 );    // false\r\n(false || 222);     // 222\r\n!!(false || 222);   // true</pre>\r\n<p>!!variable 会返回和原值相等的boolean值</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<h3 style="margin-top: 10px; margin-right: 0px; margin-bottom: 10px; margin-left: 5px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; font-weight: bold; color: rgb(0, 0, 0); line-height: 1.8; font-size: 14px; background-image: url(http://docs.kissyui.com/kissy/docs/assets/dotted_line.gif); background-attachment: initial; background-origin: initial; background-clip: initial; background-color: initial; background-position: 0px 100%; background-repeat: repeat no-repeat; ">Object的构造</h3>\r\n<pre title="code" class="brush: jscript;">\r\nfunction Object() { [native code] }\r\nObject.prototype = {\r\n	constructor: function Object() { [native code] },\r\n	hasOwnProperty: function hasOwnProperty() { [native code] },\r\n	isPrototypeOf: function isPrototypeOf() { [native code] },\r\n	propertyIsEnumerable: function propertyIsEnumerable() { [native code] },\r\n	toLocaleString: function toLocaleString() { [native code] },\r\n	toString: function toString() { [native code] },\r\n	valueOf: function valueOf() { [native code] }\r\n};\r\n\r\nObject.prototype.constructor === Object;    // true</pre>\r\n<p>&nbsp;</p>\r\n<h3 style="margin-top: 10px; margin-right: 0px; margin-bottom: 10px; margin-left: 5px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; font-weight: bold; color: rgb(0, 0, 0); line-height: 1.8; font-size: 14px; background-image: url(http://docs.kissyui.com/kissy/docs/assets/dotted_line.gif); background-attachment: initial; background-origin: initial; background-clip: initial; background-color: initial; background-position: 0px 100%; background-repeat: repeat no-repeat; ">prototype中的一些细节</h3>\r\n<pre title="code" class="brush: jscript;">\r\nvar A = function(){\r\n    this.name = ''rain-man'';\r\n};\r\nA.prototype = {\r\n    name : ''cnblogs''\r\n};\r\nvar o = new A();\r\nconsole.log(o.name);    // ''rain-man''</pre>\r\n<pre title="code" class="brush: jscript;">\r\nvar B = function(){};\r\nB.prototype = {\r\n    name : ''obj-B''\r\n};\r\n\r\nvar o = new B();\r\no.name = ''obj-c'';\r\ndelete o.name;\r\nconsole.log(o.name);    //''obj-B''，暴漏原型链</pre>\r\n<p>&nbsp;</p>\r\n<h3 style="margin-top: 10px; margin-right: 0px; margin-bottom: 10px; margin-left: 5px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; font-weight: bold; color: rgb(0, 0, 0); line-height: 1.8; font-size: 14px; background-image: url(http://docs.kissyui.com/kissy/docs/assets/dotted_line.gif); background-attachment: initial; background-origin: initial; background-clip: initial; background-color: initial; background-position: 0px 100%; background-repeat: repeat no-repeat; ">创建对象，并保持原型链</h3>\r\n<pre title="code" class="brush: jscript;">\r\nvar O = function(obj) {\r\n    function T() {}\r\n    T.prototype = obj;\r\n    return new T();\r\n};\r\n\r\nvar obj = {name: ''obj'', age: 0 }, \r\n    obj1 = O(obj), \r\n    obj2 = O(obj1);\r\n\r\n// 更改原型链的一处，所有原型链都会更改\r\nobj.name = ''superclass'';    \r\nconsole.log(obj1.name);    // ''superclass''\r\nconsole.log(obj2.name);    // ''superclass''\r\n\r\n// 每一层可单独处理\r\nobj1.name = 100;\r\nconsole.log(obj1.name);    //100\r\ndelete obj1.name;    //暴漏原型链\r\nconsole.log(obj1.name);    // ''superclass''</pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>', 'JavaScript', '', '2011-07-20 8:54:44'),
(612, 'js本地存储解决方案(localStorage与userData)', '<p>WEB应用的快速发展，是的本地存储一些数据也成为一种重要的需求，实现的方案也有很多，最普通的就是cookie了，大家也经常都用，但是cookie的缺点是显而易见的，其他的方案比如：IE6以上的userData，Firefox下面的globalStorage，以及Flash的本地存储，除了Flash之外，其他的几个都有一些兼容性的问题。</p>\r\n<h2>sessionStorage与localStorage</h2>\r\n<p>Web Storage实际上由两部分组成：sessionStorage与localStorage。</p>\r\n<p>sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。</p>\r\n<p>localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。</p>\r\n<h2>userData</h2>\r\n<p><strong>语法：</strong></p>\r\n<p>XML<span class="Apple-tab-span" style="white-space: pre;">	</span> &lt;Prefix: CustomTag ID=sID STYLE=&quot;behavior:url(''#default#userData'')&quot; /&gt;</p>\r\n<p>HTML<span class="Apple-tab-span" style="white-space: pre;">	</span> &lt;ELEMENT STYLE=&quot;behavior:url(''#default#userData'')&quot; ID=sID&gt;</p>\r\n<p>Scripting<span class="Apple-tab-span" style="white-space: pre;">	</span> object .style.behavior = &quot;url(''#default#userData'')&quot;</p>\r\n<p>object .addBehavior (&quot;#default#userData&quot;)</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p><strong>属性:</strong></p>\r\n<p>expires 设置或者获取 userData behavior 保存数据的失效日期。</p>\r\n<p>XMLDocument 获取 XML 的引用。</p>\r\n<p><strong>方法:</strong></p>\r\n<p>getAttribute() 获取指定的属性值。</p>\r\n<p>load(object) 从 userData 存储区载入存储的对象数据。</p>\r\n<p>removeAttribute() 移除对象的指定属性。</p>\r\n<p>save(object) 将对象数据存储到一个 userData 存储区。</p>\r\n<p>setAttribute() 设置指定的属性值。</p>\r\n<h2 style="font-size: 1.5em;">localStorage</h2>\r\n<p><strong>方法：</strong></p>\r\n<p>localStorage.getItem(key):获取指定key本地存储的值</p>\r\n<p>localStorage.setItem(key,value)：将value存储到key字段</p>\r\n<p>localStorage.removeItem(key):删除指定key本地存储的值</p>\r\n<h2>封装</h2>\r\n<pre title="code" class="brush: jscript;">\r\n    localData = {\r\n        hname:location.hostname?location.hostname:''localStatus'',\r\n        isLocalStorage:window.localStorage?true:false,\r\n        dataDom:null,\r\n        initDom:function(){ //初始化userData\r\n            if(!this.dataDom){\r\n                try{\r\n                    this.dataDom = document.createElement(''input'');//这里使用hidden的input元素\r\n                    this.dataDom.type = ''hidden'';\r\n                    this.dataDom.style.display = &quot;none&quot;;\r\n                    this.dataDom.addBehavior(''#default#userData'');//这是userData的语法\r\n                    document.body.appendChild(this.dataDom);\r\n                    var exDate = new Date();\r\n                    exDate = exDate.getDate()+30;\r\n                    this.dataDom.expires = exDate.toUTCString();//设定过期时间\r\n                }catch(ex){\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        },\r\n        set:function(key,value){\r\n            if(this.isLocalStorage){\r\n                window.localStorage.setItem(key,value);\r\n            }else{\r\n                if(this.initDom()){\r\n                    this.dataDom.load(this.hname);\r\n                    this.dataDom.setAttribute(key,value);\r\n                    this.dataDom.save(this.hname)\r\n                }\r\n            }\r\n        },\r\n        get:function(key){\r\n            if(this.isLocalStorage){\r\n                return window.localStorage.getItem(key);\r\n            }else{\r\n                if(this.initDom()){\r\n                    this.dataDom.load(this.hname);\r\n                    return this.dataDom.getAttribute(key);\r\n                }\r\n            }\r\n        },\r\n        remove:function(key){\r\n            if(this.isLocalStorage){\r\n                localStorage.removeItem(key);\r\n            }else{\r\n                if(this.initDom()){\r\n                    this.dataDom.load(this.hname);\r\n                    this.dataDom.removeAttribute(key);\r\n                    this.dataDom.save(this.hname)\r\n                }\r\n            }\r\n        }\r\n    }</pre>', 'JavaScript', '0', '2011-07-20 9:13:41'),
(613, '如何判断Javascript对象是否存在', '<div class="asset-more" id="more">\r\n<p>举例来说，请考虑以下情况。</p>\r\n<p>现在，我们要判断一个<strong>全局对象</strong>myObj是否存在，如果不存在，就对它进行声明。用自然语言描述的算法如下：</p>\r\n<blockquote>\r\n<p>　　if (myObj不存在){</p>\r\n<p>　　　　声明myObj;</p>\r\n<p>　　}</p>\r\n</blockquote>\r\n<p>你可能会觉得，写出这段代码很容易。但是实际上，它涉及的语法问题，远比我们想象的复杂。<a target="_blank" href="http://perfectionkills.com/unnecessarily-comprehensive-look-into-a-rather-insignificant-issue-of-global-objects-creation/">Juriy Zaytsev</a>指出，判断一个Javascript对象是否存在，有超过50种写法。只有对Javascript语言的实现细节非常清楚，才可能分得清它们的区别。</p>\r\n<p><strong>第一种写法</strong></p>\r\n<p>根据直觉，你可能觉得可以这样写：</p>\r\n<blockquote>\r\n<p>　　if (!myObj) {</p>\r\n<p>　　　　myObj = { };</p>\r\n<p>　　}</p>\r\n</blockquote>\r\n<p>但是，运行这段代码，浏览器会直接抛出ReferenceError错误，导致运行中断。请问错在哪里？</p>\r\n<p>对了，if语句判断myObj是否为空时，这个变量还不存在，所以才会报错。改成下面这样，就能正确运行了。</p>\r\n<blockquote>\r\n<p>　　if (!myObj) {</p>\r\n<p>　　　　<strong>var myObj = { };</strong></p>\r\n<p>　　}</p>\r\n</blockquote>\r\n<p>为什么加了一个var以后，就不报错了？难道这种情况下，if语句做判断时，myObj就已经存在了吗？</p>\r\n<p>要回答这个问题，就必须知道Javascript解释器的工作方式。Javascript语言是&quot;先解析，后运行&quot;，解析时就已经完成了变量声明，所以上面的代码实际等同于：</p>\r\n<blockquote>\r\n<p>　　<strong>var myObj;</strong></p>\r\n<p>　　if (!myObj) {</p>\r\n<p>　　　　var myObj = { };</p>\r\n<p>　　}</p>\r\n</blockquote>\r\n<p>因此，if语句做判断时，myObj确实已经存在了，所以就不报错了。这就是var命令的&quot;代码提升&quot;（hoisting）作用。Javascript解 释器，只&quot;提升&quot;var命令定义的变量，对不使用var命令、直接赋值的变量不起作用，这就是为什么不加var会报错的原因。</p>\r\n<p><strong>第二种写法</strong></p>\r\n<p>除了var命令，还可以有另一种改写，也能得到正确的结果：</p>\r\n<blockquote>\r\n<p>　　<strong>if (!window.myObj) {</strong></p>\r\n<p>　　　　myObj = { };</p>\r\n<p>　　}</p>\r\n</blockquote>\r\n<p>window是javascript的顶层对象，所有的全局变量都是它的属性。所以，判断myobj是否为空，等同于判断window对象是否有 myobj属性，这样就可以避免因为myObj没有定义而出现ReferenceError错误。不过，从代码的规范性考虑，最好还是对第二行加上 var：</p>\r\n<blockquote>\r\n<p>　　if (!window.myObj) {</p>\r\n<p>　　　　<strong>var myObj = { };</strong></p>\r\n<p>　　}</p>\r\n</blockquote>\r\n<p>或者写成这样：</p>\r\n<blockquote>\r\n<p>　　if (!window.myObj) {</p>\r\n<p>　　　　<strong>window.myObj = { };</strong></p>\r\n<p>　　}</p>\r\n</blockquote>\r\n<p><strong>第三种写法</strong></p>\r\n<p>上面这种写法的缺点在于，在某些运行环境中（比如V8、Rhino），window未必是顶层对象。所以，考虑改写成：</p>\r\n<blockquote>\r\n<p>　　if (!<strong>this.myObj</strong>) {</p>\r\n<p>　　　　<strong>this.myObj</strong> = { };</p>\r\n<p>　　}</p>\r\n</blockquote>\r\n<p>在全局变量的层面中，this关键字总是指向顶层变量，所以就可以独立于不同的运行环境。</p>\r\n<p><strong>第四种写法</strong></p>\r\n<p>但是，上面这样写可读性较差，而且this的指向是可变的，容易出错，所以进一步改写：</p>\r\n<blockquote>\r\n<p>　　<strong>var global = this;</strong></p>\r\n<p>　　if (!global.myObj) {</p>\r\n<p>　　　　global.myObj = { };</p>\r\n<p>　　}</p>\r\n</blockquote>\r\n<p>用自定义变量global表示顶层对象，就清楚多了。</p>\r\n<p><strong>第五种写法</strong></p>\r\n<p>还可以使用typeof运算符，判断myObj是否有定义。</p>\r\n<blockquote>\r\n<p>　　if (<strong>typeof myObj == &quot;undefined&quot;</strong>) {</p>\r\n<p>　　　　var myObj = { };</p>\r\n<p>　　}</p>\r\n</blockquote>\r\n<p>这是目前使用最广泛的判断javascript对象是否存在的方法。</p>\r\n<p><strong>第六种写法</strong></p>\r\n<p>由于在已定义、但未赋值的情况下，myObj的值直接等于undefined，所以上面的写法可以简化：</p>\r\n<blockquote>\r\n<p>　　if (<strong>myObj == undefined</strong>) {</p>\r\n<p>　　　　var myObj = { };</p>\r\n<p>　　}</p>\r\n</blockquote>\r\n<p>这里有两个地方需要注意，首先第二行的var关键字不能少，否则会出现ReferenceError错误，其次undefined不能加单引号或双引号，因为这里比较的是undefined这种数据类型，而不是&quot;undefined&quot;这个字符串。</p>\r\n<p><strong>第七种写法</strong></p>\r\n<p>上面的写法在&quot;精确比较&quot;（===）的情况下，依然成立：</p>\r\n<blockquote>\r\n<p>　　if (<strong>myObj === undefined</strong>) {</p>\r\n<p>　　　　var myObj = { };</p>\r\n<p>　　}</p>\r\n</blockquote>\r\n<p><strong>第八种写法</strong></p>\r\n<p>根据javascript的语言设计，undefined == null，所以比较myObj是否等于null，也能得到正确结果：</p>\r\n<blockquote>\r\n<p>　　if (<strong>myObj == null</strong>) {</p>\r\n<p>　　　　var myObj = { };</p>\r\n<p>　　}</p>\r\n</blockquote>\r\n<p>不过，虽然运行结果正确，但是从语义上看，这种判断方法是错的，应该避免。因为null指的是已经赋值为null的空对象，即这个对象实际上是有值的，而 undefined指的是不存在或没有赋值的对象。因此，这里只能使用&quot;比较运算符&quot;（==），如果这里使用&quot;精确比较运算符&quot;（===），就会出错。</p>\r\n<p><strong>第九种写法</strong></p>\r\n<p>还可以使用in运算符，判断myObj是否为顶层对象的一个属性：</p>\r\n<blockquote>\r\n<p>　　<strong>if (!(''myObj'' in window)) {</strong></p>\r\n<p>　　　　window.myObj = { };</p>\r\n<p>　　}</p>\r\n</blockquote>\r\n<p><strong>第十种写法</strong></p>\r\n<p>最后，使用hasOwnProperty方法，判断myObj是否为顶层对象的一个属性：</p>\r\n<blockquote>\r\n<p>　　<strong>if (!this.hasOwnProperty(''myObj'')) {</strong></p>\r\n<p>　　　　this.myObj = { };</p>\r\n<p>　　}</p>\r\n</blockquote>\r\n<p><strong>总结</strong></p>\r\n<p>1. 如果只判断对象是否存在，推荐使用第五种写法。</p>\r\n<p>2. 如果除了对象是否存在，还要判断对象是否有null值，推荐使用第一种写法。</p>\r\n<p>3. 除非特殊情况，所有变量都应该使用var命令声明。</p>\r\n<p>4. 为了跨平台，建议避免使用window表示顶层对象。</p>\r\n<p>5. 在Javascript语言中，null和undefined容易产生混淆。在可能同时涉及两者的情况下，建议使用&quot;精确比较&quot;运算符（===）。</p>\r\n</div>', 'JavaScript', '', '2011-08-22 8:49:57'),
(614, 'Css Bug总结', '<p>&nbsp;<a href="http://ued.alipay.com/wd/2010/07/28/ie-beat-the-holy-canon-css-bug-table/">http://ued.alipay.com/wd/2010/07/28/ie-beat-the-holy-canon-css-bug-table/</a></p>\r\n<p><a href="http://haslayout.net/css/">http://haslayout.net/css/</a></p>', 'CSS', '', '2011-08-22 8:50:26'),
(615, '手持终端css框架', '<p>&nbsp;simplegrid 简单小巧的css框架，各种屏幕分辨率自适应，手持终端内自动折行排列</p>\r\n<div><a href="http://simplegrid.info/">http://simplegrid.info/</a></div>', 'CSS', '', '2011-08-22 8:50:44'),
(616, '前端概念', '<ol>\r\n    <li>平稳退化：确保网页在没有JavaScript的情况下也能正常工作</li>\r\n    <li>分离JavaScript：把网页的结构和内容与JavaScript脚本的动作行为分开</li>\r\n    <li>向后兼容性：确保老版本的浏览器不会因为你的JavaScript脚本而死掉</li>\r\n    <li>性能考虑：确定脚本执行的性能最优</li>\r\n    <li>渐进增强：用一些额外的信息层去包裹原始数据。按照&ldquo;渐进增强&rdquo;原则创建出的网页几乎都符合&ldquo;平稳退化&rdquo;原则</li>\r\n</ol>', '前端', '', '2011-09-18 9:54:46');

-- --------------------------------------------------------

--
-- 表的结构 `user`
--

CREATE TABLE IF NOT EXISTS `user` (
  `user_id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(100) CHARACTER SET gbk NOT NULL,
  `password` varchar(100) CHARACTER SET gbk NOT NULL,
  PRIMARY KEY (`user_id`)
) ENGINE=InnoDB  DEFAULT CHARSET=latin1 AUTO_INCREMENT=4 ;

--
-- 导出表中的数据 `user`
--

INSERT INTO `user` (`user_id`, `name`, `password`) VALUES
(1, 'jxsr_lxj', '9dc3ff796374b3561138cc44aaca192d'),
(2, 'seanlou', 'a25167dca02b1371b8bebfa1a49b20d3'),
(3, 'lxj', '807f60a539e40a2e123ad0c53545dde5');
