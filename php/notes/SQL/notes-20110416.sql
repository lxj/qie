-- phpMyAdmin SQL Dump
-- version 2.11.6
-- http://www.phpmyadmin.net
--
-- 主机: localhost
-- 生成日期: 2011 年 04 月 16 日 03:00
-- 服务器版本: 6.0.4
-- PHP 版本: 5.2.0RC4

SET SQL_MODE="NO_AUTO_VALUE_ON_ZERO";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;

--
-- 数据库: `notes`
--

-- --------------------------------------------------------

--
-- 表的结构 `list`
--

CREATE TABLE IF NOT EXISTS `list` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'id',
  `title` varchar(100) NOT NULL,
  `content` varchar(30000) NOT NULL COMMENT '内容',
  `cat` varchar(500) NOT NULL COMMENT '分类',
  `time` varchar(50) NOT NULL COMMENT '时间',
  PRIMARY KEY (`id`)
) ENGINE=MyISAM  DEFAULT CHARSET=gbk AUTO_INCREMENT=513 ;

--
-- 导出表中的数据 `list`
--

INSERT INTO `list` (`id`, `title`, `content`, `cat`, `time`) VALUES
(2, '', '在设置Frame时，有一属性是scrolling="yes/no/auto"，IE6的mozilla都支持，但很显然地，IE的开发人员在这个地方懒了一下，他们对auto的理解很不人性化。auto的意思是自动，就是要的时候有，不要的时候没有。但如果设成auto，则在网页过长需要出竖起滚动条时，IE会自动地把水平滚动条也显示出来，哪怕网页完全不超宽。而设成yes时，IE则会一直出竖直滚动条，而不随便出水平条，这差不多是对的。所以如果要用Frame的话，还是要把这个属性设成Yes，这完全是为迁就IE。 mozilla则在任何时候都是对的。(google) \r\n', 'CSS', '2011-01-05 21:12:30'),
(5, '', '<p>CSS方法解决chrome 12像素字体限制：中文版的chrome有个12px字体限制的问题，就是当字体小于12px时候都以12px来显示，可以使用Webkit 的内核的 -webkit-text-size-adjust 的私有 CSS 属性来解决，比如下面的代码就可以成功的解决，通过它即可实现字体大小不随终端设备或浏览器影响。样式定义如下： #chrome10px{ -webkit-text-size-adjust:none; font-size:10px}</p>', 'CSS', '2011-01-05 21:00:30'),
(4, '', '<pre class="brush: jscript;" title="code">\r\nvar oFCKeditor = new FCKeditor(''content'');//传入参数为表单元素（由FCKeditor生成的input或textarea）的name\r\noFCKeditor.BasePath=''FCKEditor-syntaxhighlight/fckeditor/'';//指定FCKeditor根路径，也就是fckeditor.js所在的路径\r\noFCKeditor.Height=''200px'';\r\noFCKeditor.ToolbarSet=''Syntax2Demo'';//&lsquo;Default&rsquo;指定工具栏\r\noFCKeditor.Value=&quot;&quot;;//默认值\r\noFCKeditor.Create();\r\n</pre>', 'JavaScript', '2011-01-05 21:09:30'),
(7, '', '<p>给table定义align=&quot;left&quot;或align=&quot;right&quot;时就像是给div标签定义浮动，所以记得给父层定义清除浮动的样式，要不然js获取父层的offsetHeight时其值时0</p>', 'CSS', '2011-01-04 21:11:30'),
(6, '', 'iframe,object和img一样，有时候在非IE浏览器下底部会有间隙，定义vertical-align:top清除下就行了', 'CSS', '2011-01-04 21:31:30'),
(3, '', '更改SVN中已经提交的版本的注释，提示说“请管理员创建pre-revprop-change钩子”，解决方法为在hooks目录下创建pre-revprop-change.bat，里面的代码如下：pre-revprop-change.bat所示(google) \r\n', 'SVN', '2011-01-05 21:10:30'),
(1, '', '用line-height:9999px可以达到隐藏input按钮的文字的效果\r\n', 'CSS', '2011-01-05 21:31:30'),
(8, '', '用text-indent:-9999px隐藏input按钮的文字时，一定要给这按钮float或display:block样式，否则在IE6和IE7下会出现整行显示不了的问题。\r\n', 'CSS', '2011-01-03 21:31:30'),
(9, '', '有浮动没有清除的层在FF下用js获取到的offsetheight的值为0\r\n', 'JavaScript', '2011-01-03 20:31:30'),
(10, '', 'Web性能优化最佳实践中最重要的一条是减少HTTP请求，它也是YSlow中比重最大的一条规则。减少HTTP请求的方案主要有合并JavaScript和CSS文件、CSS Sprites、图像映射（Image Map）和使用Data URI来编码图片。CSS Sprites和图像映射现在已经随处可见了，但由于IE6和IE7不支持Data URI以及性能问题，这项技术尚未大量使用。目前大部分网页中的JavaScript和CSS文件数量和开发时一致，少量的网页会根据实际情况采取本地合并，这些合并中相当多的是有选择地手动完成，每次新的合并都需要重新在本地完成并上传到服务器，比较的随意和繁琐，同样文件的压缩也有类似的情况。而利用服务端的合并和压缩，我们就可以按照开发的逻辑尽可能让文件的颗粒度变小，利用网页中URL的规则来自动实现文件的合并和压缩，这会相当的灵活和高效。(<a href="http://dancewithnet.com/2010/06/08/minify-js-and-css-files-in-server/" target="_blank">随网之舞</a>)', '性能', '2011-01-03 20:21:30'),
(11, '', 'a链接标签不错，设置了href属性时就表现出了a标签的独特之处，没有设置href属性时它就是一个没有手型没有链接的内联元素非常好用\r\n', 'CSS', '2011-01-03 20:20:30'),
(16, '', 'IE下textarea文本区域默认是有滚动的，其他浏览器只有当内容输入过多的时候才出现滚动条。设置了overflow:hidden时，在所有浏览器中就算输入的内容再多滚动条都是被隐藏。设置overflow:auto时，在所有浏览器中都没滚动条，只有在内容输入过多时才出现滚动条，这很人性化(Opera除外)。\r\n', 'CSS', '2011-01-01 19:10:30'),
(15, '', '<p><span style="color: #ff0000"><strong>旋转</strong></span></p>\r\n<pre class="brush: css;" title="code">\r\n-o-transform:rotate(30deg); -moz-transform:rotate(30deg); -webkit-transform:rotate(30deg);</pre>', 'CSS3', '2011-01-02 19:10:30'),
(13, '', '<p><span style="color: rgb(255, 102, 0); "><strong>CSS3圆角</strong></span></p>\r\n<pre title="code" class="brush: css;">\r\nborder-radius:10px;-moz-border-radius:10px;-webkit-border-radius:10px;border:1px solid #eee</pre>', 'CSS3', '2011-01-03 19:10:30'),
(14, '', '<p><span style="color: #ff0000"><strong>阴影</strong></span></p>\r\n<pre class="brush: css;" title="code">\r\nbox-shadow:5px 5px 5px #333; -moz-box-shadow:5px 5px 5px #333;-webkit-box-shadow:5px 5px 5px #999;</pre>', 'CSS3', '2011-01-02 19:10:30'),
(393, '', '<p>Firefox3实现的原生getElementsByClassName方法返回的不是javascript数组（Array），而是html element collection，这个东西可以用标准的方式遍历，但是却与Array没有共同的prototype（这个指javascript里面的原型继承的prototype）。所以，很不幸，如果你用了Prototype库的那个返回Array的方法写程序，然后使用了Array增强方法里面的first()等方法或者Emmerable里面的each()等方法，那么程序一定会出错。此时你可以$A一下这个html element collection，但是这不是好方法。因为其实Prototype在1.6以后就不推荐使用getElementsByClassName方法了。</p>', 'JavaScript', '2011-01-06 21:37:23'),
(394, '', '<pre class="brush: css;" title="code">\r\n#test{ \r\n　　　　　　　　color:red; /* 所有浏览器都支持 */ \r\n　　　　　　　　color:red !important;/* Firefox、IE7支持 */ \r\n　　　　　　　　_color:red; /* IE6支持 */ \r\n　　　　　　　　*color:red; /* IE6、IE7支持 */ \r\n　　　　　　　　*+color:red; /* IE7支持 */ \r\n　　　　　　　　color:red\\9; /* IE6、IE7、IE8支持 */ \r\n　　　　　　　　color:red\\0; /* IE8支持 */ \r\n　　　　　　　　} \r\nbody:nth-of-type(1) p{color:red;} /* Chrome、Safari支持 */\r\n</pre>', 'CSS', '2011-01-06 21:37:57'),
(395, '', '<p>通常情况下给file input设置宽或是设置size都不能把浏览按钮的宽度增宽，其实只要设置font-size就可以达到给浏览按钮增加宽度。</p>', 'CSS', '2011-01-06 21:38:25'),
(396, '', '<p>把有图片的标签的HTML放在textarea标签内作为value，或者作为一段HTML的注释，这样可以使浏览器略过分析该HTML，图片也就不会加载</p>', 'CSS', '2011-01-06 21:38:43'),
(403, '', '<p><strong>开启Fckeditor上传图片功能<br />\r\n</strong></p>\r\n<p>打开editor/filemanager/connectors/php目录下config.php，找到<br />\r\n&nbsp;</p>\r\n<pre class="brush: php;" title="code">\r\n$Config[''Enabled''] = false ; </pre>\r\n<p>更改为</p>\r\n<p>&nbsp;</p>\r\n<pre class="brush: php;" title="code">\r\n$Config[''Enabled''] = true ; </pre>\r\n<p>并在相应目录下建立userfiles上传目录后，Fckeditor上传图片功能开启。</p>\r\n<p>&nbsp;</p>\r\n<p>打开editor/filemanager/connectors/php目录下config.php文件，找到<br />\r\n&nbsp;</p>\r\n<pre class="brush: php;" title="code">\r\n$Config[''UserFilesPath''] = ''/userfiles/'' ; \r\n</pre>\r\n<p>更改为</p>\r\n<pre class="brush: php;" title="code">\r\n$Config[''UserFilesPath''] = ''/项目目录/userfiles/'' ; </pre>\r\n<p><strong>注意：此处userfiles文件夹是针对http://localhost/的根目录而言的。</strong></p>\r\n<p>&nbsp;</p>\r\n<p><strong>Fckeditor上传图片文件名重名及中文乱码解决方法</strong></p>\r\n<p>&nbsp;打开editor/filemanager/connectors/php目录下commands.php，找到FileUpload函数，在<br />\r\n&nbsp;</p>\r\n<pre class="brush: php;" title="code">\r\n$sExtension = substr( $sFileName, ( strrpos($sFileName, ''.'') + 1 ) ) ;\r\n$sExtension = strtolower( $sExtension ) ; </pre>\r\n<p>后添加</p>\r\n<p>&nbsp;</p>\r\n<pre class="brush: php;" title="code">\r\n$sFileName = rand(0,100).&quot;.&quot;.$sExtension; </pre>\r\n<p>此处rand函数可根据需要自行改变重命名规则。</p>\r\n<p>　　另一种上传图片文件名乱码解决方法为使用iconv函数对文件名进行编码转换，但仍然存在重名问题，所以针对Fckeditor上传图片文件名最好还是重命名。</p>', 'FCKEditor', '2011-01-07 22:49:29'),
(408, '', '<pre class="brush: jscript;" title="code">\r\nFCKConfig.ImageUpload = true ;\r\nFCKConfig.ImageUploadURL = FCKConfig.BasePath + ''filemanager/connectors/'' + _QuickUploadLanguage + ''/connector.'' + _QuickUploadExtension + ''?Command=FileUpload&amp;Type=Image&amp;CurrentFolder=%2F'' ;\r\nFCKConfig.ImageUploadAllowedExtensions	= &quot;.(jpg|gif|jpeg|png|bmp)$&quot; ;		// empty for all\r\nFCKConfig.ImageUploadDeniedExtensions	= &quot;&quot; ;							// empty for no one</pre>\r\n<p>FCKConfig.ImageUploadURL的地址改成如上所示后，通过点击图片按钮上传的图片就会自动放在image文件夹中去了。</p>', 'FCKeditor', '2011-01-07 23:21:14'),
(429, '', '<table>\r\n<tr><td><a target="_blank" href="/notebook/submodels/2010-10-15/29/10631.html">联想ThinkPad E40（0578A54）</a></td><td>Intel 酷睿i5 450M</td><td>2.4GHz</td><td>3GB</td><td>500GBGB</td><td width="80">14英寸 LED背光 （1280×800）</td><td>NVIDIA Quadro NVS 3100M</td><td>2.27Kg</td><td class="fred">￥6800</td>		  <td><a class="addDB" onclick="parent.ContAdd(''联想ThinkPad E40（0578A54）'',10631,this,''http://i2.sinaimg.cn/IT/2010/1229/2010122901159.jpg'',''/notebook/submodels/2010-10-15/29/10631.html'',''myframe'')" href="javascript:void(0)">加入对比</a></td>\r\n</tr>\r\n<tr><td><a target="_blank" href="/notebook/submodels/2010-07-30/29/9834.html">联想ThinkPad E40（0578A18）</a></td><td>Intel 酷睿i5 430M</td><td>2.26GHz</td><td>2GB</td><td>320GBGB</td><td width="80">14英寸 LED背光 （1366×768）</td><td>ATI Mobility Radeon HD 545v</td><td>2.25Kg</td><td class="fred">￥6629</td>		  <td><a class="addDB" onclick="parent.ContAdd(''联想ThinkPad E40（0578A18）'',9834,this,''http://i0.sinaimg.cn/IT/2010/0928/201092823425.jpg'',''/notebook/submodels/2010-07-30/29/9834.html'',''myframe'')" href="javascript:void(0)">加入对比</a></td>\r\n</tr>\r\n<tr><td><a target="_blank" href="/notebook/submodels/2010-07-30/29/9848.html">联想ThinkPad E40（0578B32）</a></td><td>Intel 酷睿i3 350M</td><td>2.26GHz</td><td>2GB</td><td>320GBGB</td><td width="80">14英寸 LED背光 （1366×768）</td><td>ATI Mobility Radeon HD 545v</td><td>2.25Kg</td><td class="fred">￥6699</td>		  <td><a class="addDB" onclick="parent.ContAdd(''联想ThinkPad E40（0578B32）'',9848,this,''http://i0.sinaimg.cn/IT/2010/0928/201092823055.jpg'',''/notebook/submodels/2010-07-30/29/9848.html'',''myframe'')" href="javascript:void(0)">加入对比</a></td>\r\n</tr>\r\n</table>', 'CSS', '2011-01-08 20:33:57'),
(425, '', '<ol id="S_Cont_01" class="olist" style="">\r\n					<li><span class="r">￥<span class="fred">6600</span></span><span class="num"></span><a title="华硕 N43EI46JF-SL" target="_blank" href="/notebook/submodels/2010-09-13/29/10264.html">华硕 N43EI46JF-SL</a></li><li class="li2"><span class="r">￥<span class="fred">5899</span></span><span class="num no2"></span><a title="华硕 A40EI46JA-SL" target="_blank" href="/notebook/submodels/2010-10-01/29/10508.html">华硕 A40EI46JA-SL</a></li><li><span class="r">￥<span class="fred">4550</span></span><span class="num no3"></span><a title="联想 G460A-ITH（H）" target="_blank" href="/notebook/submodels/2010-07-16/29/9687.html">联想 G460A-ITH（H）</a></li><li class="li2"><span class="r">￥<span class="fred">5300</span></span><span class="num no4"></span><a title="华硕 K42EI43Jv-SL" target="_blank" href="/notebook/submodels/2010-06-14/29/9289.html">华硕 K42EI43Jv-SL</a></li><li><span class="r">￥<span class="fred">3799</span></span><span class="num no5"></span><a title="惠普 CQ42-256TX" target="_blank" href="/notebook/submodels/2010-08-13/29/10013.html">惠普 CQ42-256TX</a></li><li class="li2"><span class="r">￥<span class="fred">5700</span></span><span class="num no6"></span><a title="联想 Y460A-ITH（灰）E" target="_blank" href="/notebook/submodels/2010-02-22/29/8144.html">联想 Y460A-ITH（灰）E</a></li><li><span class="r">￥<span class="fred">6800</span></span><span class="num no7"></span><a title="苹果 MacBook（MC516ZP/A）" target="_blank" href="/notebook/submodels/2010-08-09/29/9999.html">苹果 MacBook（MC516ZP/A）</a></li><li class="li2"><span class="r">￥<span class="fred">6499</span></span><span class="num no8"></span><a title="索尼 EA18EC/B（黑）" target="_blank" href="/notebook/submodels/2010-04-23/29/8583.html">索尼 EA18EC/B（黑）</a></li><li><span class="r">￥<span class="fred">4850</span></span><span class="num no9"></span><a title="联想 Z460A-ITH（酷黑）" target="_blank" href="/notebook/submodels/2010-04-23/29/8597.html">联想 Z460A-ITH（酷黑）</a></li><li class="li2"><span class="r">￥<span class="fred">31300</span></span><span class="num no10"></span><a title="联想ThinkPad W510（4319A19）" target="_blank" href="/notebook/submodels/2010-07-16/29/9702.html">联想ThinkPad W510（4319A19</a></li>\r\n				</ol>', 'CSS', '2011-01-08 10:57:00'),
(428, '', '<p><a href="http://tech.sina.com.cn/notebook/models/2010-04-06/23/3486.html">ThinkPad E40</a></p>\r\n<p><a href="http://tech.sina.com.cn/notebook/submodels/2010-07-30/29/9848.html">联想ThinkPad E40（0578B32）</a></p>', 'CSS', '2011-01-08 19:52:22'),
(431, '', '<style type="text/css">\r\n.tbl-list th, .tbl-list td {\r\n    border: 1px solid #DEF0FD;\r\n    padding: 2px;\r\n}\r\n</style>\r\n<table cellspacing="0" class="tbl-list" id="table-1">\r\n    <thead>\r\n        <tr class="trbg">\r\n            <td _sorttype="">型号</td>\r\n            <td width="80" _sorttype="">CPU</td>\r\n            <td width="50" _sorttype="">频率</td>\r\n            <td width="50" class="sort">内存<img class="sort-arrow" src="http://i1.sinaimg.cn/IT/deco/2009/0605/09notebook/images/blank.png" alt="" /></td>\r\n            <td width="60" class="sort">硬盘<img class="sort-arrow" src="http://i1.sinaimg.cn/IT/deco/2009/0605/09notebook/images/blank.png" alt="" /></td>\r\n            <td width="80" _sorttype="">屏幕</td>\r\n            <td width="50" _sorttype="">显卡</td>\r\n            <td width="50" class="sort">重量<img class="sort-arrow" src="http://i1.sinaimg.cn/IT/deco/2009/0605/09notebook/images/blank.png" alt="" /></td>\r\n            <td width="50" class="sort">价格<img class="sort-arrow ascending" src="http://i1.sinaimg.cn/IT/deco/2009/0605/09notebook/images/blank.png" alt="" /></td>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr class=" trbg">\r\n            <td><a href="/notebook/submodels/2010-11-03/29/10713.html" target="_blank">联想ThinkPad E40（0578A67）</a></td>\r\n            <td>Intel 酷睿i3 370M</td>\r\n            <td>2.4GHz</td>\r\n            <td>2GB</td>\r\n            <td>320GBGB</td>\r\n            <td width="80">14.1英寸 LED背光 （1366&times;768）</td>\r\n            <td>ATI Mobility Radeon HD 545v</td>\r\n            <td>2.25Kg</td>\r\n            <td class="fred"><span style="display: none;">￥0</span>暂无价格</td>\r\n\r\n        </tr>\r\n        <tr class="undefined">\r\n            <td><a href="/notebook/submodels/2010-11-03/29/10714.html" target="_blank">联想ThinkPad E40（0578A62）</a></td>\r\n            <td>Intel 酷睿i3 370M</td>\r\n            <td>2.4GHz</td>\r\n            <td>2GB</td>\r\n            <td>320GBGB</td>\r\n            <td width="80">14.1英寸 LED背光 （1366&times;768）</td>\r\n            <td>ATI Mobility Radeon HD 545v</td>\r\n            <td>2.25Kg</td>\r\n            <td class="fred"><span style="display: none;">￥0</span>暂无价格</td>\r\n        </tr>\r\n        <tr class=" trbg">\r\n            <td><a href="/notebook/submodels/2010-10-29/29/10755.html" target="_blank">联想ThinkPad E40（0578A69）</a></td>\r\n            <td>Intel 酷睿i3 370M</td>\r\n            <td>2.4GHz</td>\r\n            <td>2GB</td>\r\n            <td>500GBGB</td>\r\n            <td width="80">14.1英寸 LED背光 （1366&times;768）</td>\r\n            <td>ATI Mobility Radeon HD 545v</td>\r\n            <td>2.25Kg</td>\r\n            <td class="fred"><span style="display: none;">￥0</span>暂无价格</td>\r\n        </tr>\r\n        <tr class="undefined">\r\n            <td><a href="/notebook/submodels/2010-10-29/29/10758.html" target="_blank">联想ThinkPad E40（0578A68）</a></td>\r\n            <td>Intel 酷睿i3 370M</td>\r\n            <td>2.4GHz</td>\r\n            <td>4GB</td>\r\n            <td>320GBGB</td>\r\n            <td width="80">14.1英寸 LED背光 （1366&times;768）</td>\r\n            <td>ATI Mobility Radeon HD 545v</td>\r\n            <td>2.25Kg</td>\r\n            <td class="fred"><span style="display: none;">￥0</span>暂无价格</td>\r\n        </tr>\r\n        <tr>\r\n            <td><a href="/notebook/submodels/2010-10-15/29/10627.html" target="_blank">联想ThinkPad E40（0578A73）</a></td>\r\n            <td>Intel 酷睿i3 370M</td>\r\n            <td>2.4GHz</td>\r\n            <td>2GB</td>\r\n            <td>250GBGB</td>\r\n            <td width="80">14.1英寸 LED背光 （1280&times;800）</td>\r\n            <td>NVIDIA Quadro NVS 3100M</td>\r\n            <td>2.27Kg</td>\r\n            <td class="fred"><span style="display: none;">￥0</span>暂无价格</td>\r\n\r\n        </tr>\r\n        <tr class=" trbg">\r\n            <td><a href="/notebook/submodels/2010-07-30/29/9852.html" target="_blank">联想ThinkPad E40（0578ER4）</a></td>\r\n            <td>Intel 酷睿i3 350M</td>\r\n            <td>2.26GHz</td>\r\n            <td>2GB</td>\r\n            <td>320GBGB</td>\r\n            <td width="80">14英寸 LED背光 （1366&times;768）</td>\r\n            <td>ATI Mobility Radeon HD 545v</td>\r\n            <td>2.25Kg</td>\r\n            <td class="fred"><span style="display: none;">￥0</span>暂无价格</td>\r\n        </tr>\r\n        <tr>\r\n            <td><a href="/notebook/submodels/2010-10-13/29/10659.html" target="_blank">联想ThinkPad E40（0578A64）</a></td>\r\n            <td>Intel 酷睿i3 370M</td>\r\n            <td>2.4GHz</td>\r\n            <td>2GB</td>\r\n            <td>320GBGB</td>\r\n            <td width="80">14英寸 LED背光 （1366&times;768）</td>\r\n            <td>ATI Mobility Radeon HD 545v</td>\r\n            <td>2.25Kg</td>\r\n            <td class="fred">￥4250</td>\r\n        </tr>\r\n        <tr>\r\n            <td><a href="/notebook/submodels/2010-10-18/29/10620.html" target="_blank">联想ThinkPad E40（0578A63）</a></td>\r\n            <td>Intel 酷睿i3 370M</td>\r\n            <td>2.4GHz</td>\r\n            <td>2GB</td>\r\n            <td>320GBGB</td>\r\n            <td width="80">14英寸 LED背光 （1366&times;768）</td>\r\n            <td>ATI Mobility Radeon HD 545v</td>\r\n            <td>2.25Kg</td>\r\n            <td class="fred">￥4450</td>\r\n        </tr>\r\n        <tr class=" trbg">\r\n            <td><a href="/notebook/submodels/2010-07-30/29/9843.html" target="_blank">联想ThinkPad E40（0578G9C）</a></td>\r\n            <td>Intel 酷睿i3 350M</td>\r\n            <td>2.26GHz</td>\r\n            <td>2GB</td>\r\n            <td>320GBGB</td>\r\n            <td width="80">14英寸 LED背光 （1366&times;768）</td>\r\n            <td>ATI Mobility Radeon HD 545v</td>\r\n            <td>2.25Kg</td>\r\n            <td class="fred">￥4450</td>\r\n        </tr>\r\n        <tr class="undefined trbg">\r\n            <td><a href="/notebook/submodels/2010-10-18/29/10621.html" target="_blank">联想ThinkPad E40（0578A59）</a></td>\r\n            <td>Intel 酷睿i3 370M</td>\r\n            <td>2.4GHz</td>\r\n            <td>2GB</td>\r\n            <td>500GBGB</td>\r\n            <td width="80">14英寸 LED背光 （1366&times;768）</td>\r\n            <td>ATI Mobility Radeon HD 545v</td>\r\n            <td>2.25Kg</td>\r\n            <td class="fred">￥4699</td>\r\n        </tr>\r\n        <tr class="undefined">\r\n            <td><a href="/notebook/submodels/2010-07-30/29/9837.html" target="_blank">联想ThinkPad E40（0578G8C）</a></td>\r\n            <td>Intel 酷睿i3 350M</td>\r\n            <td>2.26GHz</td>\r\n            <td>2GB</td>\r\n            <td>320GBGB</td>\r\n            <td width="80">14英寸 LED背光 （1366&times;768）</td>\r\n            <td>ATI Mobility Radeon HD 545v</td>\r\n            <td>2.25Kg</td>\r\n            <td class="fred">￥4750</td>\r\n        </tr>\r\n        <tr class=" trbg">\r\n            <td><a href="/notebook/submodels/2010-04-05/29/8370.html" target="_blank">联想ThinkPad E40（05785KC）</a></td>\r\n            <td>Intel 酷睿i3 330M</td>\r\n            <td>2.13GHz</td>\r\n            <td>2GB</td>\r\n            <td>320GB</td>\r\n            <td width="80">14英寸 LED背光 （1366&times;768）</td>\r\n            <td>ATI Mobility Radeon HD 5145</td>\r\n            <td>2.25Kg</td>\r\n            <td class="fred">￥4800</td>\r\n        </tr>\r\n        <tr>\r\n            <td><a href="/notebook/submodels/2010-07-30/29/9851.html" target="_blank">联想ThinkPad E40（0578ER5）</a></td>\r\n            <td>Intel 酷睿i3 350M</td>\r\n            <td>2.26GHz</td>\r\n            <td>2GB</td>\r\n            <td>320GBGB</td>\r\n            <td width="80">14英寸 LED背光 （1366&times;768）</td>\r\n            <td>ATI Mobility Radeon HD 545v</td>\r\n            <td>2.25Kg</td>\r\n            <td class="fred">￥4899</td>\r\n        </tr>\r\n        <tr>\r\n            <td><a href="/notebook/submodels/2010-04-19/29/8532.html" target="_blank">联想ThinkPad E40（0578DB1）</a></td>\r\n            <td>Intel 酷睿i3 330M</td>\r\n            <td>2.13GHz</td>\r\n            <td>2GB</td>\r\n            <td>320GBGB</td>\r\n            <td width="80">14英寸 LED背光 （1366&times;768）</td>\r\n            <td>ATI Mobility Radeon HD 5145</td>\r\n            <td>2.25Kg</td>\r\n            <td class="fred">￥5100</td>\r\n        </tr>\r\n        <tr>\r\n            <td><a href="/notebook/submodels/2010-07-30/29/9841.html" target="_blank">联想ThinkPad E40（0578A38）</a></td>\r\n            <td>Intel 酷睿i3 350M</td>\r\n            <td>2.26GHz</td>\r\n            <td>2GB</td>\r\n            <td>320GBGB</td>\r\n            <td width="80">14英寸 LED背光 （1366&times;768）</td>\r\n            <td>ATI Mobility Radeon HD 545v</td>\r\n            <td>2.25Kg</td>\r\n            <td class="fred">￥5400</td>\r\n        </tr>\r\n        <tr class="undefined trbg">\r\n            <td><a href="/notebook/submodels/2010-04-19/29/8533.html" target="_blank">联想ThinkPad E40（0578DR1）</a></td>\r\n            <td>Intel 酷睿i3 330M</td>\r\n            <td>2.13GHz</td>\r\n            <td>2GB</td>\r\n            <td>320GBGB</td>\r\n            <td width="80">14英寸 LED背光 （1366&times;768）</td>\r\n            <td style="visibility: hidden;">0</td>\r\n            <td>2.25Kg</td>\r\n            <td class="fred">￥5450</td>\r\n        </tr>\r\n        <tr>\r\n            <td><a href="/notebook/submodels/2010-07-30/29/9835.html" target="_blank">联想ThinkPad E40（057893C）</a></td>\r\n            <td>Intel 酷睿i3 330M</td>\r\n            <td>2.13GHz</td>\r\n            <td>2GB</td>\r\n            <td>250GBGB</td>\r\n            <td width="80">14英寸 LED背光 （1366&times;768）</td>\r\n            <td>ATI Mobility Radeon HD 545v</td>\r\n            <td>2.25Kg</td>\r\n            <td class="fred">￥5749</td>\r\n        </tr>\r\n        <tr class="undefined trbg">\r\n            <td><a href="/notebook/submodels/2010-04-19/29/8531.html" target="_blank">联想ThinkPad E40（0578NB2）</a></td>\r\n            <td>Intel 酷睿i3 330M</td>\r\n            <td>2.13GHz</td>\r\n            <td>3GB</td>\r\n            <td>500GBGB</td>\r\n            <td width="80">14英寸 LED背光 （1366&times;768）</td>\r\n            <td style="visibility: hidden;">0</td>\r\n            <td>2.25Kg</td>\r\n            <td class="fred">￥5800</td>\r\n        </tr>\r\n        <tr class="undefined">\r\n            <td><a href="/notebook/submodels/2010-04-16/29/8454.html" target="_blank">联想ThinkPad E40（0578DR2）</a></td>\r\n            <td>Intel 酷睿i3 330M</td>\r\n            <td>2.13GHz</td>\r\n            <td>3GB</td>\r\n            <td>500GBGB</td>\r\n            <td width="80">14英寸 LED背光 （1366&times;768）</td>\r\n            <td>ATI Mobility Radeon HD 4570</td>\r\n            <td>2.25Kg</td>\r\n            <td class="fred">￥5840</td>\r\n        </tr>\r\n        <tr class="undefined trbg">\r\n            <td><a href="/notebook/submodels/2010-05-28/29/8961.html" target="_blank">联想ThinkPad E40（0578A12）</a></td>\r\n            <td>Intel 酷睿i5 430M</td>\r\n            <td>2.26GHz</td>\r\n            <td>2GB</td>\r\n            <td>320GBGB</td>\r\n            <td width="80">14英寸 LED背光 （1366&times;768）</td>\r\n            <td>ATI Mobility Radeon HD 5145</td>\r\n            <td>2.25Kg</td>\r\n            <td class="fred">￥5999</td>\r\n        </tr>\r\n        <tr class="undefined">\r\n            <td><a href="/notebook/submodels/2010-10-18/29/10619.html" target="_blank">联想ThinkPad E40（0578GVC）</a></td>\r\n            <td>Intel 酷睿i5 450M</td>\r\n            <td>2.4GHz</td>\r\n            <td>4GB</td>\r\n            <td>320GBGB</td>\r\n            <td width="80">14英寸 LED背光 （1366&times;768）</td>\r\n            <td>ATI Mobility Radeon HD 545v</td>\r\n            <td>2.25Kg</td>\r\n            <td class="fred">￥6200</td>\r\n        </tr>\r\n        <tr class=" trbg">\r\n            <td>&nbsp;</td>\r\n            <td>Intel 酷睿 i5 430M</td>\r\n            <td>2.26GHz</td>\r\n            <td>2GB</td>\r\n            <td>320GB</td>\r\n            <td width="80">14英寸 LED背光 （1366&times;768）</td>\r\n            <td>ATI Mobility Radeon HD 4570</td>\r\n            <td>0g</td>\r\n            <td class="fred">￥6200</td>\r\n        </tr>\r\n        <tr>\r\n            <td><a href="/notebook/submodels/2010-07-30/29/9839.html" target="_blank">联想ThinkPad E40（0578B31）</a></td>\r\n            <td>Intel 酷睿i3 330M</td>\r\n            <td>2.13GHz</td>\r\n            <td>2GB</td>\r\n            <td>320GBGB</td>\r\n            <td width="80">14英寸 LED背光 （1366&times;768）</td>\r\n            <td>ATI Mobility Radeon HD 545v</td>\r\n            <td>2.25Kg</td>\r\n            <td class="fred">￥6399</td>\r\n        </tr>\r\n        <tr class="undefined trbg">\r\n            <td><a href="/notebook/submodels/2010-10-01/29/10512.html" target="_blank">联想ThinkPad E40（0578A53）</a></td>\r\n            <td>Intel 酷睿i5 450M</td>\r\n            <td>2.4GHz</td>\r\n            <td>2GB</td>\r\n            <td>500GBGB</td>\r\n            <td width="80">14英寸 LED背光 （1366&times;768）</td>\r\n            <td style="visibility: hidden;">0</td>\r\n            <td>2.25Kg</td>\r\n            <td class="fred">￥6500</td>\r\n        </tr>\r\n        <tr class="undefined">\r\n            <td><a href="/notebook/submodels/2010-07-30/29/9834.html" target="_blank">联想ThinkPad E40（0578A18）</a></td>\r\n            <td>Intel 酷睿i5 430M</td>\r\n            <td>2.26GHz</td>\r\n            <td>2GB</td>\r\n            <td>320GBGB</td>\r\n            <td width="80">14英寸 LED背光 （1366&times;768）</td>\r\n            <td>ATI Mobility Radeon HD 545v</td>\r\n            <td>2.25Kg</td>\r\n            <td class="fred">￥6629</td>\r\n        </tr>\r\n        <tr class="undefined trbg">\r\n            <td><a href="/notebook/submodels/2010-07-30/29/9850.html" target="_blank">联想ThinkPad E40（0578A37）</a></td>\r\n            <td>Intel 酷睿i3 350M</td>\r\n            <td>2.26GHz</td>\r\n            <td>4GB</td>\r\n            <td>320GBGB</td>\r\n            <td width="80">14英寸 LED背光 （1366&times;768）</td>\r\n            <td>ATI Mobility Radeon HD 545v</td>\r\n            <td>2.25Kg</td>\r\n            <td class="fred">￥6659</td>\r\n        </tr>\r\n        <tr class="undefined">\r\n            <td><a href="/notebook/submodels/2010-07-30/29/9848.html" target="_blank">联想ThinkPad E40（0578B32）</a></td>\r\n            <td>Intel 酷睿i3 350M</td>\r\n            <td>2.26GHz</td>\r\n            <td>2GB</td>\r\n            <td>320GBGB</td>\r\n            <td width="80">14英寸 LED背光 （1366&times;768）</td>\r\n            <td>ATI Mobility Radeon HD 545v</td>\r\n            <td>2.25Kg</td>\r\n            <td class="fred">￥6699</td>\r\n        </tr>\r\n        <tr class="undefined trbg">\r\n            <td><a href="/notebook/submodels/2010-10-15/29/10631.html" target="_blank">联想ThinkPad E40（0578A54）</a></td>\r\n            <td>Intel 酷睿i5 450M</td>\r\n            <td>2.4GHz</td>\r\n            <td>3GB</td>\r\n            <td>500GBGB</td>\r\n            <td width="80">14英寸 LED背光 （1280&times;800）</td>\r\n            <td>NVIDIA Quadro NVS 3100M</td>\r\n            <td>2.27Kg</td>\r\n            <td class="fred">￥6800</td>\r\n        </tr>\r\n        <tr class="undefined">\r\n            <td><a href="/notebook/submodels/2010-07-30/29/9838.html" target="_blank">联想ThinkPad E40（0578B51）</a></td>\r\n            <td>Intel 酷睿i5 430M</td>\r\n            <td>2.26GHz</td>\r\n            <td>2GB</td>\r\n            <td>320GBGB</td>\r\n            <td width="80">14英寸 LED背光 （1366&times;768）</td>\r\n            <td>ATI Mobility Radeon HD 545v</td>\r\n            <td>2.25Kg</td>\r\n            <td class="fred">￥7699</td>\r\n        </tr>\r\n        <tr class=" trbg">\r\n            <td><a href="/notebook/submodels/2010-10-15/29/10632.html" target="_blank">联想ThinkPad E40（0578A47）</a></td>\r\n            <td>Intel 酷睿i5 520M</td>\r\n            <td>2.4GHz</td>\r\n            <td>3GB</td>\r\n            <td>500GBGB</td>\r\n            <td width="80">14英寸 LED背光 （1280&times;800）</td>\r\n            <td>NVIDIA Quadro NVS 3100M</td>\r\n            <td>2.27Kg</td>\r\n            <td class="fred">￥7700</td>\r\n        </tr>\r\n    </tbody>\r\n</table>', 'CSS', '2011-01-08 22:00:45'),
(433, '', '<h1>形式参数和实际参数</h1>\r\n<p>函数的参数分为形参和实参两种。在本小节中，进一步介绍形参、实参的特点和两者的关系。形参出现在函数定义中，在整个函数体内都可以使用，离开该函数则不能使用。实参出现在主调函数中，进入被调函数后，实参变量也不能使用。形参和实参的功能是作数据传送。发生函数调用时，主调函数把实参的值传送给被调函数的形参从而实现主调函数向被调函数的数据传送。 函数的形参和实参具有以下特点：&nbsp;<br />\r\n1. 形参变量只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元。因此，形参只有在函数内部有效。函数调用结束返回主调函数后则不能再使用该形参变量。&nbsp;<br />\r\n2. 实参可以是常量、变量、表达式、函数等，无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值，以便把这些值传送给形参。因此应预先用赋值，输入等办法使实参获得确定值。&nbsp;<br />\r\n3. 实参和形参在数量上，类型上，顺序上应严格一致，否则会发生类型不匹配&rdquo;的错误。&nbsp;<br />\r\n4. 函数调用中发生的数据传送是单向的。即只能把实参的值传送给形参，而不能把形参的值反向地传送给实参。 因此在函数调用过程中，形参的值发生改变，而实参中的值不会变化。</p>\r\n<div id="postmessage_183841">就例如一下一段函数</div>\r\n<pre title="code" class="brush: jscript;">\r\nvar a;\r\na = 0;\r\nfunction func(b)\r\n{\r\nb = 1;\r\ndocument.write(b);\r\n}\r\ndocument.write(a+&quot;&lt;br&gt;&quot;)\r\nfunc(a);\r\ndocument.write(&quot;&lt;br&gt;&quot;+a)</pre>\r\n<div>我希望的是，变量a经过func(a)之后，变成1，<br />\r\n但是出了这个func()这个函数体之后，a的值还是0。<br />\r\n这下大家应该明白了吧。<br />\r\n有什么办法使得a出了这个func()这个函数体之后，a的值变成1呢？<br />\r\n这个就是形参和实参的区别啦。</div>', 'CSS', '2011-01-08 22:37:56'),
(434, '', '<p>&nbsp;我是一个最硬心软的人，不关心的人我是不骂他的</p>', 'CSS', '2011-01-08 23:39:30'),
(439, '', '<p>利用Javascript取和设FCKeditor值也是非常容易的，如下：</p>\r\n<pre title="code" class="brush: jscript;">\r\n// 获取编辑器中HTML内容 \r\nfunction getEditorHTMLContents(EditorName) { \r\nvar oEditor = FCKeditorAPI.GetInstance(EditorName); \r\nreturn(oEditor.GetXHTML(true)); \r\n} \r\n\r\n// 获取编辑器中文字内容 \r\nfunction getEditorTextContents(EditorName) { \r\nvar oEditor = FCKeditorAPI.GetInstance(EditorName); \r\nreturn(oEditor.EditorDocument.body.innerText); \r\n} \r\n\r\n// 设置编辑器中内容 \r\nfunction SetEditorContents(EditorName, ContentStr) { \r\nvar oEditor = FCKeditorAPI.GetInstance(EditorName) ; \r\noEditor.SetHTML(ContentStr) ; \r\n}</pre>\r\n<p>&nbsp;</p>', 'FCKeditor', '2011-01-09 10:23:00'),
(473, '', '<p>Lazyload的一个作用就是延迟html渲染。原理是先保存元素里面的html，当判断元素在加载范围里面时，再加载里面的html。程序主要是做判断的部分，而如何保存和加载就看各位的想象力了。以下几种方法个人认为还不错的： <br />\r\n1，ajax法：保存地址，加载时利用ajax读取实际内容并插入到元素中；使用恰当的话能有效节省服务器资源，特别是要读数据库的地方，但响应速度受网络影响，而且不利seo，类似的还可以用iframe。 <br />\r\n2，textarea法：把html保存到一个textarea中，加载时把value插入元素中；利用了textarea的特性，第二个实例就使用了这个方法，淘宝用的也是这个方式，使用简单，响应速度快。不过仅仅是html的话，貌似也没必要延迟，可以考虑关联一些dom操作之类的。 <br />\r\n2，注释法：把html保存到一个注释中，加载时把内容插入元素中；跟textarea法类似，但效率应该更好，加载时找出nodeType为8的节点，再把nodeValue插入元素中；但在ie如果用innerHTML添加注释会被自动忽略掉，使用时注意。</p>', '性能', '2011-01-09 20:47:22'),
(474, '', '<pre class="brush: jscript;" title="code">\r\n	//去掉字符串的空格\r\n	String.prototype.trim = function(){\r\n		return this.replace(/(^[\\s]*)|([\\s]*$)/g, &quot;&quot;);\r\n	}\r\n</pre>', 'JavaScript', '2011-01-09 20:51:50'),
(476, '', '<p>目前的Firefox、chrome、safari中的textarea控件，可以有拉伸的功能，有时这非常酷，但再好的东西并不是所有人都喜欢，你可以用CSS把这个功能屏蔽掉。 <br />\r\n解决方法:</p>\r\n<pre class="brush: css;" title="code">\r\nresize: none;</pre>\r\n<p>或者:</p>\r\n<pre class="brush: css;" title="code">\r\n    max-width:300px; \r\n    max-height:300px; \r\n    width:300px; \r\n    height:300px;  </pre>', 'CSS', '2011-01-10 19:34:10'),
(484, '', '<p><a href="http://product.pchome.net/compare_param_289672,300808.html">http://product.pchome.net/compare_param_289672,300808.html</a></p>\r\n<p><a href="http://php.tech.sina.com.cn/notebook/compare.php?d_id=10755,9848">http://php.tech.sina.com.cn/notebook/compare.php?d_id=10755,9848</a></p>', '随笔', '2011-01-14 22:50:40'),
(485, '', '<p><span style="color: rgb(255, 0, 0);"><strong>Clarksfield比Arrandale好</strong></span></p>\r\n<p>Arrandale是目前酷睿i3/i5处理器的内核代号，Clarksfield是酷睿i7的内核代号，不是架构。Arrandale内核的处理器均采用32nm工艺制作，为双核四线程，有3或4MB的三级缓存，内部集成GPU。Clarksfield采用45nm工艺制作，为四核八线程，有6或8MB的三级缓存，所以从性能上后者明显强于前者</p>', '随笔', '2011-01-15 10:45:34'),
(486, '', '<p>【联想ThinkPad E40（0578A69）|联想ThinkPad E40（0578B32）】</p>\r\n<p style="text-align: center;"><img width="454" height="1588" alt="" src="/attachment/image/E40-0578-A69-B32.jpg" /></p>', '随笔', '2011-01-15 11:33:28'),
(487, '', '<p><a href="http://product.pchome.net/compare_param_300808,289672,74406.html">http://product.pchome.net/compare_param_300808,289672,74406.html</a></p>', '随笔', '2011-01-15 11:57:05'),
(489, '', '<p><a href="http://www.gracecode.com/archives/3044/">http://www.gracecode.com/archives/3044/</a></p>\r\n<p><a href="http://code.taobao.org/svn/nginx_concat_module/trunk">http://code.taobao.org/svn/nginx_concat_module/trunk</a></p>', '性能', '2011-01-17 21:21:15'),
(495, '', '<h1><a rel="permalink" href="http://www.infoq.com/cn/articles/sandboxOnB;jsessionid=1C01966EFA805A841473BD46ECC07ED5">漫谈B端的沙箱技术</a></h1>\r\n<p><a href="http://www.infoq.com/cn/articles/sandboxOnB">http://www.infoq.com/cn/articles/sandboxOnB</a></p>\r\n<p>&nbsp;</p>\r\n<p>从语言学的角度上来说，允许代码无节制地使用全局变量，是最错误的选择之一。而更可怕的，就是一个变量&quot;可能&quot;成为全局的（在未知的时间与地点）。但是这两项，却伴随JavaScript这门语言成功地走到了现在。</p>\r\n<p>也许是限于浏览器应用的规模，所以这一切还迟迟没有酿成灾难。在此之前，出现了两种解决方案。一种是ECMA在新的规范（Edition 5）中对此做出了限制，其中最重要的一条便是eval()的使用变得不再随意和无度。而另一种方案，则是相对没有那么官僚与学术的，尽管也拥有一个同样学术的名字：沙箱。</p>\r\n<p>沙箱（Sandbox）并不是一个新东西，即使对于JavaScript来说，也已经存在了相当长的时间。在SpiderMonkey JS的源代码中，就明确地将一个闭包描述为一个沙箱。这包含着许多潜在的信息：它有一个初始环境，可以被重置，可以被复制，以及最重要的，在它内部的所有操作，不会影响到外部</p>\r\n<p>当然事实上远非如此。JavaScript里的闭包只是一个&quot;貌似沙箱&quot;的东西--仍然是出于JavaScript早期的语言规范的问题，闭包不得不允许那些&quot;合法泄漏&quot;给外部的东西。而对于这一切无法忍受的前端工程师们，开始寻求另外的解决之道，这其中相对较早的尝试，是基于IFRAME的实践。例如dean.edwards在2006年提出过的方案（注1）：</p>\r\n<pre title="code" class="brush: jscript;">\r\na_frames.document.write(\r\n  &quot;&lt;script&gt;&quot;+\r\n  &quot;var MSIE/*@cc_on =1@*/;&quot;+ // sniff\r\n  &quot;parent.sandbox=MSIE?this:{eval:function(s){return eval(s)}}&quot;+\r\n  &quot;&lt;\\/script&gt;&quot;\r\n);\r\n</pre>\r\n<p>显然，由于在不同的IFRAME中运行着各自的JavaScript引擎实例，所以上述的方案也意味着沙箱是&quot;引擎&quot;这个级别的：在任何一个沙箱中的崩溃，将导致该引擎以及对应IFRAME崩溃。但--理论上说--不会影响整个浏览器。</p>\r\n<p>问题是，这并不那么理想。往往的，引擎会导致整个浏览器锁在那里，例如用alert()弹出一个对话框而又因为某种意外失去了焦点。又或者单个的IFRAME会导致全局的CPU被耗光，例如一个死循环。于是更加复杂的方案--在JavaScritp中包含一个完整的执行器--出现了。最有名的则是Narrative JavaScript，它内建了一个执行器，用于逐行地解释执行JavaScript代码，这使得它可以控制所有的代码执行序列，或者随时重置整个执行引擎--如同一个沙箱所要做的那样。</p>\r\n<p>这一切或者太过依赖于环境，又或者太过复杂，但都不乏追随者。例如jsFiddle这个项目（注2）在&quot;嵌入或装载&quot;这样的路子上就已经有了不俗的成绩。但是，YUI在新版本中却给出了它自己的选择：以更加明确的编程约定，来实现应用级别的沙箱。这包括一个非常简单的、新的YUI语法：</p>\r\n<pre title="code" class="brush: jscript;">\r\nYUI().use(''dom-base'', function(Y) {\r\n  // Y是一个新的沙箱\r\n});\r\n</pre>\r\n<p>在''dom-base''位置上，可以是1到N个字符串，表明一个需要在沙箱中装载的模块列表。这可以是沙箱的初始列表，或者后续的callback函数(亦即是用户代码)所需依赖的模块列表。在这种实现方案中，YUI为每个沙箱维护各自的装载模块列表和上下文环境中的变量、成员。但是出于JavaScript语言自己的局限，这个沙箱依然是相当脆弱的。例如下一示例中沙箱内的代码就会污染到全局：</p>\r\n<pre title="code" class="brush: jscript;">\r\nYUI().use('''', function(Y) {\r\n  abc = 1234;  //&lt;--这里可能导致一个全局变量''abc''被隐式地声明\r\n});\r\n</pre>\r\n<p>同样，在上述的沙箱里也可以使用类似window、document等全局变量、修改它们的成员或无限制地调用方法（例如使用setTimeout()来创建时钟）。所以YUI的沙箱事实上是靠&quot;规约&quot;来约束的，而不是真正意义上的沙箱。当然，这也意味着，如果用户能按照规约来处理沙箱内的代码，那么也就能自由地享用它带来的便利：安全、移植和有效的隔离副作用。</p>\r\n<p>而我们再穷究其根底，YUI沙箱的实质不过是一行:</p>\r\n<pre title="code" class="brush: jscript;">\r\n\r\n// code from yui.js\r\n//  - mod.fn(this, name)\r\nmod.entryFunc(sandbox, modName);\r\n</pre>\r\n<p>其实际含义是：</p>\r\n<ul>\r\n    <li>mod ：沙箱当前装载的模块；</li>\r\n    <li>entryFunc : 上述模块的入口函数；</li>\r\n    <li>sandbox ：当前的沙箱的实例，即YUI()返回值；</li>\r\n    <li>modName：模块名</li>\r\n</ul>\r\n<p>除了依赖关系（以及可能需要的异步加载）之外，YUI沙箱环境仅是用下面的代码来简单地调用callback函数：</p>\r\n<pre title="code" class="brush: jscript;">\r\ncallback(Y, response);\r\n</pre>\r\n<p>然而这些需求的实现并不那么复杂。首先，我们设定数据结构mod为一个对象：</p>\r\n<pre title="code" class="brush: jscript;">\r\n{ name:modName, fn: entryFunc, req: [], use: [] }</pre>\r\n<p>则一个环境对象env，将包括多个mod(将它们处理成对象而非数组，主要是便于使用名字来索引模块)和以及对它们进行管理操作的方法：</p>\r\n<pre title="code" class="brush: jscript;">\r\n\r\n{ mods:{}, used:{}, add:..., use:...}\r\n</pre>\r\n<p>最后，所谓一个沙箱sandbox，就是上述环境对象的一个实例，并在初始时sandbox.mods与sandbox.used为空。由此简单的实现为：</p>\r\n<pre title="code" class="brush: jscript;">\r\n/**\r\n * tiny sandbox framework\r\n * mirror from YUI3 by aimingoo.\r\n**/\r\nfunction Sandbox() {\r\n  if (!(this instanceof arguments.callee)) return new arguments.callee();\r\n  this.mods = this.mods || {};\r\n  this.used = {};\r\n}\r\n\r\nSandbox.prototype = {\r\n  add: function(modName, entryFunc, reqArr, useArr) {\r\n    this.mods[modName] = { fn: entryFunc, req: reqArr, use: useArr }\r\n  },\r\n\r\n  use: function() { \r\n    var mods = [].slice.call(arguments, 0); 	// 0..length-2 is modNames\r\n    var callback = mods.pop();  	// length-1 is callback\r\n    var recursive_load = function(name, mod) {\r\n      if (!this.used[name] &amp;&amp; (mod=this.mods[name])) {\r\n        mod.req.forEach(recursive_load, this);\r\n        mod.fn(this, name);\r\n        mod.use.forEach(recursive_load, this);\r\n        this.used[name] = true;\r\n      }\r\n    }\r\n    mods.forEach(recursive_load, this);\r\n    callback(this);\r\n  }\r\n}\r\n</pre>\r\n<p>现在我们来尝试一个与YUI类似的语法风格：</p>\r\n<pre title="code" class="brush: jscript;">\r\nSandbox().use('''', function(){\r\n   alert(''user code.'');\r\n});\r\n</pre>\r\n<p>或者，先向整个Sandbox环境注册一些模块（在真实的框架实现中，这一步可能是通过框架的装载器来初始化）：</p>\r\n<pre title="code" class="brush: jscript;">\r\n\r\n// for test, entry of mods\r\nf1 = function() { alert(''f1'') };\r\nf2 = function() { alert(''f2'') };\r\nf3 = function() { alert(''f3'') };\r\n\r\n// mods for global/common env.\r\nSandbox.prototype.mods = {\r\n  ''core'': { fn: f1, req: [], use: [] },\r\n  ''oo'':   { fn: f2, req: [''core''], use: [''xml''] },\r\n  ''xml'':  { fn: f3, req: [], use: [] }\r\n}\r\n</pre>\r\n<p>然后再尝试在一个沙箱实例中运行代码：</p>\r\n<pre title="code" class="brush: jscript;">\r\n// f1 -&gt; f2 -&gt; f3 -&gt; user code\r\nSandbox().use(''oo'', function(){\r\n   alert(''user code.'');\r\n});\r\n</pre>\r\n<p>其实即便是上述代码中用于处理模块依赖的逻辑，也并不是什么&quot;神奇的&quot;代码或者技巧。除开这些，这样的沙箱隔离泄露的能力还抵不过一个嵌入式DSL语言。而后者所应用的技巧很简单，看不出什么花招（注3)：</p>\r\n<pre title="code" class="brush: jscript;">\r\nwith (YUI()) this.eval(&quot;... mod_context ... &quot;);\r\n</pre>\r\n<p>这样一来，在mod_context里的代码就只会在YUI()的一个实例中造成污染了。当然，仍然是源于JavaScript的限制，我们还是无法避免一个变量泄露到全局--除非，我们回到js in js这个项目（注4），真的在环境中重新初始化一个js引擎。</p>\r\n<p>从这一意义上来说，引擎级别的沙箱与操作系统的进程一样，带来的是终级的解决方案，所以Chrome、IE等等主流浏览器纷纷有了&quot;独立进程&quot;模式。而在这样的背景之下，试图用&quot;框架内置沙箱&quot;来改善ECMAScript ed3中一些设计疏失的种种努力，不过是一张张空头的支票罢了。</p>', 'JavaScript', '2011-03-08 8:22:02'),
(496, '', '<pre title="code" class="brush: jscript;">\r\nfunction lxj(){\r\n	var mods = [].slice.call(arguments, 0); //将函数的形参储存为数组\r\n	return mods;\r\n}\r\ndocument.write(lxj(1,2)+''&lt;br/&gt;'');//输出结果为:[1,2]\r\ndocument.write(lxj(1,2,3)+''&lt;br/&gt;'');//输出结果为:[1,2,3]\r\ndocument.write(lxj(''a'',''b'')+''&lt;br/&gt;'');//输出结果为:[''a'',''b'']\r\ndocument.write(lxj(''a'',''b'',''h'',''j'')+''&lt;br/&gt;'');//输出结果为:[''a'',''b'',''h'',''j'']\r\ndocument.write(lxj(''a'',''b'',''y'')+''&lt;br/&gt;'');//输出结果为:[''a'',''b'',''y'']</pre>\r\n<p>&nbsp;</p>', 'JavaScript', '2011-03-08 8:22:30'),
(501, '', '<p>css3实战&mdash;制作一个弹性滑动的图片显示</p>\r\n<pre title="code" class="brush: css;">\r\n    .flexbox {\r\n        background-color:#ffffff;\r\n \r\n        display: -webkit-box;\r\n        display: -moz-box;\r\n        display: box;\r\n \r\n        -webkit-box-orient: horizontal;\r\n        -moz-box-orient: horizontal;\r\n        box-orient: horizontal;\r\n \r\n        box-align: stretch;\r\n        \r\n        margin-top:20px;\r\n        position: relative;\r\n        overflow:hidden;\r\n \r\n        text-shadow: 1px 1px 1px rgba(240,240,240,0.7);\r\n        \r\n        box-shadow:0 0 10px #cccccc;\r\n        -webkit-box-shadow: 0 0 10px #cccccc;\r\n        -moz-box-shadow:0 0 10px #cccccc;\r\n \r\n    }\r\n \r\n    .flexbox &gt; div {\r\n        -webkit-box-flex: 1;\r\n        -moz-box-flex: 1;\r\n        box-flex: 1;\r\n \r\n        box-align: stretch;\r\n        \r\n        -moz-transition: all 0.5s ease-out;\r\n        -o-transition: all 0.5s ease-out;\r\n        -webkit-transition: all 0.5s ease-out;\r\n        transition: all 0.5s ease-out;\r\n        width: 0;\r\n    }\r\n \r\n    .flexbox &gt; div:hover {\r\n        width: 500px;\r\n    }</pre>\r\n<pre title="code" class="brush: xhtml;">\r\n    &lt;div class=&quot;flexbox&quot;&gt; \r\n        &lt;div&gt; \r\n           &lt;img src=&quot;images/1.png&quot; alt=&quot;死神1&quot; /&gt; \r\n        &lt;/div&gt; \r\n        &lt;div&gt; \r\n            &lt;img src=&quot;images/2.png&quot; alt=&quot;死神2&quot; /&gt; \r\n        &lt;/div&gt; \r\n        &lt;div&gt; \r\n            &lt;img src=&quot;images/3.png&quot; alt=&quot;死神3&quot; /&gt; \r\n        &lt;/div&gt; \r\n        &lt;div&gt; \r\n            &lt;img src=&quot;images/1.png&quot; alt=&quot;死神4&quot; /&gt; \r\n        &lt;/div&gt; \r\n        &lt;div&gt; \r\n            &lt;img src=&quot;images/2.png&quot; alt=&quot;死神5&quot; /&gt; \r\n        &lt;/div&gt; \r\n    &lt;/div&gt; </pre>\r\n<p>&nbsp;</p>', 'CSS3', '2011-03-13 20:42:13');
INSERT INTO `list` (`id`, `title`, `content`, `cat`, `time`) VALUES
(502, '', '<p>在IE下的JS编程需注意的内存释放问题</p>\r\n<p><a href="http://bbs.51js.com/viewthread.php?tid=51770">http://bbs.51js.com/viewthread.php?tid=51770</a></p>\r\n<p>在IE下的JS编程中，以下的编程方式都会造成即使关闭IE也无法释放内存的问题，下面分类给出：<br />\r\n<br />\r\n<font color="red">1、给DOM对象添加的属性是一个对象的引用。范例：</font><br />\r\nvar MyObject = {};<br />\r\ndocument.getElementById(''myDiv'').myProp = MyObject;<br />\r\n<font color="green">解决方法</font>：<br />\r\n在window.onunload事件中写上: document.getElementById(''myDiv'').myProp = null;<br />\r\n<br />\r\n<br />\r\n<font color="red">2、DOM对象与JS对象相互引用。范例：</font><br />\r\nfunction Encapsulator(element) {<br />\r\n&nbsp;&nbsp;this.elementReference = element;<br />\r\n&nbsp;&nbsp;element.myProp = this;<br />\r\n}<br />\r\nnew&nbsp;&nbsp;Encapsulator(document.getElementById(''myDiv''));<br />\r\n<font color="green">解决方法</font>：<br />\r\n在onunload事件中写上: document.getElementById(''myDiv'').myProp = null;<br />\r\n<br />\r\n<br />\r\n<font color="red">3、给DOM对象用attachEvent绑定事件。范例：</font><br />\r\nfunction doClick() {}<br />\r\nelement.attachEvent(&quot;onclick&quot;, doClick);<br />\r\n<font color="green">解决方法</font>：<br />\r\n在onunload事件中写上: element.detachEvent(''onclick'', doClick);<br />\r\n<br />\r\n<br />\r\n<font color="red">4、从外到内执行appendChild。这时即使调用removeChild也无法释放。范例：</font><br />\r\nvar parentDiv =&nbsp;&nbsp;document.createElement(&quot;div&quot;);<br />\r\nvar childDiv = document.createElement(&quot;div&quot;);<br />\r\ndocument.body.appendChild(parentDiv);<br />\r\nparentDiv.appendChild(childDiv);<br />\r\n<font color="green">解决方法</font>：<br />\r\n从内到外执行appendChild:<br />\r\nvar parentDiv =&nbsp;&nbsp;document.createElement(&quot;div&quot;);<br />\r\nvar childDiv = document.createElement(&quot;div&quot;);<br />\r\nparentDiv.appendChild(childDiv);<br />\r\ndocument.body.appendChild(parentDiv);<br />\r\n<br />\r\n<br />\r\n<font color="red">5、反复重写同一个属性会造成内存大量占用(但关闭IE后内存会被释放)。范例：</font><br />\r\nfor(i = 0; i &lt; 5000; i++) {<br />\r\n&nbsp;&nbsp;hostElement.text = &quot;asdfasdfasdf&quot;;<br />\r\n}<br />\r\n这种方式相当于定义了5000个属性！<br />\r\n<font color="green">解决方法：</font><br />\r\n其实没什么解决方法:P~~~就是编程的时候尽量避免出现这种情况咯~~</p>', 'JavaScript', '2011-04-01 8:36:04'),
(499, '', '<p>为什么要用Object.prototype.toString而不是Function.prototype.toString或者其它？这是和他们的toString解释方式有关系的。下面是ECMA中对Object.prototype.toString的解释：</p>\r\n<p><code>Object.prototype.toString( )<br />\r\nWhen the toString method is called, the following steps are taken:<br />\r\n1. Get the [[Class]] property of this object.<br />\r\n2. Compute a string value by concatenating the three strings &ldquo;[object &ldquo;, Result (1), and &ldquo;]&rdquo;.<br />\r\n3. Return Result (2)<br />\r\n</code></p>\r\n<p>其过程简单说来就是：1、获取对象的类名（对象类型）。2、然后将[object、获取的类名、]组合并返回。</p>\r\n<p>ECMA中对Array有如下说明：</p>\r\n<p><code>The [[Class]] property of the newly constructed object is set to &ldquo;Array&rdquo;.</code></p>\r\n<p>因此我们用如下代码来检测数组：</p>\r\n<pre><span class="keywords">function</span> isArray(o) { <br />&nbsp;&nbsp;<span class="keywords">return</span> Object.<span class="global">prototype</span>.<span class="global">toString</span>.call(o) === <span class="string">''[object Array]''</span>;&nbsp;&nbsp;<br />}</pre>\r\n<p>function isArray(o) {&lt;br/&gt;  return Object.prototype.toString.call(o) === ''[object Array]''; &lt;br/&gt;}</p>\r\n<p>这种方式既解决了instanceof存在的跨页面问题，也解决了属性检测方式所存在的问题，实在是一种妙招，一个很好的解决方案。</p>\r\n<p>除此之外，这种解决办法也可以应用于判断Date,Function等类型的对象。</p>', 'JavaScript', '2011-03-10 22:18:06'),
(500, '', '前端:\r\n<br />You can see what we do，but we do more than what you see.', '随笔', '2011-03-11 11:04:58'),
(503, '', '<p>http://bbs.51js.com/viewthread.php?tid=45812&amp;extra=page%3D1</p>\r\n<p>我认识了一个程序员,讲到我们毕业生出来工资大概多少的时候,他出了一道题,说,这个题目的月薪是1000 ,如果做不出 说明你现在可能还需要努力突破￥1000 ,而不是突破￥5000   请用程序打印出a b c d e f g h i j k l这十二个字符的全部组合，每种组合占一行 你的结果可能会是 a b c d e a b c d f &hellip;&hellip; 请用任何你熟悉的语言写出程序   10分钟内完成</p>\r\n<pre title="code" class="brush: jscript;">\r\nvar stack = new Array(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;,&quot;g&quot;,&quot;h&quot;,&quot;i&quot;,&quot;j&quot;,&quot;k&quot;,&quot;l&quot;);\r\nvar buff = new Array();\r\n\r\nfunction getComb(stack, buff)\r\n{\r\n	if(stack.length + buff.length &lt; 5) return; //字母不够了，不用再试\r\n	while(stack.length &gt; 0) //字母还没用完\r\n	{\r\n		buff.push(stack.shift()); //选取字母\r\n		if(buff.length &lt; 5) //还没到5个字母\r\n		{\r\n			getComb(stack.slice(0), buff.slice(0)); //继续选取\r\n		}\r\n		else if(buff.length == 5)\r\n		{\r\n			document.write(buff+&quot;&lt;br&gt;&quot;); //够数量了，输出\r\n		}\r\n		buff.pop(); //丢弃用过的字母\r\n	}\r\n\r\n	return;\r\n}\r\ngetComb(stack, buff);</pre>\r\n<p>&nbsp;</p>', 'JavaScript', '2011-04-02 9:03:58'),
(504, '', '<p>javascript中的作用域scope</p>\r\n<p>在一般程序设计语言中，作用域是按块来划分的。即&ldquo;变量定义在哪个块之内，这个块就是变量的有效范围&rdquo;。而在javascript中，变量的作用域是按函数来划分的&mdash;&mdash;变量在某个函数范围内有效。比如：</p>\r\n<p>var f = false;</p>\r\n<p>if(true) { var f = true; } &nbsp; //此时f位于if内，也就是块内，等价于还是全局范围内</p>\r\n<p>alert(f) &nbsp;//所以，结果为true</p>\r\n<p>&nbsp;</p>\r\n<p>再如下例：</p>\r\n<p>var f = false;</p>\r\n<p>function test() {</p>\r\n<p>　　var f = true; &nbsp;//这是函数内定义的变量，只在函数内部有效，函数执行完毕后，该变量将被释放</p>\r\n<p>}</p>\r\n<p>test();</p>\r\n<p>alert(f) //结果为false，并没有因为test()的执行而改变</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>再有，在javascript中声明的全局变量都可以看作是window对象的一个属性，比如：</p>\r\n<p>var test = &quot;this is a test&quot;;</p>\r\n<p>alert(window.test == test) &nbsp;//结果为true</p>\r\n<p>这正好验证了上边所说的全局变量也是window对象的属性</p>\r\n<p>&nbsp;</p>\r\n<p>最后，我们来看</p>\r\n<p>function test() {</p>\r\n<p>　　f = false;</p>\r\n<p>}</p>\r\n<p>test();</p>\r\n<p>alert(f) //结果为false</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>', 'JavaScript', '2011-04-10 13:35:01'),
(505, '', '<h2>最佳的&quot;addEvent&quot;是怎样诞生的</h2>\r\n<p>&nbsp;IE的 JScript 存在内存泄露的bug 想必大家都清楚或者有耳闻了。这是由于IE的内存回收管理器的一个设计错误导致的。当我们编写脚本的时候创建了交叉引用，例如如下代码： window.onload = function () {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; var x = document.getElementsByTagName(&rsquo;H3&rsquo;);&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; for (var i=0;i&lt;x.length;i++)&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x[i].onclick = openClose;&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x[i].relatedElement = x[i].nextSibling; // simplified situation&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x[i].relatedElement.relatedElement = x[i];&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;<br />\r\n}或者在函数中使用脚本语言最常见的闭句Closures的时候，IE都无法回收内存。而闭句在给DOM对象注册事件处理器(event handler)的时候最为常用。Novemberborn提供了一些example可以让你运行并切实感受到这个bug。&nbsp;&nbsp;<br />\r\n我最喜爱的QuirkMode  去年初意识到这个bug存在巨大隐患，觉得有必要呼吁广大web开发者关注并竭力避免这个问题，于是举办了一个慈善邀请赛，鼓励大家提交各自  addEvent/removeEvent 方案。并终于在去年10月下旬宣布了他们认为的胜利者：John  Resig，让John赢得胜利的代码如下：&nbsp;&nbsp;&nbsp;<br />\r\n<br />\r\nfunction addEvent( obj, type, fn ) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp; if ( obj.attachEvent ) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; obj[&rsquo;e&rsquo;+type+fn] = fn;&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; obj[type+fn] = function(){obj[&rsquo;e&rsquo;+type+fn]( window.event );}&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; obj.attachEvent( &rsquo;on&rsquo;+type, obj[type+fn] );&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp; } else&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; obj.addEventListener( type, fn, false );&nbsp;&nbsp;<br />\r\n}&nbsp;&nbsp;<br />\r\nfunction removeEvent( obj, type, fn ) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp; if ( obj.detachEvent ) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; obj.detachEvent( &rsquo;on&rsquo;+type, obj[type+fn] );&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; obj[type+fn] = null;&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp; } else&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; obj.removeEventListener( type, fn, false );&nbsp;&nbsp;<br />\r\n}&nbsp;&nbsp;<br />\r\nQuirkMode 对选择John为胜利者的解释概括来说就是以上代码最简洁有效，在避免内存问题的同时还巧妙的保证了this关键字在ie的attachEvent中能正常工作。缺点当然还是存在：&nbsp;&nbsp;&nbsp;<br />\r\n<br />\r\n不支持 Netscape 4 和 Explorer 5 Mac。(有可能国内的程序员会嗤之以鼻，但国外很强调广泛的兼容性)&nbsp;&nbsp;&nbsp;<br />\r\n在 removeEvent 中遗漏了remove obj[&quot;e&quot;+type+fn]。&nbsp;&nbsp;&nbsp;<br />\r\n总之不管怎么说，简单取胜。&nbsp;&nbsp;<br />\r\n结果一出，众多参赛与评论者不服气，很快又挑出了John的代码的几处毛病：&nbsp;&nbsp;&nbsp;<br />\r\n<br />\r\naddEvent中本身就使用了闭句，所以没有根本解决IE内存泄露的问题。&nbsp;&nbsp;&nbsp;<br />\r\n没有解决同类型的事件可能被重复注册而被IE重复执行的问题。&nbsp;&nbsp;&nbsp;<br />\r\n几个高手于是提出了改进性的方案： /*&nbsp;&nbsp;<br />\r\nOriginal idea by John Resig&nbsp;&nbsp;<br />\r\nTweaked by Scott Andrew LePera, Dean Edwards and Peter-Paul Koch&nbsp;&nbsp;<br />\r\nFixed for IE by Tino Zijdel (crisp)&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; Note that in IE this will cause memory leaks and still doesn&rsquo;t  quite function the same as in browsers that do support the W3C event  model:&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; - event execution order is not the same (LIFO in IE against FIFO)&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; - functions attached to the same event on the same element multiple times will also get executed multiple times in IE&nbsp;&nbsp;<br />\r\n*/&nbsp;&nbsp;<br />\r\nfunction addEvent( obj, type, fn ) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; if (obj.addEventListener)&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj.addEventListener( type, fn, false );&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; else if (obj.attachEvent) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj[&quot;e&quot;+type+fn] = fn;&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj.attachEvent( &quot;on&quot;+type, function() { obj[&quot;e&quot;+type+fn](); } );&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;<br />\r\n}&nbsp;&nbsp;<br />\r\nfunction removeEvent( obj, type, fn ) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; if (obj.removeEventListener)&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj.removeEventListener( type, fn, false );&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; else if (obj.detachEvent) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj.detachEvent( &quot;on&quot;+type, obj[&quot;e&quot;+type+fn] );&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj[&quot;e&quot;+type+fn] = null;&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;<br />\r\n}&nbsp;&nbsp;<br />\r\n很明显，虽然修正了John代码的一些不足。但内存泄露依然存在，部分浏览器依然不支持，还是无法避免ie重复注册。另外根据注释:当在同一个对象上注册多个事件处理器的时候，IE与其他浏览器的执行顺序是不同的，这又是一个隐患。&nbsp;&nbsp;<br />\r\n<br />\r\n几天之后，一个被认为最严谨的方案由Dean Edwards 提出。Dean他的方案与众不同：&nbsp;&nbsp;&nbsp;<br />\r\n<br />\r\n不执行对象检测(Object detection)&nbsp;&nbsp;&nbsp;<br />\r\n没有调用 addeventListener/attachEvent 方法&nbsp;&nbsp;&nbsp;<br />\r\n保持this关键字的运行于正确的上下文环境&nbsp;&nbsp;&nbsp;<br />\r\n正确传递 event 对象参数&nbsp;&nbsp;&nbsp;<br />\r\n完全跨浏览器至此(包括IE4和NS4)&nbsp;&nbsp;&nbsp;<br />\r\n不存在内存泄露&nbsp;&nbsp;&nbsp;<br />\r\nDean的代码如下： // written by Dean Edwards, 2005&nbsp;&nbsp;<br />\r\n// <a target="_blank" href="http://dean.edwards.name/function%C2%A0">http://dean.edwards.name/function </a>  ;\r\n<br />addEvent(element, type, handler) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; // assign each event handler a unique ID&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; // 为事件处理函数设定一个唯一值&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; if (!handler.$$guid) handler.$$guid = addEvent.guid++;&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; // create a hash table of event types for the element&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; if (!element.events) element.events = {};&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; // create a hash table of event handlers for each element/event pair&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; var handlers = element.events[type];&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; if (!handlers) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handlers = element.events[type] = {};&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // store the existing event handler (if there is one)&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 如果对象已经注册有事件处理，那么要保留下来,并保存为第一个&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (element[&quot;on&quot; + type]) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handlers[0] = element[&quot;on&quot; + type];&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; // store the event handler in the hash table&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; handlers[handler.$$guid] = handler;&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; // assign a global event handler to do all the work&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; // 指派一个全局函数做统一的事件处理，同时避免了反复注册&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; element[&quot;on&quot; + type] = handleEvent;&nbsp;&nbsp;<br />\r\n};&nbsp;&nbsp;<br />\r\n// a counter used to create unique IDs&nbsp;&nbsp;<br />\r\naddEvent.guid = 1;function removeEvent(element, type, handler) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; // delete the event handler from the hash table&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; if (element.events &amp;&amp; element.events[type]) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete element.events[type][handler.$$guid];&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;<br />\r\n};function handleEvent(event) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; // grab the event object (IE uses a global event object)&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; event = event || window.event;&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; // get a reference to the hash table of event handlers&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; // 这里的 this 随 handlerEvent function 被触发的source element 变化而变化&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; var handlers = this.events[event.type];&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; // execute each event handler&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; for (var i in handlers) {&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //这样写才能保证注册的事件处理函数中的 this 得到正确的引用，直接handlers[i]()是不行的&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.$$handleEvent = handlers[i];&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.$$handleEvent(event);&nbsp;&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;<br />\r\n};&nbsp;&nbsp;<br />\r\n这段代码相比之前就大了不少了，不过确实很精妙。可是这段代码却引入了其他的问题，比如无法处理事件处理函数的返回值，for..in循环可能因为  (Object.prototype)的错误应用而中断等等...很快Dean推出一个&quot;updated version&quot;。&nbsp;&nbsp;<br />\r\n<br />\r\n要做到最好真的好辛苦。&nbsp;&nbsp;<br />\r\n<br />\r\n目前似乎Dean的最终版本是最全面的解决方案。不过就我个人意见，感觉有些吹毛求疵了。尽量使用浏览器本身的实现和保持简单是我一贯坚持的主张。但洋人这种严谨的态度，还是让我深深敬佩。</p>', 'JavaScript', '2011-04-10 21:18:53'),
(506, '', '<p>IE与现代浏览器在DOM中最大的差异是什么无疑就是event了。各个浏览器接口的差异以及够头疼了，而IE甚至Firefox早期版本由于内存管理机制不完善，很容易在事件处理中导致内存泄漏。</p>\r\n<p>event究竟有多么复杂？可见前辈的6年前的努力：<a href="http://blog.csdn.net/alex197963/archive/2009/08/18/4458737.aspx">最佳的addEvent是怎样诞生的</a>，后起之秀jQuery也付出了一千六百多行血汗代码（v 1.5.1）搞定了6年后出现的各种核的浏览器。</p>\r\n<p>我参考前辈的代码以及自己的理解尝试写了一个事件框架，我的框架完成了一个事件机制的核心，它能提供统一接口实现多事件绑定以及避免内存泄漏等其他一些问题，更重要的是性能还不错。</p>\r\n<p><strong>我的手法：</strong></p>\r\n<ol>\r\n    <li>所有回调函数根据元素、事件类型、回调函数唯一ID缓存在一个_create对象中（其内部具体结构可见下面源码的关于_cache的注释）。</li>\r\n    <li>事件绑定使用一个_create代理函数处理，并且一个元素的各类型事件全部通过此进行分发，同时运用apply方法让IE的指针指向元素。</li>\r\n    <li>通过数组队列解决IE回调函数执行顺序的问题。</li>\r\n    <li>fix函数将处理回调函数传入的event参数以及其他兼容问题。此处参考了jQuery.event.fix。</li>\r\n    <li>断开事件与元素的循环引用避免内存泄漏。</li>\r\n</ol>\r\n<p><strong>一、核心实现：</strong></p>\r\n<pre class="brush:javascript">\r\n \r\n// myEvent 0.2\r\n// 2011.04.06 - TangBin - planeart.cn - MIT Licensed\r\n/**\r\n * 事件框架\r\n * @namespace\r\n * @see http://www.planeart.cn/?p=1285\r\n */\r\nvar myEvent = (function () {\r\nvar _fid = 1,\r\n	_guid = 1,\r\n	_time = (new Date).getTime(),\r\n	_nEid = ''{$eid}'' + _time,\r\n	_nFid = ''{$fid}'' + _time,\r\n	_DOM = document.addEventListener,\r\n	_noop = function () {},\r\n	_create = function (guid) {\r\n		return function (event) {\r\n			event = api.fix(event || window.event);\r\n			var i = 0,\r\n				type = (event || (event = document.event)).type,\r\n				elem = _cache[guid].elem,\r\n				data = arguments,\r\n				events = _cache[guid].events[type];\r\n \r\n			for (; i &lt; events.length; i ++) {\r\n				if (events[i].apply(elem, data) === false) event.preventDefault();\r\n			};\r\n		};\r\n	},\r\n	_cache = {/*\r\n		1: {\r\n			elem: (HTMLElement),\r\n			events: {\r\n				click: [(Function), (..)],\r\n				(..)\r\n			},\r\n			listener: (Function)\r\n		},\r\n		(..)\r\n	*/};\r\n \r\nvar api = {\r\n \r\n	/**\r\n	 * 事件绑定\r\n	 * @param	{HTMLElement}	元素\r\n	 * @param	{String}		事件名\r\n	 * @param	{Function}		要绑定的函数\r\n	 */\r\n	bind: function (elem, type, callback) {\r\n		var guid = elem[_nEid] || (elem[_nEid] = _guid ++);\r\n \r\n		if (!_cache[guid]) _cache[guid] = {\r\n			elem: elem,\r\n			listener: _create(guid),\r\n			events: {}\r\n		};\r\n \r\n		if (type &amp;&amp; !_cache[guid].events[type]) {\r\n			_cache[guid].events[type] = [];\r\n			api.add(elem, type, _cache[guid].listener);\r\n		};\r\n \r\n		if (callback) {\r\n			if (!callback[_nFid]) callback[_nFid] = _fid ++;\r\n			_cache[guid].events[type].push(callback);\r\n		} else\r\n			return _cache[guid];\r\n	},\r\n \r\n	/**\r\n	 * 事件卸载\r\n	 * @param	{HTMLElement}	元素\r\n	 * @param	{String}		事件名\r\n	 * @param	{Function}		要卸载的函数\r\n	 */\r\n	unbind: function (elem, type, callback) {\r\n		var events, i, list,\r\n			guid = elem[_nEid],\r\n			handler = _cache[guid];\r\n \r\n		if (!handler) return;\r\n		events = handler.events;\r\n \r\n		if (callback) {\r\n \r\n			list = events[type];\r\n			if (!list) return;\r\n			for (i = 0; i &lt; list.length; i ++) {\r\n				list[i][_nFid] === callback[_nFid] &amp;&amp; list.splice(i--, 1);\r\n			};\r\n			if (list.length === 0) return api.unbind(elem, type);\r\n \r\n		} else if (type) {\r\n \r\n			delete events[type];\r\n			api.remove(elem, type, handler.listener);\r\n \r\n		} else {\r\n \r\n			for (i in events) {\r\n				api.remove(elem, i, handler.listener);\r\n			};\r\n			delete _cache[guid];\r\n \r\n		};\r\n	},\r\n \r\n	/**\r\n	 * 事件触发 (注意：不会触发浏览器默认行为与冒泡)\r\n	 * @param	{HTMLElement}	元素\r\n	 * @param	{String}		事件名\r\n	 * @param	{Array}			(可选)附加数据\r\n	 */\r\n	triggerHandler: function (elem, type, data) {\r\n		var guid = elem[_nEid],\r\n			event = {\r\n				type: type,\r\n				target: elem,\r\n				currentTarget: elem,\r\n				preventDefault: _noop,\r\n				stopPropagation: _noop\r\n			};\r\n \r\n		data = data || [];\r\n		data.unshift(event);\r\n \r\n		guid &amp;&amp; _cache[guid].listener.apply(elem, data);\r\n \r\n		try {\r\n			elem[''on'' + type] &amp;&amp; elem[''on'' + type].apply(elem, data);\r\n			//elem[type] &amp;&amp; elem[type]();\r\n		} catch (e) {};\r\n	},\r\n \r\n	// 原生事件绑定接口\r\n	add: _DOM ? function (elem, type, listener) {\r\n		elem.addEventListener(type, listener, false);\r\n	} : function (elem, type, listener) {\r\n		elem.attachEvent(''on'' + type, listener);\r\n	},\r\n \r\n	// 原生事件卸载接口\r\n	remove: _DOM ? function (elem, type, listener) {\r\n		elem.removeEventListener(type, listener, false);\r\n	} : function (elem, type, listener) {\r\n		elem.detachEvent(''on'' + type, listener);\r\n	},\r\n \r\n	// 修正\r\n	fix: function (event) {\r\n		if (_DOM) return event;\r\n		var name,\r\n			newEvent = {},\r\n			doc = document.documentElement,\r\n			body = document.body;\r\n \r\n		newEvent.target = event.srcElement || document;\r\n		newEvent.target.nodeType === 3 &amp;&amp; (newEvent.target = newEvent.target.parentNode);\r\n		newEvent.preventDefault = function () {event.returnValue = false};\r\n		newEvent.stopPropagation = function () {event.cancelBubble = true};\r\n		newEvent.pageX = newEvent.clientX + (doc &amp;&amp; doc.scrollLeft || body &amp;&amp; body.scrollLeft || 0) - (doc &amp;&amp; doc.clientLeft || body &amp;&amp; body.clientLeft || 0);\r\n		newEvent.pageY = newEvent.clientY + (doc &amp;&amp; doc.scrollTop  || body &amp;&amp; body.scrollTop  || 0) - (doc &amp;&amp; doc.clientTop  || body &amp;&amp; body.clientTop  || 0);\r\n		newEvent.relatedTarget = event.fromElement === newEvent.target ? event.toElement : event.fromElement;\r\n \r\n		// !!IE写event会极其容易导致内存泄漏，Firefox写event会报错\r\n		// 拷贝event\r\n		for (name in event) newEvent[name] = event[name];\r\n \r\n		return newEvent;\r\n	}\r\n \r\n};\r\n \r\nreturn api;\r\n})();\r\n</pre>\r\n<p>我给一万个元素绑定事件进行了测试，测试工具为sIEve，结果：</p>\r\n<blockquote>\r\n<table width="340" border="1" cellpadding="7" cellspacing="2">\r\n    <tbody>\r\n        <tr>\r\n            <td width="100">事件框架</td>\r\n            <td width="73">耗时</td>\r\n            <td width="117">内存</td>\r\n        </tr>\r\n        <tr>\r\n            <td colspan="3" align="center" bgcolor="#F7F7F7">IE8</td>\r\n        </tr>\r\n        <tr>\r\n            <td>jQuery.bind</td>\r\n            <td>1064 MS</td>\r\n            <td>79.80 MB</td>\r\n        </tr>\r\n        <tr>\r\n            <td>myEvent.bind</td>\r\n            <td>623 MS</td>\r\n            <td>35.82 MB</td>\r\n        </tr>\r\n        <tr>\r\n            <td colspan="3" align="center" bgcolor="#F7F7F7">IE6</td>\r\n        </tr>\r\n        <tr>\r\n            <td>jQuery.bind</td>\r\n            <td>2503 MS</td>\r\n            <td>74.23 MB</td>\r\n        </tr>\r\n        <tr>\r\n            <td height="35">myEvent.bind</td>\r\n            <td>1810 MS</td>\r\n            <td>28.48 MB</td>\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n</blockquote>\r\n<p>可以看到无论是执行效率还是内存占用myEvent都比有一定优势，这是可能是由于jQuery事件机制过于强大导致其性能的损耗。<br />\r\n测试样本：<a href="http://www.planeart.cn/demo/myEvent/">http://www.planeart.cn/demo/myEvent/</a></p>\r\n<p><strong>二、扩展自定义事件机制</strong><br />\r\njQuery是可以自定义事件的，它用一个special命名空间存储自定义事件，我在上面代码的基础上模仿jQuery自定义事件机制，并把其著名的ready事件与另外一个jQuery hashchange事件插件移植过来。</p>\r\n<p>这两个自定义事件非常重要，ready事件可以在DOM就绪给元素绑定事件，比传统使用window.onload要快很多；hashchange事件可以监听锚点改变，常用于解决AJAX历史记录问题，如Twitter新版本就就采用此处理AJAX，使用锚点机制除了可以提高AJAX应用程序的用户体验外，如果按照一定规则还能被google索引到。</p>\r\n<p>当然，我前面文章实现的imgReady事件也可以通过此扩展进来，稍后更新。</p>\r\n<pre class="brush:javascript">\r\n \r\n// myEvent 0.2.2\r\n// 2011.04.07 - TangBin - planeart.cn - MIT Licensed\r\n/**\r\n * 事件框架\r\n * @namespace\r\n * @see http://www.planeart.cn/?p=1285\r\n */\r\nvar myEvent = (function () {\r\n \r\nvar _ret, _name,\r\n	_fid = 1,\r\n	_guid = 1,\r\n	_time = (new Date).getTime(),\r\n	_nEid = ''{$eid}'' + _time,\r\n	_nFid = ''{$fid}'' + _time,\r\n	_DOM = document.addEventListener,\r\n	_noop = function () {},\r\n	_create = function (guid) {\r\n		return function (event) {\r\n			event = myEvent.fix(event || window.event);\r\n			var type = (event || (event = document.event)).type,\r\n				elem = _cache[guid].elem,\r\n				data = arguments,\r\n				events = _cache[guid].events[type],\r\n				i = 0,\r\n				length = events.length;\r\n \r\n			for (; i &lt; length; i ++) {\r\n				if (events[i].apply(elem, data) === false) event.preventDefault();\r\n			};\r\n \r\n			event = elem = null;\r\n		};\r\n	},\r\n	_cache = {/*\r\n		1: {\r\n			elem: (HTMLElement),\r\n			events: {\r\n				click: [(Function), (..)],\r\n				(..)\r\n			},\r\n			listener: (Function)\r\n		},\r\n		(..)\r\n	*/};\r\n \r\nvar API = function () {};\r\nAPI.prototype = {\r\n \r\n	/**\r\n	 * 事件绑定\r\n	 * @param	{HTMLElement}	元素\r\n	 * @param	{String}		事件名\r\n	 * @param	{Function}		要绑定的函数\r\n	 */\r\n	bind: function (elem, type, callback) {\r\n		var events, listener,\r\n			guid = elem[_nEid] || (elem[_nEid] = _guid ++),\r\n			special = this.special[type] || {},\r\n			cacheData = _cache[guid];\r\n \r\n		if (!cacheData) cacheData = _cache[guid] = {\r\n			elem: elem,\r\n			listener: _create(guid),\r\n			events: {}\r\n		};\r\n \r\n		events = cacheData.events;\r\n		listener = cacheData.listener;\r\n		if (!events[type]) events[type] = [];\r\n		if (!callback[_nFid]) callback[_nFid] = _fid ++;\r\n		if (!special.setup || special.setup.call(elem, listener) === false) {\r\n			events[type].length === 0 &amp;&amp; this.add(elem, type, listener);\r\n		};\r\n		events[type].push(callback);\r\n	},\r\n \r\n	/**\r\n	 * 事件卸载\r\n	 * @param	{HTMLElement}	元素\r\n	 * @param	{String}		事件名\r\n	 * @param	{Function}		要卸载的函数\r\n	 */\r\n	unbind: function (elem, type, callback) {\r\n		var events, special, i, list, fid,\r\n			guid = elem[_nEid],\r\n			cacheData = _cache[guid];\r\n \r\n		if (!cacheData) return;\r\n		events = cacheData.events;\r\n \r\n		if (callback) {\r\n \r\n			list = events[type];\r\n			fid = callback[_nFid];\r\n			if (!list) return;\r\n \r\n			for (i = 0; i &lt; list.length; i ++) {\r\n				list[i][_nFid] === fid &amp;&amp; list.splice(i--, 1);\r\n			};\r\n			if (!list.length) this.unbind(elem, type);\r\n \r\n		} else if (type) {\r\n \r\n			special = this.special[type] || {};\r\n			if (!special.teardown || special.teardown.call(elem) === false) {\r\n				this.remove(elem, type, cacheData.listener);\r\n			};\r\n			delete events[type];\r\n \r\n		} else {\r\n \r\n			for (i in events) {\r\n				this.remove(elem, i, cacheData.listener);\r\n			};\r\n			delete _cache[guid];\r\n \r\n		};\r\n \r\n	},\r\n \r\n	/**\r\n	 * 事件触发 (注意：不会触发浏览器默认行为与冒泡)\r\n	 * @param	{HTMLElement}	元素\r\n	 * @param	{String}		事件名\r\n	 * @param	{Array}			(可选)附加数据\r\n	 */\r\n	triggerHandler: function (elem, type, data) {\r\n		var guid = elem[_nEid],\r\n			cacheData = _cache[guid],\r\n			event = {\r\n				type: type,\r\n				target: elem,\r\n				currentTarget: elem,\r\n				preventDefault: _noop,\r\n				stopPropagation: _noop\r\n			};\r\n \r\n		data = data || [];\r\n		data.unshift(event);\r\n \r\n		cacheData &amp;&amp; cacheData.events[type] &amp;&amp; _cache[guid].listener.apply(elem, data);\r\n \r\n		try {\r\n			elem[''on'' + type] &amp;&amp; elem[''on'' + type].apply(elem, data);\r\n			//elem[type] &amp;&amp; elem[type]();\r\n		} catch (e) {};\r\n	},\r\n \r\n	// 自定义事件接口\r\n	special: {},\r\n \r\n	// 原生事件绑定接口\r\n	add: _DOM ? function (elem, type, listener) {\r\n		elem.addEventListener(type, listener, false);\r\n	} : function (elem, type, listener) {\r\n		elem.attachEvent(''on'' + type, listener);\r\n	},\r\n \r\n	// 原生事件卸载接口\r\n	remove: _DOM ? function (elem, type, listener) {\r\n		elem.removeEventListener(type, listener, false);\r\n	} : function (elem, type, listener) {\r\n		elem.detachEvent(''on'' + type, listener);\r\n	},\r\n \r\n	// 修正\r\n	fix: function (event) {\r\n		if (_DOM) return event;\r\n \r\n		var name,\r\n			newEvent = {},\r\n			doc = document.documentElement,\r\n			body = document.body;\r\n \r\n		newEvent.target = event.srcElement || document;\r\n		newEvent.target.nodeType === 3 &amp;&amp; (newEvent.target = newEvent.target.parentNode);\r\n		newEvent.preventDefault = function () {event.returnValue = false};\r\n		newEvent.stopPropagation = function () {event.cancelBubble = true};\r\n		newEvent.pageX = newEvent.clientX + (doc &amp;&amp; doc.scrollLeft || body &amp;&amp; body.scrollLeft || 0) - (doc &amp;&amp; doc.clientLeft || body &amp;&amp; body.clientLeft || 0);\r\n		newEvent.pageY = newEvent.clientY + (doc &amp;&amp; doc.scrollTop  || body &amp;&amp; body.scrollTop  || 0) - (doc &amp;&amp; doc.clientTop  || body &amp;&amp; body.clientTop  || 0);\r\n		newEvent.relatedTarget = event.fromElement === newEvent.target ? event.toElement : event.fromElement;\r\n \r\n		// !!直接写event IE导致内存泄漏，Firefox会报错\r\n		// 伪装event\r\n		for (name in event) newEvent[name] = event[name];\r\n		return newEvent;\r\n	}\r\n \r\n};\r\n \r\nreturn new API();\r\n})();\r\n \r\n// DOM就绪事件\r\nmyEvent.ready = (function () {\r\n	var readyList = [], DOMContentLoaded,\r\n		readyBound = false, isReady = false;\r\n \r\n	function ready () {\r\n		if (!isReady) {\r\n			if (!document.body) return setTimeout(ready, 13);\r\n			isReady = true;\r\n \r\n			if (readyList) {\r\n				var fn, i = 0;\r\n				while ((fn = readyList[i++])) {\r\n					fn.call(document, {});\r\n				};\r\n				readyList = null;\r\n			};\r\n		};\r\n	};\r\n \r\n	function bindReady () {\r\n		if (readyBound) return;\r\n \r\n		readyBound = true;\r\n \r\n		if (document.readyState === ''complete'') {\r\n			return ready();\r\n		};\r\n \r\n		if (document.addEventListener) {\r\n			document.addEventListener(''DOMContentLoaded'', DOMContentLoaded, false);\r\n			window.addEventListener(''load'', ready, false);\r\n		} else if (document.attachEvent) {\r\n			document.attachEvent(''onreadystatechange'', DOMContentLoaded);\r\n			window.attachEvent(''onload'', ready);\r\n			var toplevel = false;\r\n			try {\r\n				toplevel = window.frameElement == null;\r\n			} catch (e) {};\r\n \r\n			if (document.documentElement.doScroll &amp;&amp; toplevel) {\r\n				doScrollCheck();\r\n			};\r\n		};\r\n	};\r\n \r\n	myEvent.special.ready = {\r\n		setup: bindReady,\r\n		teardown: function () {}\r\n	};\r\n \r\n	if (document.addEventListener) {\r\n		DOMContentLoaded = function () {\r\n			document.removeEventListener(''DOMContentLoaded'', DOMContentLoaded, false);\r\n			ready();\r\n		};\r\n	} else if (document.attachEvent) {\r\n		DOMContentLoaded = function () {\r\n			if (document.readyState === ''complete'') {\r\n				document.detachEvent(''onreadystatechange'', DOMContentLoaded);\r\n				ready();\r\n			};\r\n		};\r\n	};\r\n \r\n	function doScrollCheck () {\r\n		if (isReady) return;\r\n \r\n		try {\r\n			document.documentElement.doScroll(''left'');\r\n		} catch (e) {\r\n			setTimeout(doScrollCheck, 1);\r\n			return;\r\n		};\r\n		ready();\r\n	};\r\n \r\n	return function (callback) {\r\n		bindReady();\r\n \r\n		if (isReady) {\r\n			callback.call(document, {});\r\n		} else if (readyList) {\r\n			readyList.push(callback);\r\n		};\r\n \r\n		return this;\r\n	};\r\n})();\r\n \r\n// Hashchange Event v1.3\r\n(function (window, undefined) {\r\n    var config = {\r\n			delay: 50,\r\n			src: null,\r\n			domain: null\r\n		},\r\n		str_hashchange = ''hashchange'',\r\n        doc = document,\r\n		isIE = !-[1,],\r\n        fake_onhashchange, special = myEvent.special,\r\n        doc_mode = doc.documentMode,\r\n        supports_onhashchange = ''on'' + str_hashchange in window &amp;&amp; (doc_mode === undefined || doc_mode &gt; 7);\r\n \r\n    function get_fragment(url) {\r\n        url = url || location.href;\r\n        return ''#'' + url.replace(/^[^#]*#?(.*)$/, ''$1'');\r\n    };\r\n \r\n    special[str_hashchange] = {\r\n        setup: function () {\r\n            if (supports_onhashchange) return false;\r\n \r\n            myEvent.ready(fake_onhashchange.start);\r\n        },\r\n        teardown: function () {\r\n            if (supports_onhashchange) return false;\r\n            myEvent.ready(fake_onhashchange.stop);\r\n        }\r\n    };\r\n \r\n	/** @inner */\r\n    fake_onhashchange = (function () {\r\n        var self = {},\r\n            timeout_id, last_hash = get_fragment(),\r\n			/** @inner */\r\n            fn_retval = function (val) {\r\n                return val;\r\n            },\r\n            history_set = fn_retval,\r\n            history_get = fn_retval;\r\n \r\n        self.start = function () {\r\n            timeout_id || poll();\r\n        };\r\n \r\n        self.stop = function () {\r\n            timeout_id &amp;&amp; clearTimeout(timeout_id);\r\n            timeout_id = undefined;\r\n        };\r\n \r\n        function poll() {\r\n            var hash = get_fragment(),\r\n                history_hash = history_get(last_hash);\r\n            if (hash !== last_hash) {\r\n                history_set(last_hash = hash, history_hash);\r\n                myEvent.triggerHandler(window, str_hashchange);\r\n            } else if (history_hash !== last_hash) {\r\n                location.href = location.href.replace(/#.*/, '''') + history_hash;\r\n            };\r\n            timeout_id = setTimeout(poll, config.delay);\r\n        };\r\n \r\n        isIE &amp;&amp; !supports_onhashchange &amp;&amp; (function () {\r\n            var iframe,iframe_src, iframe_window;\r\n \r\n            self.start = function () {\r\n                if (!iframe) {\r\n                    iframe_src = config.src;\r\n                    iframe_src = iframe_src &amp;&amp; iframe_src + get_fragment();\r\n \r\n					iframe = doc.createElement(''<iframe tabindex="-1" style="display:none" title="empty" src="'' + (iframe_src || ''javascript:0'') + ''"></iframe>'');\r\n					myEvent.bind(iframe, ''load'', function () {\r\n						myEvent.unbind(iframe, ''load'');\r\n						iframe_src || history_set(get_fragment());\r\n                        poll();\r\n                    });\r\n					doc.getElementsByTagName(''html'')[0].appendChild(iframe);\r\n					iframe_window = iframe.contentWindow;\r\n                    doc.onpropertychange = function () {\r\n                        try {\r\n                            if (event.propertyName === ''title'') {\r\n                                iframe_window.document.title = doc.title;\r\n                            };\r\n                        } catch (e) {};\r\n                    };\r\n                };\r\n            };\r\n \r\n            self.stop = fn_retval;\r\n \r\n			/** @inner */\r\n            history_get = function () {\r\n                return get_fragment(iframe_window.location.href);\r\n            };\r\n \r\n			/** @inner */\r\n            history_set = function (hash, history_hash) {\r\n                var iframe_doc = iframe_window.document,\r\n                    domain = config.domain;\r\n                if (hash !== history_hash) {\r\n					iframe_doc.title = doc.title;\r\n                    iframe_doc.open();\r\n                    domain &amp;&amp; iframe_doc.write(''<script>document.domain="'' + domain + ''"</script>'');\r\n					iframe_doc.close();\r\n                    iframe_window.location.hash = hash;\r\n                };\r\n            };\r\n        })();\r\n \r\n        return self;\r\n    })();\r\n})(this);\r\n</pre>\r\n<p>ready事件是伪事件，调用方式：</p>\r\n<pre class="brush:javascript">\r\n \r\nmyEvent.ready(function () {\r\n    //[code..]\r\n});\r\n</pre>\r\n<p>hashchange事件可以采用标准方式绑定：</p>\r\n<pre class="brush:javascript">\r\n \r\nmyEvent.bind(window, ''hashchange'', function () {\r\n    //[code..]\r\n});\r\n</pre>\r\n<p>这里有一些文章值得阅读：<br />\r\n<a href="http://www.cnblogs.com/rubylouvre/archive/2010/03/26/1696182.html">javascript 跨浏览器的事件系统</a>(司徒正美。他博客有一系列的讲解)<br />\r\n<a href="http://typeof.net/2010/08/compatibility-with-elegance/">更优雅的兼容</a>（BELLEVE INVIS）</p>', 'JavaScript', '2011-04-15 8:27:30'),
(507, '', '<p><a href="https://lijing00333.wordpress.com/2011/02/08/%e6%95%b0%e7%bb%84%e5%8e%bb%e9%87%8d%e2%80%94%e2%80%94%e4%b8%80%e9%81%93%e5%89%8d%e7%ab%af%e6%a0%a1%e6%8b%9b%e8%af%95%e9%a2%98/">https://lijing00333.wordpress.com/2011/02/08/%e6%95%b0%e7%bb%84%e5%8e%bb%e9%87%8d%e2%80%94%e2%80%94%e4%b8%80%e9%81%93%e5%89%8d%e7%ab%af%e6%a0%a1%e6%8b%9b%e8%af%95%e9%a2%98/ </a></p>\r\n<h2 class="entry-title">数组去重&mdash;&mdash;一道前端校招试题</h2>\r\n<p>很多校招题是没有严格的标准答案的，只有知识点，只要几个关键点能答上来，不管程序是否真的能跑通，都可以拿分的。比如最常见的一道题：</p>\r\n<p>试题：<br />\r\n有这样一个数组，成员都是数字，例如<br />\r\nvar a = [1,2,3,4,5,2,3,4,6,7,8];<br />\r\n请实现a.distinct()方法，用来给数组a去掉重复值，要求对Array的原型进行扩展方法，并尽可能做到效率最优。</p>\r\n<p>考察点：<br />\r\n1，考察应试者是否理解原型链<br />\r\n2，考察应试者是否由意识的控制算法的时间复杂度，了解应试者对专业课知识的掌握程度<br />\r\n3，考察应试者对js数组函数的了解程度</p>\r\n<p>答案1：</p>\r\n<p>Array.prototype.distinct = function(){<br />\r\nvar a = [],b=[],oa = this.concat();<br />\r\nfor(var i = 1;i&lt;oa.length;i++){<br />\r\nfor(var j = 0;j&lt;i;j++){<br />\r\nif(b.indexOf(j)&gt;-1)continue;<br />\r\nif(oa[j] == oa[i]){<br />\r\nb.push(j);<br />\r\n}<br />\r\n}<br />\r\n}<br />\r\nthis.splice(0,this.length);<br />\r\nfor(var i = 0;i&lt;oa.length;i++){<br />\r\nif(b.indexOf(i)&gt;-1)continue;<br />\r\nthis.push(oa[i ]);<br />\r\n}<br />\r\nreturn this;<br />\r\n};</p>\r\n<p>\r\n<p>答案2：</p>\r\n<p>Array.prototype.distinct = function(){<br />\r\nfor(var i = 0;i&lt;this.length;i++){<br />\r\nvar n = this[i ];<br />\r\nthis.splice(i,1,null);<br />\r\nif(this.indexOf(n) &lt; 0){<br />\r\nthis.splice(i,1,n);//不存在重复<br />\r\n}else{<br />\r\nthis.splice(i,1);//存在重复<br />\r\n}<br />\r\n}<br />\r\nreturn this;<br />\r\n};</p>\r\n<p>答案3：</p>\r\n<p>Array.prototype.distinct = function(){<br />\r\nvar self = this;<br />\r\nvar _a = this.concat().sort();<br />\r\n_a.sort(function(a,b){<br />\r\nif(a == b){<br />\r\nvar n = self.indexOf(a);<br />\r\nself.splice(n,1);<br />\r\n}<br />\r\n});<br />\r\nreturn self;<br />\r\n};</p>\r\n<p>得分点：<br />\r\n1，应试者起码应该自觉通过Array.prototype.distince来实现函数，若没有这样做，则扣分50%<br />\r\n2，应试者起码会给出答案1，得分30%，如果没有使用splice和concate，扣分20%<br />\r\n3，给出答案2的，得分80%，算法复杂度控制在O(n)<br />\r\n4，给出答案3的，得满分，算法复杂度控制在O(1)</p>\r\n</p>', 'JavaScript', '2011-04-15 8:39:31'),
(508, '', 'concat() 方法用于连接两个或多个数组。\r\n\r\n该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。\r\n', 'JavaScript', '2011-04-15 8:39:56');
INSERT INTO `list` (`id`, `title`, `content`, `cat`, `time`) VALUES
(509, '', '<p>http://news.cnblogs.com/n/97229/</p>\r\n<p id="page-note">　　本文是从 <a href="http://patrickavella.com/blog/5-reasons-your-javascript-stinks">5 Reasons Your Javascript Stinks</a> 这篇文章翻译而来。</p>\r\n<p>　　Javascript在互联网上名声很臭，但你又很难再找到一个像它这样如此动态、如此被广泛使用、如此根植于我们的生活中的另外一种语言。它的低学习门槛让很多人都称它为学前脚本语言，它另外一个让人嘲笑的东西是动态语言的概念是偏偏使用了高标准的静态数据类型。其实，你和Javascript都站错了立场，而现在，你让Javascript很生气。这里有五个原因能说明你的Javascript技术很烂。</p>\r\n<p>　　<strong>1. 你没有使用命名空间。</strong></p>\r\n<p>　　是否还记得在大学里老师告诉你不要在家庭作业里使用全局变量？Javascript里的全局变量的使用方法也不例外。Web网页稍不留神就会变的混乱不堪、到处都是从互联网上各个角落里找来的乱糟糟的相互侵犯的脚本和脚本库。如果你把一个变量命名成loader()，那你是成心自找麻烦。如果你在无意识的情况下重载了一个函数，Javascript根本不会提醒你。你还把它叫做一种学前教育编程语言，还记得吧？我要说的是，你需要知道在做了这些后发生什么情况。</p>\r\n<blockquote>\r\n<p>function derp(){ alert(&ldquo;one&rdquo;); }<br />\r\nfunction derp(){ alert(&ldquo;two&rdquo;); }<br />\r\nderp();</p>\r\n</blockquote>\r\n<p>　　&ldquo;two&rdquo;，答案是&ldquo;two&rdquo;。并不是一定会这样，它也可能是&ldquo;one&rdquo;。所以，把你所有的代码都放在自己的命名空间里，这很容易。下面是定义自己的命名空间的一个简单做法。</p>\r\n<blockquote>\r\n<p>var foospace={};<br />\r\nfoospace.derp=function(){ alert(&ldquo;one&rdquo;); }<br />\r\nfunction derp(){ alert(&ldquo;two&rdquo;); }<br />\r\nfoospace.derp();</p>\r\n</blockquote>\r\n<p>　　<strong>2. 你在变戏法，你把变量定义的东一个西一个。</strong></p>\r\n<p>　　你使用莫名其妙的数字字母组合作为变量名是一个双输的结局。在40行的代码块中寻找一个不带任何表意的字符变量，对于维护工作来说简直是场噩梦。把对变量的第一次声明混合到一个40行的代码块里同样也是一场噩梦。即使你自己遇到这样的变量时，你也要不由的问自己：&ldquo;这是在哪里定义的？&rdquo;，然后迅速的使用Ctrl+F组合在源代码里寻找这个变量最初定义的位置。不，不要这样，相反，这是对Javascript的滥用，是一种愚蠢的做法。你应该始终把变量定义在它的使用范围的顶部。并不能说因为这不是必须的，你就可以不这样做。</p>\r\n<blockquote>\r\n<p>function(){<br />\r\nvar a,//description<br />\r\nb; //description<br />\r\n//process&hellip;<br />\r\n}</p>\r\n</blockquote>\r\n<p>　　<strong>3. 你没有理解Javascript的变量范围。</strong></p>\r\n<p>　　你是个天才的程序员，你吃的是C++、拉的是List。你知道什么是变量范围，你对你的变量有完全的控制，你就像太上皇似的的注视着它们。然而，Javascript却在你的咖啡里拉了一泡屎，并且大笑不止。</p>\r\n<blockquote>\r\n<p>var herp=&rdquo;one&rdquo;;<br />\r\n{<br />\r\nvar herp=&rdquo;two&rdquo;;<br />\r\n}<br />\r\nalert(herp);</p>\r\n</blockquote>\r\n<p>　　在这种情况下你得到的<tt>herp</tt>不是&ldquo;one&rdquo;，而是&ldquo;two&rdquo;。Javascript的变量有效范围并不是跟其它语言一样依赖于代码块。Javascript的变量范围是以<strong>函数</strong>为基础的。每个函数都有它自己的变量范围，Javascript这一点上表现的很酷，根本不理睬这毫无意义的花括弧包起来的范围。事实上，Javascript是如此的酷，以至于你甚至可以将变量范围像命名空间或变量那样进行传递。</p>\r\n<p>　　<strong>4. 你以为Javascript的面向对象特征只是嫁接而来的。</strong></p>\r\n<p>　　Javascript，自从呱呱落地起，它就是一个面向对象的语言。所有的东西在Javascript里都是对象，所有的！甚至数字和字符这样的文字符号都可以通过它自身固有的构造器转化成对象。跟其它面向对象的语言比起来，Javascript的不同之处在于，它没有类(class)。Javascript对象像函数那样定义，甚至函数自己也是对象。Javascript有个属性叫做<strong>prototype</strong>，所有对象里都内置了这个属性，你可以通过它来改变对象的构造，修改对象、添加更多的变量、更多的功能。</p>\r\n<blockquote>\r\n<p>var derp; //will hold a Herp instance<br />\r\nvar Herp= function(){<br />\r\nthis.opinion=&rdquo;Javascript is cooler than BASIC.&rdquo;;<br />\r\n}<br />\r\nHerp.prototype.speak=function(){ alert(this.opinion); }<br />\r\nvar derp= new Herp();<br />\r\nderp.speak();</p>\r\n</blockquote>\r\n<p>　　如果这个看起来跟你毫不相干，我愿意介绍我的好朋友Google给你，Google擅长于帮助人们学习知识。面向对象对于我这篇简短的、低姿态的文章来说实在是个太大的话题。</p>\r\n<p>　　<strong>5. 你使用&ldquo;new&rdquo;关键字时就像是盲人瞎马。</strong></p>\r\n<p>　　Javascript肯定是你的初恋女友，因为你显得无所适从。如果你想像真人那样取悦Javascript，你需要去了解对象符号。除了在需要实例化一个对象，或罕见的需要延时加载数据的情况外，你基本上不需要使用<strong>new</strong>关键字。在Javascript里分配大量的<strong>new</strong>变量地址是一项很慢的操作，为了效率起见，你应该始终使用对象符号。</p>\r\n<blockquote>\r\n<p>var rightway= [1, 2, 3];<br />\r\nvar wrongway= new Array(1, 2, 3);</p>\r\n</blockquote>\r\n<p>　　是否还记得我说过Javascript的变量范围是以函数为基础的？是否还记得有人说Javascript的对象像函数那样定义？如果你不使用<strong>new</strong>关键字来声明一个对象，你将会使这个对象成为全局范围内的对象。所以，永远使用<strong>new</strong>关键字来声明对象是一个好习惯。</p>\r\n<blockquote>\r\n<p>var derp=&rdquo;one&rdquo;;<br />\r\nvar Herp=function(){<br />\r\nthis.derp=&rdquo;two&rdquo;;<br />\r\n}<br />\r\nvar foo=Herp();<br />\r\nalert(derp);</p>\r\n</blockquote>\r\n<p>　　如果你这样写，Javascript并不会在意，而你真正弹出的答案是&ldquo;two&rdquo;！有很多方法可以防止对象做出这样的行为，可以以使用<strong>instanceOf</strong>，但更好的方法是正确的使用<strong>new</strong>关键字，这样显得更专业。</p>\r\n<p>　　现在你知道你的Javascript代码写的很烂了吧，如果你记住了上面所说的东西，你的代码就会有所改善。我喜欢用3个tab键来缩进代码，我喜欢用下划线来连接单词，我喜欢把函数名首字母大写来表示它是对象。当然，这个是另外一场讨论了。有很多原因会导致你的Javascript代码写的很烂，就像我有很多技术很烂一样，所以，尽情的在评论里表达你的意见，支持，反对，不吝赐教。</p>\r\n<p>　　非常感谢rogeliorv和 <a href="http://msujaws.wordpress.com/">Jared Wein</a>指出第五点中存在的错误。你们很强。</p>', 'JavaScript', '2011-04-15 8:40:18'),
(510, '', '<h2>页面元素拖拽 -- HTML中的setCapture和releaseCapture</h2>\r\n<p>setCapture函数的作用就是将后续的mouse事件都发送给这个对象，releaseCapture就是将鼠标事件还回去，由 document、window、object之类的自行来处理，这样就保证了在拖动的过程中，不会由于经过了其它的元素而受到干扰。另外，还有一个很重要的事情是，在Win32上，mouse move的事件不是一个连续的，也就是说，并不是我们每次移动1px的鼠标指针，就会发生一个mousemove，windows会周期性检查mouse 的位置变化来产生mousemove的事件。所以，如果是一个很小的页面对象，比如一个直径5px的圆点，如果没有setCapture和 releaseCapture，那么在鼠标按住之后，快速的移动鼠标，就有可能鼠标移动走了，但是小圆点还在原地，就是因为下一次的mousemove事件已经不再发给这个圆点对象了。</p>', 'JavaScript', '2011-04-15 8:40:36'),
(511, '', '<h2><a id="ctl02_TitleUrl" href="http://www.cnblogs.com/PrimerDotNet/archive/2011/04/14/2015548.html">Javascript 面试题随笔之Function.call.call</a></h2>\r\n\r\n<p>今天无聊在群里面看到了一道面试题：</p>\r\n<pre title="code" class="brush: jscript;">\r\nfunction f1(){\r\n   alert("1");\r\n}\r\nfunction f2(){\r\n   alert("2");\r\n}\r\nvar f3=f1.call;\r\nf3.call(f2);\r\n</pre>\r\n\r\n<p>输出结果是2，后来想了一下，实在是让我大感JS的有趣，我的理解也不一定是正确的，只是想说出来，望有高手指正：我是这么理解：call函数是Function.prototype里面的函数，他在f1.call的情况下能调用f1，所以他的实现应该至少可以类似于<p>\r\n<pre title="code" class="brush: jscript;">\r\n Function.prototype.call = function(thispointer, arg1, arg2){\r\n	  thispointer = thispointer || window;\r\n	  thispointer.func = this;\r\n	  thispointer.func(arg1, arg2);\r\n	  delete thispointer.func;\r\n}\r\n</pre>\r\n\r\n<p>当f1.call.call(f2)被调用时，实际上的执行过程是：</p>\r\n<pre title="code" class="brush: jscript;">\r\nthispointer = f2;\r\nf2.func = f1.call;\r\nf2.func();\r\ndelete f2.func;\r\n</pre>\r\n<p>所以可以得到是f2.call()被调用了。就这样子。</p>', 'JavaScript', '2011-04-15 8:40:53'),
(512, '', '<p><a href="http://my.oschina.net/caiyuan/blog/13836">如何编写高质量的Javascript代码</a></p>', 'JavaScript', '2011-04-15 9:23:11');
